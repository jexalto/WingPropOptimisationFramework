<!doctype html>
<html>
<head>
<title>OpenMDAO Model Hierarchy and N2 diagram</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script type="text/javascript">
window.addEventListener("error", handleError, true);
function handleError(evt) {

    // Cannot define this color in Style since hasn't been loaded yet
    // Cannot call anything in any of the diagram JavaScript code because nothing has been loaded
    document.body.style.background = '#db9f9f';
    document.getElementById("show-error-button-container").style.visibility = 'visible';

    document.getElementById('show-error-button').onclick = function() {
       if (evt.error) { // Chrome sometimes provides this
         alert("An error has occured while displaying the diagram. This error should be reported as an " +
               "issue to the OpenMDAO developers.\n\n" +
               "Error: " + evt.message + "\n\n" +
               "Stack trace: \n" + evt.error.stack + "\n" );
       } else {
         alert("An error has occured while displaying the diagram. This error should be reported as an issue " +
               "to the OpenMDAO developers. \n\n" +
               "For more details about the error, please look in the browser's Console using the menu item:\n\n" +
               "    Develop -> Show JavaScript Console");
       }
    }
}

</script>

<style type="text/css">
#n2-windows {
    position: absolute;
    width: 100vw;
    height: 100vw;
}

#n2-windows div {
    position: absolute;
}

.n2-windows-modal-bg {
    width: 100vw;
    height: 100vw;
    opacity: 0.6;
    background-color: black;
}

.main-window {
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
}

.window-contents {
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
}

/* Use "visibility:hidden" instead of "display: none" here
   because "display: none" will caused certain operations
   and calculations on the window to fail. */
.window-inactive {
    visibility: hidden;
}

/* For when the window or window component will not be used
   or manipulated at all. */
.window-unused {
    display: none;
}

.window-draggable-ribbon {
    cursor: grab;
}

/* vvvvvvvvvv Begin N2 Window resizing styles vvvvvvvvvv */
:root {
    --resize-overflow: -2px;
    --resize-edge-size: 5px;
    --resize-corner-size: 10px;
}

.resize {
    top: var(--resize-overflow);
    left: var(--resize-overflow);
    right: var(--resize-overflow);
    bottom: var(--resize-overflow);
    display: block;
    opacity: 0;
    pointer-events: none;
    background-color:none;
}

.resize>div {
    pointer-events: auto;
}

.rsz-horizontal {
    height: var(--resize-edge-size);
    left: var(--resize-corner-size);
    right: var(--resize-corner-size);
}
.rsz-horizontal:hover { cursor: ns-resize; }

.rsz-top { top: 0; }
.rsz-bottom { bottom: 0; }

.rsz-vertical {
    width: var(--resize-edge-size);
    top: var(--resize-corner-size);
    bottom: var(--resize-corner-size);
}
.rsz-vertical:hover { cursor: ew-resize; }

.rsz-right { right: 0; }
.rsz-left { left: 0; }

.rsz-corner {
    height: var(--resize-corner-size);
    width: var(--resize-corner-size);
}

.rsz-top-right { top: 0; right: 0; cursor: nesw-resize; }
.rsz-bottom-right { bottom: 0; right: 0; cursor: nwse-resize; }
.rsz-bottom-left { bottom: 0; left: 0; cursor: nesw-resize; }
.rsz-top-left { top: 0; left: 0; cursor: nwse-resize; }

/* ^^^^^^^^^^ End N2 Window resizing styles ^^^^^^^^^^ */


/* vvvvvvvvvv Begin Default N2 Window theme vvvvvvvvvv */
.window-theme-default {
    --header-height: 30px;
    --ribbon-color: #42926b;

    background-color: white;
    border: 1px solid #a0a0a0;
    transition: opacity 0.25s;
    box-shadow: 3px 3px 3px 1px rgba(0, 0, 0, 0.2);

    border-radius: 10px;
    overflow: hidden;
}

.window-theme-default .window-header {
    background-color: var(--ribbon-color);
    margin: 0;
    font-size: 11pt;
    text-align: right;
    white-space: nowrap;
    height: var(--header-height);
    top: 0;
    left: 0;
    right: 0;
    bottom: auto;
}

.window-theme-default .window-close-button::before {
    content: '\2715'
}

.window-theme-default .window-close-button {
    color: none;
    opacity: 0.4;
    text-shadow: -0.5px -0.5px 0.5px black, 0.5px 0.5px 0.5px white;
    position: absolute;
    top: 0px;
    right: 8px;
    cursor: pointer;
    margin: 0;
    font-size: 12pt;
    font-weight: bold;
    line-height: var(--header-height);
    padding: 0;
}

.window-theme-default .window-close-button:hover,
.window-theme-default .window-close-button:focus {
    color: #333;
    text-decoration: none;
    cursor: pointer;
}

.window-theme-default .window-header .window-title {
    color: white;
    display: block;
    font-weight: bold;
    line-height: var(--header-height);
    position: relative;

    /* Stuff to prevent title bar from being too long */
    text-overflow: ellipsis;
    overflow: hidden;
    width: auto;
    direction: rtl;
    text-align: center;
    margin-left: 15px;
    margin-right: 25px;
}

.window-theme-default .window-body {
    color: black;
    border: 0;
    margin: 0;
    padding: 0;

    top: var(--header-height);
    left: 0;
    right: 0;
    bottom: var(--footer-height);
}

.window-theme-default .window-footer {
    display: none;
}

/* ^^^^^^^^^^ End Default N2 Window theme ^^^^^^^^^^ */

/* vvvvvvvvvv Begin Node Info N2 Window theme vvvvvvvvvv */
.window-theme-node-info {
    --header-height: 26px;
    --footer-height: 15px;
    --ribbon-color: #42926b;

    background-color: white;
    border: 1px solid #a0a0a0;
    transition: opacity 0.25s;
    box-shadow: 3px 3px 3px 1px rgba(0, 0, 0, 0.2);
    border-radius: 10px;
    overflow: hidden;
}

.window-theme-node-info .window-header {
    background-color: var(--ribbon-color);
    margin: 0;
    font-size: 11pt;
    text-align: right;
    white-space: nowrap;
    height: var(--header-height);
    top: 0;
    left: 0;
    right: 0;
    bottom: auto;
}

.window-theme-node-info .window-close-button::before {
    content: '\2715'
}

.window-theme-node-info .window-close-button {
    color: none;
    opacity: 0.4;
    text-shadow: -0.5px -0.5px 0.5px black, 0.5px 0.5px 0.5px white;
    position: absolute;
    top: 0px;
    right: 8px;
    cursor: pointer;
    margin: 0;
    font-size: 12pt;
    font-weight: bold;
    line-height: var(--header-height);
    padding: 0;
}

.window-theme-node-info .window-close-button:hover,
.window-theme-node-info .window-close-button:focus {
    color: #333;
    text-decoration: none;
    cursor: pointer;
}

.window-theme-node-info .window-header .window-title {
    color: white;
    display: block;
    font-weight: bold;
    line-height: var(--header-height);
    position: relative;

    /* Stuff to prevent title bar from being too long */
    text-overflow: ellipsis;
    overflow: hidden;
    width: auto;
    direction: rtl;
    text-align: center;
    margin-left: 15px;
    margin-right: 25px;
}

.window-theme-node-info .window-body {
    color: black;
    border: 0;
    margin: 0;
    padding: 0;

    top: var(--header-height);
    left: 0;
    right: 0;
    bottom: var(--footer-height);
}

.window-theme-node-info .window-footer {
    background-color: var(--ribbon-color);
    color: white;

    height: var(--footer-height);
    top: auto;
    bottom: 0;
    left: 0;
    right: 0;
}

.window-theme-node-info table {
	overflow: hidden;
	background-color: white;
    min-width: 200px;
    border-collapse: separate;
    border-spacing: 0;
    /* width: fit-content; */
    width: 100%;
    height: fit-content;
}

.window-theme-node-info table tbody th {
    text-align: right;
    font-size: 9pt;
    margin-top: 0;
    border-top: 0;
    border-bottom: 1px solid #a0a0a0;
    border-right: 1px solid #a0a0a0;
    padding: 3px;
    white-space: nowrap;
}

.window-theme-node-info table tbody .options-header {
    background-color: #eeeeee;
    text-align: center;
}

.window-theme-node-info table tbody td {
    text-align: left;
    font-size: 9pt;
    margin-top: 0;
    margin-left: 0;
    border-top: 0;
    border-left: 0;
    border-bottom: 1px solid #a0a0a0;
    padding: 3px;
    white-space: nowrap;
}

.caps {
    text-transform: capitalize;
}

.node-info-data {
    display: none;
}

.info-header {
	background-color: #42926b;
}

.info-header p {
	color: white;
	text-align: center;
}

.node-data-cursor {
    cursor: context-menu;
}

/* ^^^^^^^^^^ End Node Info N2 Window theme ^^^^^^^^^^ */


/* vvvvvvvvvv Begin Value Info N2 Window theme vvvvvvvvvv */
.window-theme-value-info {
    --header-height: 26px;
    --footer-height: 15px;
    --ribbon-color: #42926b;

    background-color: white;
    border: 1px solid #a0a0a0;
    /* transition: opacity 0.25s; */
    box-shadow: 3px 3px 3px 1px rgba(0, 0, 0, 0.2);
    border-radius: 10px;
    
    overflow: hidden;
}

.window-theme-value-info .window-header {
    background-color: var(--ribbon-color);
    margin: 0;
    font-size: 11pt;
    text-align: right;
    white-space: nowrap;
    height: var(--header-height);
    top: 0;
    left: 0;
    right: 0;
    bottom: auto;
}

.window-theme-value-info .window-close-button::before {
    content: '\2715'
}

.window-theme-value-info .window-close-button {
    color: none;
    opacity: 0.4;
    text-shadow: -0.5px -0.5px 0.5px black, 0.5px 0.5px 0.5px white;
    position: absolute;
    top: 0px;
    right: 8px;
    cursor: pointer;
    margin: 0;
    font-size: 11pt;
    font-weight: bold;
    line-height: var(--header-height);
    padding: 0;
}

.window-theme-value-info .window-close-button:hover,
.window-theme-value-info .window-close-button:focus {
    color: #333;
    text-decoration: none;
    cursor: pointer;
}

.window-theme-value-info .window-header .window-title {
    color: white;
    display: block;
    font-weight: bold;
    line-height: var(--header-height);
    position: relative;

    /* Stuff to prevent title bar from being too long */
    text-overflow: ellipsis;
    width: auto;
    direction: rtl;
    text-align: center;
    margin-left: 15px;
    margin-right: 25px;
}

.window-theme-value-info .window-header .window-title::after {
    content: ' Value';
}

.window-theme-value-info .window-body {
    color: black;
    border: 0;
    margin: 0;
    padding: 0;

    top: var(--header-height);
    left: 0;
    right: 0;
    bottom: var(--footer-height);
    overflow: scroll;
    visibility: visible;
    border: 1px solid gray;

}

.window-theme-value-info .window-footer {
    background-color: var(--ribbon-color);
    color: white;

    height: var(--footer-height);
    top: auto;
    bottom: 0;
    left: 0;
    right: 0;
}

/* Value window table */
.window-theme-value-info .window-body table {
	overflow: hidden;
	background-color: white;
    min-width: 200px;
    border-collapse: separate;
    border-spacing: 0;
    margin: 0;
    padding: 0;
    border: 0;
}

.window-theme-value-info .window-body table tbody tr th {
    text-align: center;
    font-size: 8pt;
    margin: 0;
    border-top: 0;
    border-bottom: 1px solid #a0a0a0;
    border-right: 1px solid #a0a0a0;
    background-color: #c0c0c0;
    padding: 3px;
    white-space: nowrap;

    color: #202020;
    min-width: 30px;
    font-weight: 300;
}

.window-theme-value-info .window-body table tbody tr th:last-child,
.window-theme-value-info .window-body table tbody tr td:last-child {
    border-right: 0;
}

.window-theme-value-info .window-body table tbody tr:last-child th,
.window-theme-value-info .window-body table tbody tr:last-child td {
    border-bottom: 0;
}

.window-theme-value-info .window-body table tbody tr td {
    text-align: left;
    font-size: 9pt;
    margin: 0;    
    border-top: 0;
    border-left: 0;
    border-bottom: 1px solid #a0a0a0;
    border-right: 1px solid #a0a0a0;
    padding: 3px;
    white-space: nowrap;
}

.show_value_button {
    background-color: #c1c1c1;
 }
 
 .copy_value_button {
    background-color: #c1c1c1;
 }

 /* this is an off screen element that is used in the strange way you
   need to put content on the clipboard.
   It has to have visibility of visible to work
 */
#input-for-pastebuffer {
    visibility: visible;
    position: absolute;
    left: -999em;
}

/* ^^^^^^^^^^ End Node Value N2 Window theme ^^^^^^^^^^ */

/* vvvvvvvvvv Begin Help N2 Window theme vvvvvvvvvv */
.window-theme-help {
    --header-height: 42px;
    --footer-height: 32px;
    --ribbon-color: steelblue;

    background-color: white;
    border: 1px solid #a0a0a0;
    transition: opacity 0.25s;
    box-shadow: 3px 3px 3px 1px rgba(0, 0, 0, 0.2);

    border: 2px solid white;
    border-radius: 0;
    overflow: hidden;
}

.window-theme-help .window-header {
    background-color: var(--ribbon-color);
    margin: 0;
    text-align: right;
    white-space: nowrap;
    height: var(--header-height);
    top: 0;
    left: 0;
    right: 0;
    bottom: auto;
}

.window-theme-help .window-close-button::before {
    content: '\2715'
}

.window-theme-help .window-close-button {
    color: none;
    opacity: 0.5;
    text-shadow: -0.5px -0.5px 0.5px black, 0.5px 0.5px 0.5px white;
    position: absolute;
    top: 0px;
    right: 8px;
    cursor: pointer;
    margin: 0;
    font-size: 12pt;
    font-weight: bold;
    line-height: var(--header-height);
    padding: 0;
}

.window-theme-help .window-close-button:hover,
.window-theme-help .window-close-button:focus {
    color: #333;
    text-decoration: none;
    cursor: pointer;
}

.window-theme-help .window-header .window-title {
    color: white;
    display: block;
    font-weight: normal;
    line-height: var(--header-height);
    position: relative;

    /* Stuff to prevent title bar from being too long */
    text-overflow: ellipsis;
    overflow: hidden;
    width: auto;
    text-align: left;
    font-size: 20px;
    padding-left: 10px;
}

.window-theme-help .window-body {
    color: black;
    border: 0;
    margin: 0 0 0 15px;
    padding: 0;

    top: var(--header-height);
    left: 0;
    right: 0;
    bottom: var(--footer-height);

    font-family: helvetica, sans-serif;
    font-size: 11pt;
}

.window-theme-help .window-body > svg {
    width: 100%;
    height: 100%;
}

.window-theme-help h3 {
    padding: 0;
    margin: 0;
}

.window-theme-help .window-footer {
    background-color: var(--ribbon-color);
    color: white;

    height: var(--footer-height);
    top: auto;
    bottom: 0;
    left: 0;
    right: 0;
}

.window-theme-help .window-footer span {
    color: white;
    display: block;
    line-height: var(--footer-height);
    position: relative;
    overflow: hidden;
    width: auto;
    text-align: left;
    font-family: helvetica, sans-serif;
    font-size: 12px;
    padding-left: 10px;
}

div#help-svg {
    width: 0;
    height: 0;
    overflow: hidden;
}

div.help-graphic {
    position: absolute;
    height: auto;
    width: 100%;
}

div.help-graphic > p {
    position: absolute;
    font: Helvetica;
    font-size: 10pt;
    padding: 0px 0 0px 5px;
    height: 30px;
    max-height: 30px;
    max-width: 165px;
    margin: -1px 0 0 0;
    z-index: 2;
    display: flex;
    justify-content: center;
    align-items: center;
    border-left: 2px solid black;
}

div.help-button-group {
    position: absolute;
    border-top-width: 1px;
    border-right-width: 1px;
    border-bottom-width: 1px;
    border-left-width: 0;
    border-color: green;
    border-style: solid;
    left: 500px;
    border-radius: 0px 10px 10px 0px;
    background-color: #e0e0e0;
    max-height: 100px;
    width: 380px;
    padding: 5px;
    
    display: flex;
    flex-flow: row wrap;
    justify-content: flex-start;
}

div.help-button-group > p {
    font: Helvetica;
    padding: 0;
    margin: 3px;
    flex: 1 1 auto;
}

p.help-text {
    display: flex;
    flex-direction: row;
    max-width: 180px;
}

i.help-text-icon {
    color: white;
    background-color: #42926b;
    padding: 5px;
    margin: 0 5px 0 0;
    height: 22px;
    font-size: 20px;
}

p.help-text > span {
    font-size: 10pt;
}

#help-graphic-svg {
    top: 0;
    left: 0;
    position: absolute;
    width: 100%;
    height: 100%;
    z-index: 1;
}

#help-graphic-svg .help-line {
    stroke: green;
    fill: #e0e0e0;
    stroke-width: 1;
}

/* ^^^^^^^^^^ End Help N2 Window theme ^^^^^^^^^^ */

/* vvvvvvvvvv Begin Legend N2 Window theme vvvvvvvvvv */
.window-theme-legend {
    --header-height: 20px;
    --ribbon-color: #42926b;

    background-color: none;
    border: 0;
    transition: opacity 0.25s;
    overflow: visible;
}

.window-theme-legend .window-header {
    background-color: var(--ribbon-color);
    margin: 0;
    font-size: 11pt;
    text-align: right;
    white-space: nowrap;
    height: var(--header-height);
    top: 0;
    bottom: auto;
    width: 100px;
    left: 50%;
    border-top-left-radius: 5px;
    border-top-right-radius: 5px;
    display: flex;
    justify-content: center;
    align-items: center;
    transform: translate(-50%, 0px);
}

.window-theme-legend .window-close-button::before {
    content: '\2715'
}

.window-theme-legend .window-close-button {
    color: none;
    opacity: 0.4;
    text-shadow: -0.5px -0.5px 0.5px black, 0.5px 0.5px 0.5px white;
    position: absolute;
    top: 0px;
    right: 8px;
    cursor: pointer;
    margin: 0;
    font-size: 12pt;
    font-weight: bold;
    line-height: var(--header-height);
    padding: 0;
}

.window-theme-legend .window-close-button:hover,
.window-theme-legend .window-close-button:focus {
    color: #333;
    text-decoration: none;
    cursor: pointer;
}

.window-theme-legend .window-header .window-title {
    color: white;
    display: block;
    font-weight: bold;
    line-height: var(--header-height);
    position: relative;

    margin-left: 5px;
    margin-right: 5px;
}

.window-theme-legend .window-header .window-title::before {
    content: ':::::: ';
}

.window-theme-legend .window-header .window-title::after {
    content: ' ::::::';
}

.window-theme-legend .window-body {
    color: black;
    border: 0;
    margin: 0;
    padding: 0;
    background-color: none;

    top: var(--header-height);
    left: 0;
    right: 0;
    bottom: var(--footer-height);
    overflow: visible;
}

.window-theme-legend .window-footer {
    display: none;
}

/* ^^^^^^^^^^ End Legend N2 Window theme ^^^^^^^^^^ */

/* vvvvvvvvvv Begin Child Select N2 Window theme vvvvvvvvvv */
.window-theme-child-select {
    --header-height: 26px;
    --footer-height: 15px;
    --ribbon-color: #0000a0;

    background-color: white;
    border: 1px solid #a0a0a0;
    /* transition: opacity 0.25s; */
    box-shadow: 3px 3px 3px 1px rgba(0, 0, 0, 0.2);
    border-radius: 10px;
    
    overflow: hidden;
}

.window-theme-child-select .window-header {
    background-color: var(--ribbon-color);
    margin: 0;
    font-size: 11pt;
    text-align: right;
    white-space: nowrap;
    height: var(--header-height);
    top: 0;
    left: 0;
    right: 0;
    bottom: auto;
}

.window-theme-child-select .window-close-button::before {
    content: '\2715'
}

.window-theme-child-select .window-close-button {
    color: none;
    opacity: 0.4;
    text-shadow: -0.5px -0.5px 0.5px black, 0.5px 0.5px 0.5px white;
    position: absolute;
    top: 0px;
    right: 8px;
    cursor: pointer;
    margin: 0;
    font-size: 11pt;
    font-weight: bold;
    line-height: var(--header-height);
    padding: 0;
}

.window-theme-child-select .window-close-button:hover,
.window-theme-child-select .window-close-button:focus {
    color: #333;
    text-decoration: none;
    cursor: pointer;
}

.window-theme-child-select .window-header .window-title {
    color: white;
    display: block;
    font-weight: bold;
    line-height: var(--header-height);
    position: relative;

    /* Stuff to prevent title bar from being too long */
    text-overflow: ellipsis;
    width: auto;
    direction: rtl;
    text-align: center;
    margin-left: 15px;
    margin-right: 25px;
}

.window-theme-child-select .window-header .window-title::after {
    content: ' Variables';
}

.window-theme-child-select .window-body {
    color: black;
    border: 0;
    margin: 0;
    padding: 0;

    top: var(--header-height);
    left: 0;
    right: 0;
    bottom: var(--footer-height);
    overflow: hidden;
    visibility: visible;
    border: 1px solid gray;
    min-width: 300px;
}

.window-theme-child-select .window-footer {
    background-color: var(--ribbon-color);
    color: white;

    height: var(--footer-height);
    top: auto;
    bottom: 0;
    left: 0;
    right: 0;
}

.window-theme-child-select table.header {
	overflow: hidden;
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    margin: 0;
    padding: 0;
    border: 0;
    top: 0px;
}

.window-theme-child-select table.header th {
    text-align: center;
    font-size: 8pt;
    margin: 0;

    border-top: 0;
    border-bottom: 1px solid #a0a0a0;
    border-right: 1px solid #a0a0a0;
    background-color: #c0c0c0;

    padding: 2px 3px 2px 3px;
    white-space: nowrap;

    color: #202020;
    font-weight: 300;
}

.window-theme-child-select table.header th.varvis {
    min-width: 40px;
}

/* Child select window table */
.window-theme-child-select .window-body .table-container {
    max-height: 280px;
    width: 100%;
    overflow-x: hidden;
    overflow-y: auto;
}

.window-theme-child-select .table-container table.variables {
	overflow: hidden;
	background-color: white;
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    margin: 0;
    padding: 0;
    border: 0;
    max-height: 280px;
}


.window-theme-child-select table.variables tr th:last-child,
.window-theme-child-select table.variables tr td:last-child {
    border-right: 0;
}

.window-theme-child-select table.variables tr:last-child th,
.window-theme-child-select table.variables tr:last-child td {
    border-bottom: 0;
}

.window-theme-child-select table.variables td {
    font-size: 9pt;
    margin: 0;    
    border-top: 0;
    border-left: 0;
    border-bottom: 1px solid #a0a0a0;
    border-right: 1px solid #a0a0a0;
    padding: 3px;
    white-space: nowrap;
}

.window-theme-child-select table.variables td.varname {
    text-align: left;
}

.window-theme-child-select table.variables td.varvis {
    text-align: center;
    min-width: 40px;
}

.window-theme-child-select table.variables tr.even td {
    background-color:white;
}

.window-theme-child-select table.variables tr.odd td {
    background-color: #d8ffff;
}

.window-theme-child-select .search-container {
    height: 21px;
    width: 100%;
    bottom: 23px;
    text-align: left;
    font-size: 8pt;
    border-top: 1px solid #a0a0a0;
    border-bottom: 1px solid #a0a0a0;
    padding: 2px 0 2px 0;
    background-color: #c0c0c0;
    white-space: nowrap;
    color: #202020;
}

.window-theme-child-select .search-label {
    padding-left: 10px;
    padding-right: 3px;
    font-style: italic;
}

.window-theme-child-select .search-container input {
    padding-left: 10px;
    border-radius: 5px;
    border: 1px solid #a0a0a0;
    background-color: #e0e0e0;
    width: 65%;
}

.window-theme-child-select .search-clear,
.window-theme-child-select .search-perform
 {
    height: 17px;
    width: 17px;
    border: 1px solid #808080;
    border-radius: 7px;
    text-align: center;
    padding: 0 2px 0 2px;
    margin: 0 0 0 3px;
    font-size: 8pt;
    color: #c0c0c0;
    background-color: #909090;
}

.window-theme-child-select .search-clear:hover,
.window-theme-child-select .search-perform:hover,
.window-theme-child-select .search-clear:focus,
.window-theme-child-select .search-perform:focus {
    color:black;
    text-decoration: none;
    cursor: pointer;
}

.window-theme-child-select .button-container {
    height: 21px;
    width: 100%;
    bottom: 2px;
    text-align: center;
}

.window-theme-child-select .button-container:not(:first-child) button {
    margin-left: 5px;
}

.window-theme-child-select .button-container button {
    font-size: 8pt;
}

.window-theme-child-select .sort-up,
.window-theme-child-select .sort-down {
    padding-right: 3px;
    padding-left: 3px;
    color: #404040;
    font-size: 8pt;
}

.window-theme-child-select .sort-up:hover,
.window-theme-child-select .sort-up:focus,
.window-theme-child-select .sort-down:hover,
.window-theme-child-select .sort-down:focus {
    color:blue;
    text-decoration: none;
    cursor: pointer;
}

.window-theme-child-select .scrollbar-spacer {
    margin: 0;
    padding: 0;
    min-width: 0;
}


/* ^^^^^^^^^^ End Child Select Window theme ^^^^^^^^^^ */

.scrollable {
    overflow-y: scroll;
    overflow-x: hidden;
}

</style>
<style type="text/css">
input:focus, select:focus, textarea:focus, button:focus {
    outline: none;
}

body {
    position: absolute;
    top: 0;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    font-family: helvetica, sans-serif;
    margin: 0;
    padding: 0;
    background-color: white;
}

#all-diagram-content {
    position: absolute;
    width: 100vw;
    z-index: 5;
}

#diagram-content {
    display: flex;
    flex: 0 0 auto;
}

#d3_content_div {
    display: flex;
    flex: auto;
    height: 100vh;
    align-items: flex-start;
    justify-content: baseline;
    overflow: auto;
    position: relative;
    margin-left: -75px;
    transition: margin-left 0.4s;
}

#svgDiv {
    position: absolute;
    top: 5px;
    left: 30px;
    z-index: 2;
    display: flex;
    overflow: visible;
}

#svgId {
    position: absolute;
    top: 0;
    left: 0;
    display: flex;
    flex: 0 0 auto;
    transform-origin: 0 0;
}

#n2-resizer-box {
    position: absolute;
    right: -5px;
}

.inactive-resizer-box {
    visibility: visible;
    left: auto;
    border: 3px solid transparent;
    pointer-events: none;
}

.active-resizer-box {
    left: -3px;
    visibility: visible;
    border: 3px dashed #98daba;
    pointer-events: initial;
}

.hidden-resizer-box {
    visibility: hidden;
}

#n2-resizer-handle {
    position: absolute;
    margin: 0;
    height: 18px;
    cursor: nwse-resize;
    pointer-events: initial;
    overflow: hidden;
}

.inactive-resizer-handle::before {
    content: '\25a8';
}

.inactive-resizer-handle {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0) 54%, rgba(255, 255, 255, 1) 55%, rgba(255, 255, 255, 1) 100%);
    font-size: 20px;
    right: 0;
    bottom: 0px;
    border: 0;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    -moz-background-clip: text;
    -moz-text-fill-color: transparent;
    font-weight: bold;
    text-align: right;
    vertical-align: bottom;
    width: 18px;
    padding: 0;
}

.inactive-resizer-handle-without-solvers::before {
    content: '\25a8';
}

.inactive-resizer-handle-without-solvers {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0) 54%, rgba(0, 0, 0, 1) 55%, rgba(0, 0, 0, 1) 100%);
    right: 13px;
    bottom: 1px;
    font-size: 20px;
    border: 0;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    -moz-background-clip: text;
    -moz-text-fill-color: transparent;
    font-weight: bold;
    text-align: right;
    vertical-align: bottom;
    width: 18px;
    padding: 0;
}

.active-resizer-handle {
    background: #98daba;
    border: 1px solid #98daba;
    border-bottom-right-radius: 0;
    color: #006000;
    font-size: 9pt;
    align-items: center;
    display: flex;
    width: auto;
    padding: 1px 5px 1px 5px;
}

@font-face {
    font-family: 'N2ToolbarIcons';
    src: url('data:application/font-woff;charset=utf-8;base64,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') format('woff');
}

.context-menu {
    display: none;
    position: absolute;
    z-index: 10;
    padding: 12px 0;
    width: 240px;
    background-color: #fff;
    border: solid 1px #dfdfdf;
    box-shadow: 1px 1px 2px #cfcfcf;
}

.context-menu--active {
    display: block;
}

.context-menu__items {
    list-style: none;
    margin: 0;
    padding: 0;
}

.context-menu__item {
    display: block;
    margin-bottom: 4px;
}

.context-menu__item:last-child {
    margin-bottom: 0;
}

.context-menu__link {
    display: block;
    padding: 4px 12px;
    color: #0066aa;
    text-decoration: none;
}

.context-menu__link:hover {
    color: #fff;
    background-color: #0066aa;
}

.tool-tip {
    z-index: 10000;
    font-size: 11px;
    padding: 5;
    background-color: #fff;
    border: solid 1px #dfdfdf;
    transition: visibility 0s ease 0.75s;
    -webkit-transition: visibility 0s ease 0.75s;
}

div.offgrid {
    z-index: 10;
    font-size: 11px;
    padding: 5;
    background-color: #fff;
    border: solid 1px #dfdfdf;
    position: absolute;
    opacity: 0.7;
}

.toolbar-help {
    width: auto;
    height: auto;
    padding: 0px 20px;
}

#logo-container {
    position: absolute;
    width: 70px;
    height: 60px;
    border-radius: 35px;
    background-color: white;
    opacity: 30%;
    bottom: 15px;
    right: 15px;
    z-index: 15;
    pointer-events: none;
}

#company-logo {
    position: absolute;
    max-width: 50px;
    height: 30px;
    left: 50%;
    margin-left: -25px;
    top: 50%;
    margin-top: -15px;
    pointer-events: none;
}

rect.diagHighlight {
    fill: black !important;
}

rect.inputHighlight {
    fill: salmon !important;
}

rect.outputHighlight {
    fill: seagreen !important;
}

.no-show {
    display: none;
}

.show {
    display: block;
}

#waiting-icon {
    position: absolute;
    width: 200px;
    height: 200px;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: auto;
    opacity: .7;
}

#waiting-container {
    width: 100vw;
    height: 100vh;
    position: relative;
    z-index: 999990;
    background: none;
}

.opt-vars {
    fill: #c5b0d5 !important;
}

#show-error-button-container {
    visibility: hidden;
    position: absolute;
    bottom: 250px;
    right: 115px;
    z-index: 5;
}

#show-error-button{
    background-color: red;
    border: none;
    color: white;
    padding: 12px 16px;
    font-size: 16px;
    cursor: pointer;
    border-radius: 5px;
    text-decoration: underline;
    box-shadow: 3px 3px 3px 1px rgba(0, 0, 0, 0.2);
}

</style>
<style type="text/css">
/** n2toolbar-icons.css ****************************************************
 *
 * AUTOMATICALLY GENERATED FILE - DO NOT EDIT DIRECTLY
 *
 * This file links unicode characters to styles for use as N2 icons.
 *
 * To generate it, cd to the N2 assets/toolbar_icons directory, and run
 *   ./gen_toolbar_icons.sh
 *
 * This file and the n2toolbar-icons-font.woff file will be overwritten.
 ***************************************************************************
 */
[class^="icon-"]:before,
[class*=" icon-"]:before {
    font-family:     "N2ToolbarIcons";
    font-style:      normal;
    font-weight:     normal;
    font-stretch:    normal;
    font-variant:    normal;
    font-size:       14px/1;
    text-rendering:  auto;
    display:         inline-block;
    transform:       translate(0, 0);
    speak:           none;
    text-decoration: inherit;
    text-align:      center;
    text-transform:  none;
    -webkit-font-smoothing:  antialiased;
    -moz-osx-font-smoothing: grayscale;
}

.icon-backward:before {
    content:         "\e001";
}
.icon-bezier-curve:before {
    content:         "\e002";
}
.icon-caret-right:before {
    content:         "\e003";
}
.icon-chevron-left:before {
    content:         "\e004";
}
.icon-collapse-depth:before {
    content:         "\e005";
}
.icon-collapse-target:before {
    content:         "\e006";
}
.icon-enlarge:before {
    content:         "\e007";
}
.icon-enlarge2:before {
    content:         "\e008";
}
.icon-filter-target:before {
    content:         "\e009";
}
.icon-floppy-disk:before {
    content:         "\e010";
}
.icon-forward:before {
    content:         "\e011";
}
.icon-fx-2:before {
    content:         "\e012";
}
.icon-hide-connections:before {
    content:         "\e013";
}
.icon-home2:before {
    content:         "\e014";
}
.icon-info-circle:before {
    content:         "\e015";
}
.icon-key:before {
    content:         "\e016";
}
.icon-linear-solver:before {
    content:         "\e017";
}
.icon-loadview:before {
    content:         "\e018";
}
.icon-model-height:before {
    content:         "\e019";
}
.icon-no-solver:before {
    content:         "\e020";
}
.icon-nonlinear-solver:before {
    content:         "\e021";
}
.icon-notification:before {
    content:         "\e022";
}
.icon-question-circle:before {
    content:         "\e023";
}
.icon-save:before {
    content:         "\e024";
}
.icon-savesvg:before {
    content:         "\e025";
}
.icon-saveview:before {
    content:         "\e026";
}
.icon-search:before {
    content:         "\e027";
}
.icon-show-connections:before {
    content:         "\e028";
}
.icon-shrink:before {
    content:         "\e029";
}
.icon-shrink2:before {
    content:         "\e030";
}
.icon-text-height:before {
    content:         "\e031";
}


</style>
<style type="text/css">
/******************* Toolbar styling *******************/

/* Search Bar */

#searchbar-container {
    align-self: flex-start;
    display: flex;
    align-items: center;
    flex-direction: row;
    margin-left: 12px;
    margin-bottom: 20px;
    z-index: 50;
    overflow: visible;
    height: 40px;
}

.search-button {
    background-color: rgba(0, 0, 0, 0);
    -moz-border-radius: 4px;
    -webkit-border-radius: 4px;
    border-radius: 4px;
    border: 1px solid #aaa;
    display: inline-block;
    cursor: pointer;
    color: #666666;
    font-size: 16px;
    text-align: center;
    text-decoration: none;
    width: 30px;
    max-width: 30px;
    height: 50px;
    max-height: 50px;
    margin: 30px 1px 2px 1px;
    border: 0px solid rgba(0, 0, 0, 0);
}

#searchbar-and-label {
    display: flex;
    flex-direction: column;
    margin-bottom: -10px;
}

.searchbar {
    width: 100%;
    display: flex;
    transition: border-color 0.5s, width 0.5s, margin-left 0.5s;
    margin-left: 8px;
    display: block;
    border: 1px solid rgba(0, 0, 0, 0);
    background-color: white;
    border-top-right-radius: 25px;
    border-bottom-right-radius: 25px;
    padding: 8px 8px;
    transition: border-color 0.5s, width 0.5s, margin-left 0.5s, visibility 0.5s;
}

.searchbar:focus {
    background: lightcyan;
}

.searchbar-hidden {
    overflow: hidden;
    visibility: hidden;
    width: 0px;
    transition: border-color 0.5s, width 0.5s, margin-left 0.5s, visibility 0.5s;
}

.searchbar-visible {
    overflow: visible;
    visibility: visible;
    width: 200px;
    transition: border-color 0.5s, width 0.5s, margin-left 0.5s, visibility 0.5s;
}

.searchbar-visible .searchbar {
    border-color: #03793f;
}

.searchbar-container label {
    font-size: 10pt;
    color: black;
    margin-left: 8px;
    transition: font-size 0.2s;
    transition-delay: 0.5s;
    width: 200px;
}

/* Toolbar Container*/

#toolbarLoc {
    margin: 0;
    padding: 0;
    /* height: 605px; */
    height: fit-content;
    padding-bottom: 7px;
    width: 65px;
    border-bottom-right-radius: 15px;
    position: relative;
    box-shadow: 20px 0px 35px rgba(0, 0, 0, 0.1);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    left: -65px;  /* Start hidden */
    transition: left 0.5s;
    z-index: 24;
    border-right: 1px solid gray;
    border-bottom: 1px solid gray;
}

.toolbar {
    display: flex;
    width: 100%;
    flex-direction: column;
    align-self: flex-start;
    align-items: center;
    justify-content: center;
    margin: 0;
    padding: 0;
    cursor: pointer;
    position: relative;
}

.toolbar-hide-container {
    background-color: white;
    width: 15px;
    height: 33px;
    border-top-right-radius: 25%;
    border-bottom-right-radius: 25%;

    position: absolute;
    top: 275px;
    margin-left: 20px;
    left: 45px;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    cursor: pointer;
    z-index: 24;
    transition: left 0.5s, transform 0.5s;
    border-top: 1px solid gray;
    border-right: 1px solid gray;
    border-bottom: 1px solid gray;
}

.toolbar-hide-container:hover>.hide-toolbar-button {
    color: green;
    transform: scale(1.25);
}

.toolbar-hide-container i {
    color: black;
    margin-right: 5px;
    cursor: pointer;
    transform: rotate(-180deg);
    /* Start hidden */
    transition: color 0.4s, transform 0.4s;
    font-size: 12px;
}

.toolbar-group-expandable {
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    width: 0px;
    padding: 2px 10px;
    border-top-right-radius: 20px;
    border-bottom-right-radius: 20px;
    align-items: center;
    max-width: 0;
    opacity: 0;
    min-height: 100%;
    transition: opacity 1s, max-width 1s;
}

.toolbar-group-expandable p {
    text-align: center;
    color: white;
    font-size: 10px;
    margin: 0;
}

.toolbar-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 50px;
    border-bottom-left-radius: 15px;
    border-bottom-right-radius: 15px;
    border-top-right-radius: 10px;
    border-top-left-radius: 10px;
    position: relative;
}

.expandable:hover>.toolbar-group-expandable {
    opacity: 1;
    width: auto;
    max-width: 200px;
    transition: opacity 1s, max-width 1s;
    pointer-events: initial;
}

.expandable {
    display: flex;
    flex-direction: row;
    align-self: flex-start;
    align-items: center;
}

.expandable i:first-of-type {
    margin-left: 15px;
}

.expandable>.toolbar-group-expandable {
    pointer-events: none;
}

/* Toolbar Groups */

.group-1 {
    background-color: #98daba;
    padding: 10px 0;
    z-index: 36;
}

.group-2 {
    background-color: #7dcda6;
    padding: 20px 0 5px 0;
    margin-top: -20px;
    z-index: 35;
    align-items: center;
}

.group-3 {
    background-color: #66b48e;
    padding: 20px 0 5px 0;
    margin-top: -20px;
    z-index: 34;
}

.group-4 {
    background-color: #42926b;
    padding: 20px 0 5px 0;
    margin-top: -20px;
    z-index: 33;
}

.group-5 {
    background-color: #30684d;
    padding: 20px 0 7px 0;
    margin-top: -20px;
    z-index: 32;
    flex-direction: row;
    align-items: center;
}

#collapse-expandable {
    background-color: #7dcda6;
}

#target-expandable {
    background-color: #7dcda6;
}

#connections-expandable {
    background-color: #66b48e;
}

#solvers-expandable {
    background-color: #66b48e;
}

#text-width-expandable {
    background-color: #42926b;
    display: flex;
    align-items: center;
}

#info-expandable {
    background-color: #30684d;
}

#text-width-expandable p {
    color: white;
    margin-left: 5px;
    width: 20px;
    font-weight: 600;
}

#model-height-expandable {
    background-color: #42926b;
    display: flex;
    align-items: center;
}

#model-height-expandable p {
    color: white;
    margin-left: 5px;
    width: 20px;
    font-weight: 600;
}

#model-depth-expandable {
    background-color: #42926b;
    display: flex;
    align-items: center;
}

#model-depth-expandable p {
    color: white;
    margin-left: 5px;
    width: 20px;
    font-weight: 600;
}

#depth-slider {
    -webkit-transform: rotate(-180deg);
    -moz-transform: rotate(-180deg);
    transform: rotate(-180deg);
}

/* Icon Styling */

.toolbar-group-expandable i {
    padding: 0px 8px;
}

.icon-search {
    color: #78d3a6;
    font-size: 24px;
}

.icon-backward {
    font-size: 13px !important;
}

.icon-forward {
	font-size: 13px !important;
}

.icon-collapse-target {
    font-size: 20px !important;
}

.icon-filter-target {
    font-size: 20px !important;
}

.toolbar .fas {
    margin: 7px 0;
    color: white;
    font-size: 20px;
    cursor: pointer;
    transition: color 0.2s;
}

.active-tab-icon {
    color: #06f !important;
    filter: drop-shadow(0 0 5px white);
}

.toolbar .fas:hover {
    color: #aeffa4;
}

.caret {
    opacity: 1;
    color: white !important;
    font-size: 15px !important;
    margin-left: 5px !important;
    transform: rotate('0deg');
    transition: transform 0.4s, opacity 0.4s;
}

.expandable:hover>.caret {
    transform: rotate(-180deg);
    opacity: 0.5;
    transition: transform 0.4s, opacity 0.4s;
}

#info-button {
    color: white;
    opacity: 1;
    transition: opacity 0.5s, color 0.5s;
}

.icon-question-circle {
    opacity: 1;
    color: white;
}

.collapse-mode-cursor {
    cursor: crosshair;
}

.filter-mode-cursor {
    cursor: zoom-in;
}

/* Slider */

.slider {
    -webkit-appearance: none;
    width: 100px;
    height: 8px;
    border-radius: 5px;
    background: white;
    outline: none;
    opacity: 0.7;
    -webkit-transition: 0.2s;
    transition: opacity 0.2s, background 0.3s;
    margin: 10px 0;
}

.slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #98daba;
    cursor: pointer;
}

.slider::-moz-range-thumb {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #98daba;
    cursor: pointer;
}

#depth-slider-label {
    min-width: 30px;
    text-align: center;
    font-size: 18px;
    border-radius: 50%;
    border: 1px solid white;
    color: white;
}

#model-slider-label {
    min-width: 30px;
    text-align: center;
}

#model-slider-fit {
    color: white;
    background: #42926b;
    border-radius: 40%;
    border: 1px solid white;
    padding: 5px;
    font-weight: 600;
    margin-left: 5px;
    -webkit-transition: 0.2s;
    transition: opacity 0.2s, background 0.3s;
}

#model-slider-fit:active {
    background: #264c39;
}

.disabled-button {
    color: #66b48e !important;
}

</style>
<style type="text/css">
/******************* Legend styling *******************/

#legend-div {
    display: flex;
    flex-direction: row;
    background-color: none;
    border-radius: 15px;
    box-shadow: 3px 3px 3px 1px rgba(0, 0, 0, 0.2);
    overflow: hidden;
}

/* Flexbox arrangement fails with 'position: absolute' */
#legend-div div {
    position: static;
}

.legend-box-container {
    display: flex;
    align-items: center;
    margin-left: 15px;
}

.legend-box-container p {
    display: flex;
    font-size: 14px;
    margin-left: 4px;
    white-space: nowrap;
}

.legend-box {
    display: flex;
    width: 12px;
    height: 12px;
    border-radius: 2px;
}

.legend-title-container {
    height: 100%;
    width: 40px;
    display: inline-block;
    background-color: #42926b;
    overflow: visible;
}

.legend-title {
    text-align: center;
    font-weight: bold;
    vertical-align: middle;
    width: 90px;
    height: 40px;
    font-size: 14px;
    color: white;
    position: relative;
    transform-origin: 0 0;
    transform: rotate(-90deg) translate(-77px, 3px);
}

.sys-var-container::-webkit-scrollbar, .linear-solvers-container::-webkit-scrollbar, .n2-symbols-container::-webkit-scrollbar {
    display: none;
}

/* Systems and Varaibles Container */

.sys-var-container {
    height: 90px;
    border-radius: 15px;
    border: 1px solid #98daba;
    display: flex;
    flex-direction: row;
    background-color: white;
    z-index: 1;
    overflow-y: scroll;
}

#sys-var-legend {
    height: 90px;
    display: flex;
    flex-wrap: wrap;
    flex-direction: column;
    margin-right: 45px;
    overflow-x: hidden;
}

/* N2 Symbols Group */

.n2-symbols-container {
    height: 90px;
    min-height: 90px;
    border-radius: 15px;
    border: 1px solid #66b48e;
    display: flex;
    align-items: center;
    padding-right: 45px;
    background-color: white;
    z-index: 2;
    overflow: hidden;
    margin-left: -20px;
}

#symbols-legend {
    display: flex;
    width: auto;
    flex-direction: column;
    padding-left: 8px;
}

.symbol {
    display: flex;
    align-items: center;
    margin: 2px 0;
}

.symbol p {
    font-size: 14px;
    margin: 0;
    margin-left: 8px;
    white-space: nowrap;
}

.symbol-outer {
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 18px;
    height: 18px;
}

.symbol-inner {
    position: absolute;
    margin: 0 auto;
}

.scalar {
    border: 2px solid #cecece;
}

.scalar .symbol-inner {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background-color: #9fc4c6;
}

.vector {
    border: 2px solid #cecece;
}

.vector .symbol-inner {
    width: 12px;
    height: 12px;
    background-color: #9fc4c6;
}

.collapsed {
    border: 2px solid #9fc4c6;
}

.collapsed .symbol-inner {
    width: 12px;
    height: 12px;
    background-color: #9fc4c6;
}

/* Linear Solvers Group */

.linear-solvers-container {
    height: 90px;
    border-radius: 15px;
    border: 1px solid #42926b;
    display: flex;
    flex-direction: row;
    margin-left: -20px;
    margin-right: 0;
    background-color: white;
    z-index: 3;
    overflow: hidden;
}

#solvers-legend {
    height: 90px;
    display: flex;
    flex-wrap: wrap;
    flex-direction: column;
    margin-right: 20px;
    overflow-x: hidden;
}

.draggable {
    position: absolute;
    width: 100px;
    height: 20px;
    left: 50%;
    background-color: #42926b;
    border-top-left-radius: 5px;
    border-top-right-radius: 5px;
    display: flex;
    justify-content: center;
    align-items: center;
    transform: translate(-50%, -20px)
}

.draggable>.icon-key {
    color: white;
}

.draggable-legend-dots p {
    color: white;
    margin-left: 5px;
    margin-right: 5px;
}


</style>
<style type="text/css">
[hidden] {
    display: none;
}

.visually-hidden {
    position: absolute;
    clip: rect(0, 0, 0, 0);
}

div.awesomplete {
    display: inline-block;
    position: relative;
}

div.awesomplete>input {}

div.awesomplete>ul {
    position: absolute;
    z-index: 10;
    min-width: 100%;
    box-sizing: border-box;
    list-style: none;
    padding: 5px;
    margin: 0 0 0 8px;
    background: lightgray;
    opacity: .85;
    border: 1px solid rgba(0, 0, 0, .3);
    box-shadow: .05em .2em .6em rgba(0, 0, 0, .2);
    text-shadow: none;
    font-size: 10pt;
    border-bottom-left-radius: 5px;
    border-bottom-right-radius: 5px;
}

div.awesomplete>ul[hidden],
div.awesomplete>ul:empty {
    display: none;
}

@supports (transform: scale(0)) {
    div.awesomplete>ul {
        transition: .3s cubic-bezier(.4, .2, .5, 1.4);
        transform-origin: 1.43em -.43em;
    }

    div.awesomplete>ul[hidden],
    div.awesomplete>ul:empty {
        opacity: 0;
        transform: scale(0);
        display: block;
        transition-timing-function: ease;
    }
}

/* Pointer
	div.awesomplete > ul:before {
		content: "";
		position: absolute;
		top: -.43em;
		left: 1em;
		width: 0; height: 0;
		padding: .4em;
		background: white;
		border: inherit;
		border-right: 0;
		border-bottom: 0;
		-webkit-transform: rotate(45deg);
		transform: rotate(45deg);
	}*/

div.awesomplete>ul>li {
    position: relative;
    padding: .2em .5em;
    cursor: pointer;
}

div.awesomplete>ul>li:hover {
    background: hsl(200, 40%, 80%);
    color: black;
}

div.awesomplete>ul>li[aria-selected="true"] {
    background: hsl(205, 40%, 40%);
    color: white;
}

div.awesomplete mark {
    /* background: hsl(65, 100%, 50%); */
    background: cyan;
}

div.awesomplete li:hover mark {
    /* background: hsl(68, 100%, 41%); */
    background: cyan;
}

div.awesomplete li[aria-selected="true"] mark {
    background: hsl(86, 100%, 21%);
    color: inherit;
}
</style>

<script type="text/javascript">
// https://d3js.org v7.3.0 Copyright 2010-2021 Mike Bostock
!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((t="undefined"!=typeof globalThis?globalThis:t||self).d3=t.d3||{})}(this,(function(t){"use strict";function n(t,n){return null==t||null==n?NaN:t<n?-1:t>n?1:t>=n?0:NaN}function e(t){let e=t,r=t,i=t;function o(t,n,e=0,o=t.length){if(e<o){if(0!==r(n,n))return o;do{const r=e+o>>>1;i(t[r],n)<0?e=r+1:o=r}while(e<o)}return e}return 2!==t.length&&(e=(n,e)=>t(n)-e,r=n,i=(e,r)=>n(t(e),r)),{left:o,center:function(t,n,r=0,i=t.length){const a=o(t,n,r,i-1);return a>r&&e(t[a-1],n)>-e(t[a],n)?a-1:a},right:function(t,n,e=0,o=t.length){if(e<o){if(0!==r(n,n))return o;do{const r=e+o>>>1;i(t[r],n)<=0?e=r+1:o=r}while(e<o)}return e}}}function r(t){return null===t?NaN:+t}const i=e(n),o=i.right,a=i.left,u=e(r).center;var c=o;function f(t,n){let e=0;if(void 0===n)for(let n of t)null!=n&&(n=+n)>=n&&++e;else{let r=-1;for(let i of t)null!=(i=n(i,++r,t))&&(i=+i)>=i&&++e}return e}function s(t){return 0|t.length}function l(t){return!(t>0)}function h(t){return"object"!=typeof t||"length"in t?t:Array.from(t)}function d(t,n){let e,r=0,i=0,o=0;if(void 0===n)for(let n of t)null!=n&&(n=+n)>=n&&(e=n-i,i+=e/++r,o+=e*(n-i));else{let a=-1;for(let u of t)null!=(u=n(u,++a,t))&&(u=+u)>=u&&(e=u-i,i+=e/++r,o+=e*(u-i))}if(r>1)return o/(r-1)}function p(t,n){const e=d(t,n);return e?Math.sqrt(e):e}function g(t,n){let e,r;if(void 0===n)for(const n of t)null!=n&&(void 0===e?n>=n&&(e=r=n):(e>n&&(e=n),r<n&&(r=n)));else{let i=-1;for(let o of t)null!=(o=n(o,++i,t))&&(void 0===e?o>=o&&(e=r=o):(e>o&&(e=o),r<o&&(r=o)))}return[e,r]}class y{constructor(){this._partials=new Float64Array(32),this._n=0}add(t){const n=this._partials;let e=0;for(let r=0;r<this._n&&r<32;r++){const i=n[r],o=t+i,a=Math.abs(t)<Math.abs(i)?t-(o-i):i-(o-t);a&&(n[e++]=a),t=o}return n[e]=t,this._n=e+1,this}valueOf(){const t=this._partials;let n,e,r,i=this._n,o=0;if(i>0){for(o=t[--i];i>0&&(n=o,e=t[--i],o=n+e,r=e-(o-n),!r););i>0&&(r<0&&t[i-1]<0||r>0&&t[i-1]>0)&&(e=2*r,n=o+e,e==n-o&&(o=n))}return o}}class InternMap extends Map{constructor(t,n=m){if(super(),Object.defineProperties(this,{_intern:{value:new Map},_key:{value:n}}),null!=t)for(const[n,e]of t)this.set(n,e)}get(t){return super.get(v(this,t))}has(t){return super.has(v(this,t))}set(t,n){return super.set(_(this,t),n)}delete(t){return super.delete(b(this,t))}}class InternSet extends Set{constructor(t,n=m){if(super(),Object.defineProperties(this,{_intern:{value:new Map},_key:{value:n}}),null!=t)for(const n of t)this.add(n)}has(t){return super.has(v(this,t))}add(t){return super.add(_(this,t))}delete(t){return super.delete(b(this,t))}}function v({_intern:t,_key:n},e){const r=n(e);return t.has(r)?t.get(r):e}function _({_intern:t,_key:n},e){const r=n(e);return t.has(r)?t.get(r):(t.set(r,e),e)}function b({_intern:t,_key:n},e){const r=n(e);return t.has(r)&&(e=t.get(r),t.delete(r)),e}function m(t){return null!==t&&"object"==typeof t?t.valueOf():t}function x(t){return t}function w(t,...n){return k(t,x,x,n)}function M(t,...n){return k(t,Array.from,x,n)}function A(t,n){for(let e=1,r=n.length;e<r;++e)t=t.flatMap((t=>t.pop().map((([n,e])=>[...t,n,e]))));return t}function T(t,n,...e){return k(t,x,n,e)}function S(t,n,...e){return k(t,Array.from,n,e)}function E(t){if(1!==t.length)throw new Error("duplicate key");return t[0]}function k(t,n,e,r){return function t(i,o){if(o>=r.length)return e(i);const a=new InternMap,u=r[o++];let c=-1;for(const t of i){const n=u(t,++c,i),e=a.get(n);e?e.push(t):a.set(n,[t])}for(const[n,e]of a)a.set(n,t(e,o));return n(a)}(t,0)}function N(t,n){return Array.from(n,(n=>t[n]))}function C(t,...n){if("function"!=typeof t[Symbol.iterator])throw new TypeError("values is not iterable");t=Array.from(t);let[e]=n;if(e&&2!==e.length||n.length>1){const r=Uint32Array.from(t,((t,n)=>n));return n.length>1?(n=n.map((n=>t.map(n))),r.sort(((t,e)=>{for(const r of n){const n=z(r[t],r[e]);if(n)return n}}))):(e=t.map(e),r.sort(((t,n)=>z(e[t],e[n])))),N(t,r)}return t.sort(P(e))}function P(t=n){if(t===n)return z;if("function"!=typeof t)throw new TypeError("compare is not a function");return(n,e)=>{const r=t(n,e);return r||0===r?r:(0===t(e,e))-(0===t(n,n))}}function z(t,n){return(null==t||!(t>=t))-(null==n||!(n>=n))||(t<n?-1:t>n?1:0)}var D=Array.prototype.slice;function R(t){return()=>t}var F=Math.sqrt(50),q=Math.sqrt(10),O=Math.sqrt(2);function U(t,n,e){var r,i,o,a,u=-1;if(e=+e,(t=+t)===(n=+n)&&e>0)return[t];if((r=n<t)&&(i=t,t=n,n=i),0===(a=I(t,n,e))||!isFinite(a))return[];if(a>0){let e=Math.round(t/a),r=Math.round(n/a);for(e*a<t&&++e,r*a>n&&--r,o=new Array(i=r-e+1);++u<i;)o[u]=(e+u)*a}else{a=-a;let e=Math.round(t*a),r=Math.round(n*a);for(e/a<t&&++e,r/a>n&&--r,o=new Array(i=r-e+1);++u<i;)o[u]=(e+u)/a}return r&&o.reverse(),o}function I(t,n,e){var r=(n-t)/Math.max(0,e),i=Math.floor(Math.log(r)/Math.LN10),o=r/Math.pow(10,i);return i>=0?(o>=F?10:o>=q?5:o>=O?2:1)*Math.pow(10,i):-Math.pow(10,-i)/(o>=F?10:o>=q?5:o>=O?2:1)}function B(t,n,e){var r=Math.abs(n-t)/Math.max(0,e),i=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),o=r/i;return o>=F?i*=10:o>=q?i*=5:o>=O&&(i*=2),n<t?-i:i}function Y(t,n,e){let r;for(;;){const i=I(t,n,e);if(i===r||0===i||!isFinite(i))return[t,n];i>0?(t=Math.floor(t/i)*i,n=Math.ceil(n/i)*i):i<0&&(t=Math.ceil(t*i)/i,n=Math.floor(n*i)/i),r=i}}function L(t){return Math.ceil(Math.log(f(t))/Math.LN2)+1}function j(){var t=x,n=g,e=L;function r(r){Array.isArray(r)||(r=Array.from(r));var i,o,a=r.length,u=new Array(a);for(i=0;i<a;++i)u[i]=t(r[i],i,r);var f=n(u),s=f[0],l=f[1],h=e(u,s,l);if(!Array.isArray(h)){const t=l,e=+h;if(n===g&&([s,l]=Y(s,l,e)),(h=U(s,l,e))[h.length-1]>=l)if(t>=l&&n===g){const t=I(s,l,e);isFinite(t)&&(t>0?l=(Math.floor(l/t)+1)*t:t<0&&(l=(Math.ceil(l*-t)+1)/-t))}else h.pop()}for(var d=h.length;h[0]<=s;)h.shift(),--d;for(;h[d-1]>l;)h.pop(),--d;var p,y=new Array(d+1);for(i=0;i<=d;++i)(p=y[i]=[]).x0=i>0?h[i-1]:s,p.x1=i<d?h[i]:l;for(i=0;i<a;++i)null!=(o=u[i])&&s<=o&&o<=l&&y[c(h,o,0,d)].push(r[i]);return y}return r.value=function(n){return arguments.length?(t="function"==typeof n?n:R(n),r):t},r.domain=function(t){return arguments.length?(n="function"==typeof t?t:R([t[0],t[1]]),r):n},r.thresholds=function(t){return arguments.length?(e="function"==typeof t?t:Array.isArray(t)?R(D.call(t)):R(t),r):e},r}function H(t,n){let e;if(void 0===n)for(const n of t)null!=n&&(e<n||void 0===e&&n>=n)&&(e=n);else{let r=-1;for(let i of t)null!=(i=n(i,++r,t))&&(e<i||void 0===e&&i>=i)&&(e=i)}return e}function X(t,n){let e;if(void 0===n)for(const n of t)null!=n&&(e>n||void 0===e&&n>=n)&&(e=n);else{let r=-1;for(let i of t)null!=(i=n(i,++r,t))&&(e>i||void 0===e&&i>=i)&&(e=i)}return e}function G(t,n,e=0,r=t.length-1,i){for(i=void 0===i?z:P(i);r>e;){if(r-e>600){const o=r-e+1,a=n-e+1,u=Math.log(o),c=.5*Math.exp(2*u/3),f=.5*Math.sqrt(u*c*(o-c)/o)*(a-o/2<0?-1:1);G(t,n,Math.max(e,Math.floor(n-a*c/o+f)),Math.min(r,Math.floor(n+(o-a)*c/o+f)),i)}const o=t[n];let a=e,u=r;for(V(t,e,n),i(t[r],o)>0&&V(t,e,r);a<u;){for(V(t,a,u),++a,--u;i(t[a],o)<0;)++a;for(;i(t[u],o)>0;)--u}0===i(t[e],o)?V(t,e,u):(++u,V(t,u,r)),u<=n&&(e=u+1),n<=u&&(r=u-1)}return t}function V(t,n,e){const r=t[n];t[n]=t[e],t[e]=r}function $(t,n,e){if(t=Float64Array.from(function*(t,n){if(void 0===n)for(let n of t)null!=n&&(n=+n)>=n&&(yield n);else{let e=-1;for(let r of t)null!=(r=n(r,++e,t))&&(r=+r)>=r&&(yield r)}}(t,e)),r=t.length){if((n=+n)<=0||r<2)return X(t);if(n>=1)return H(t);var r,i=(r-1)*n,o=Math.floor(i),a=H(G(t,o).subarray(0,o+1));return a+(X(t.subarray(o+1))-a)*(i-o)}}function W(t,n,e=r){if(i=t.length){if((n=+n)<=0||i<2)return+e(t[0],0,t);if(n>=1)return+e(t[i-1],i-1,t);var i,o=(i-1)*n,a=Math.floor(o),u=+e(t[a],a,t);return u+(+e(t[a+1],a+1,t)-u)*(o-a)}}function Z(t,n){let e,r=-1,i=-1;if(void 0===n)for(const n of t)++i,null!=n&&(e<n||void 0===e&&n>=n)&&(e=n,r=i);else for(let o of t)null!=(o=n(o,++i,t))&&(e<o||void 0===e&&o>=o)&&(e=o,r=i);return r}function K(t){return Array.from(function*(t){for(const n of t)yield*n}(t))}function Q(t,n){let e,r=-1,i=-1;if(void 0===n)for(const n of t)++i,null!=n&&(e>n||void 0===e&&n>=n)&&(e=n,r=i);else for(let o of t)null!=(o=n(o,++i,t))&&(e>o||void 0===e&&o>=o)&&(e=o,r=i);return r}function J(t,n){return[t,n]}function tt(t,n,e){t=+t,n=+n,e=(i=arguments.length)<2?(n=t,t=0,1):i<3?1:+e;for(var r=-1,i=0|Math.max(0,Math.ceil((n-t)/e)),o=new Array(i);++r<i;)o[r]=t+r*e;return o}function nt(t,e=n){if(1===e.length)return Q(t,e);let r,i=-1,o=-1;for(const n of t)++o,(i<0?0===e(n,n):e(n,r)<0)&&(r=n,i=o);return i}var et=rt(Math.random);function rt(t){return function(n,e=0,r=n.length){let i=r-(e=+e);for(;i;){const r=t()*i--|0,o=n[i+e];n[i+e]=n[r+e],n[r+e]=o}return n}}function it(t){if(!(i=t.length))return[];for(var n=-1,e=X(t,ot),r=new Array(e);++n<e;)for(var i,o=-1,a=r[n]=new Array(i);++o<i;)a[o]=t[o][n];return r}function ot(t){return t.length}function at(t){return t instanceof InternSet?t:new InternSet(t)}function ut(t,n){const e=t[Symbol.iterator](),r=new Set;for(const t of n){const n=ct(t);if(r.has(n))continue;let i,o;for(;({value:i,done:o}=e.next());){if(o)return!1;const t=ct(i);if(r.add(t),Object.is(n,t))break}}return!0}function ct(t){return null!==t&&"object"==typeof t?t.valueOf():t}function ft(t){return t}var st=1e-6;function lt(t){return"translate("+t+",0)"}function ht(t){return"translate(0,"+t+")"}function dt(t){return n=>+t(n)}function pt(t,n){return n=Math.max(0,t.bandwidth()-2*n)/2,t.round()&&(n=Math.round(n)),e=>+t(e)+n}function gt(){return!this.__axis}function yt(t,n){var e=[],r=null,i=null,o=6,a=6,u=3,c="undefined"!=typeof window&&window.devicePixelRatio>1?0:.5,f=1===t||4===t?-1:1,s=4===t||2===t?"x":"y",l=1===t||3===t?lt:ht;function h(h){var d=null==r?n.ticks?n.ticks.apply(n,e):n.domain():r,p=null==i?n.tickFormat?n.tickFormat.apply(n,e):ft:i,g=Math.max(o,0)+u,y=n.range(),v=+y[0]+c,_=+y[y.length-1]+c,b=(n.bandwidth?pt:dt)(n.copy(),c),m=h.selection?h.selection():h,x=m.selectAll(".domain").data([null]),w=m.selectAll(".tick").data(d,n).order(),M=w.exit(),A=w.enter().append("g").attr("class","tick"),T=w.select("line"),S=w.select("text");x=x.merge(x.enter().insert("path",".tick").attr("class","domain").attr("stroke","currentColor")),w=w.merge(A),T=T.merge(A.append("line").attr("stroke","currentColor").attr(s+"2",f*o)),S=S.merge(A.append("text").attr("fill","currentColor").attr(s,f*g).attr("dy",1===t?"0em":3===t?"0.71em":"0.32em")),h!==m&&(x=x.transition(h),w=w.transition(h),T=T.transition(h),S=S.transition(h),M=M.transition(h).attr("opacity",st).attr("transform",(function(t){return isFinite(t=b(t))?l(t+c):this.getAttribute("transform")})),A.attr("opacity",st).attr("transform",(function(t){var n=this.parentNode.__axis;return l((n&&isFinite(n=n(t))?n:b(t))+c)}))),M.remove(),x.attr("d",4===t||2===t?a?"M"+f*a+","+v+"H"+c+"V"+_+"H"+f*a:"M"+c+","+v+"V"+_:a?"M"+v+","+f*a+"V"+c+"H"+_+"V"+f*a:"M"+v+","+c+"H"+_),w.attr("opacity",1).attr("transform",(function(t){return l(b(t)+c)})),T.attr(s+"2",f*o),S.attr(s,f*g).text(p),m.filter(gt).attr("fill","none").attr("font-size",10).attr("font-family","sans-serif").attr("text-anchor",2===t?"start":4===t?"end":"middle"),m.each((function(){this.__axis=b}))}return h.scale=function(t){return arguments.length?(n=t,h):n},h.ticks=function(){return e=Array.from(arguments),h},h.tickArguments=function(t){return arguments.length?(e=null==t?[]:Array.from(t),h):e.slice()},h.tickValues=function(t){return arguments.length?(r=null==t?null:Array.from(t),h):r&&r.slice()},h.tickFormat=function(t){return arguments.length?(i=t,h):i},h.tickSize=function(t){return arguments.length?(o=a=+t,h):o},h.tickSizeInner=function(t){return arguments.length?(o=+t,h):o},h.tickSizeOuter=function(t){return arguments.length?(a=+t,h):a},h.tickPadding=function(t){return arguments.length?(u=+t,h):u},h.offset=function(t){return arguments.length?(c=+t,h):c},h}var vt={value:()=>{}};function _t(){for(var t,n=0,e=arguments.length,r={};n<e;++n){if(!(t=arguments[n]+"")||t in r||/[\s.]/.test(t))throw new Error("illegal type: "+t);r[t]=[]}return new bt(r)}function bt(t){this._=t}function mt(t,n){return t.trim().split(/^|\s+/).map((function(t){var e="",r=t.indexOf(".");if(r>=0&&(e=t.slice(r+1),t=t.slice(0,r)),t&&!n.hasOwnProperty(t))throw new Error("unknown type: "+t);return{type:t,name:e}}))}function xt(t,n){for(var e,r=0,i=t.length;r<i;++r)if((e=t[r]).name===n)return e.value}function wt(t,n,e){for(var r=0,i=t.length;r<i;++r)if(t[r].name===n){t[r]=vt,t=t.slice(0,r).concat(t.slice(r+1));break}return null!=e&&t.push({name:n,value:e}),t}bt.prototype=_t.prototype={constructor:bt,on:function(t,n){var e,r=this._,i=mt(t+"",r),o=-1,a=i.length;if(!(arguments.length<2)){if(null!=n&&"function"!=typeof n)throw new Error("invalid callback: "+n);for(;++o<a;)if(e=(t=i[o]).type)r[e]=wt(r[e],t.name,n);else if(null==n)for(e in r)r[e]=wt(r[e],t.name,null);return this}for(;++o<a;)if((e=(t=i[o]).type)&&(e=xt(r[e],t.name)))return e},copy:function(){var t={},n=this._;for(var e in n)t[e]=n[e].slice();return new bt(t)},call:function(t,n){if((e=arguments.length-2)>0)for(var e,r,i=new Array(e),o=0;o<e;++o)i[o]=arguments[o+2];if(!this._.hasOwnProperty(t))throw new Error("unknown type: "+t);for(o=0,e=(r=this._[t]).length;o<e;++o)r[o].value.apply(n,i)},apply:function(t,n,e){if(!this._.hasOwnProperty(t))throw new Error("unknown type: "+t);for(var r=this._[t],i=0,o=r.length;i<o;++i)r[i].value.apply(n,e)}};var Mt="http://www.w3.org/1999/xhtml",At={svg:"http://www.w3.org/2000/svg",xhtml:Mt,xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};function Tt(t){var n=t+="",e=n.indexOf(":");return e>=0&&"xmlns"!==(n=t.slice(0,e))&&(t=t.slice(e+1)),At.hasOwnProperty(n)?{space:At[n],local:t}:t}function St(t){return function(){var n=this.ownerDocument,e=this.namespaceURI;return e===Mt&&n.documentElement.namespaceURI===Mt?n.createElement(t):n.createElementNS(e,t)}}function Et(t){return function(){return this.ownerDocument.createElementNS(t.space,t.local)}}function kt(t){var n=Tt(t);return(n.local?Et:St)(n)}function Nt(){}function Ct(t){return null==t?Nt:function(){return this.querySelector(t)}}function Pt(t){return null==t?[]:Array.isArray(t)?t:Array.from(t)}function zt(){return[]}function Dt(t){return null==t?zt:function(){return this.querySelectorAll(t)}}function Rt(t){return function(){return this.matches(t)}}function Ft(t){return function(n){return n.matches(t)}}var qt=Array.prototype.find;function Ot(){return this.firstElementChild}var Ut=Array.prototype.filter;function It(){return Array.from(this.children)}function Bt(t){return new Array(t.length)}function Yt(t,n){this.ownerDocument=t.ownerDocument,this.namespaceURI=t.namespaceURI,this._next=null,this._parent=t,this.__data__=n}function Lt(t){return function(){return t}}function jt(t,n,e,r,i,o){for(var a,u=0,c=n.length,f=o.length;u<f;++u)(a=n[u])?(a.__data__=o[u],r[u]=a):e[u]=new Yt(t,o[u]);for(;u<c;++u)(a=n[u])&&(i[u]=a)}function Ht(t,n,e,r,i,o,a){var u,c,f,s=new Map,l=n.length,h=o.length,d=new Array(l);for(u=0;u<l;++u)(c=n[u])&&(d[u]=f=a.call(c,c.__data__,u,n)+"",s.has(f)?i[u]=c:s.set(f,c));for(u=0;u<h;++u)f=a.call(t,o[u],u,o)+"",(c=s.get(f))?(r[u]=c,c.__data__=o[u],s.delete(f)):e[u]=new Yt(t,o[u]);for(u=0;u<l;++u)(c=n[u])&&s.get(d[u])===c&&(i[u]=c)}function Xt(t){return t.__data__}function Gt(t){return"object"==typeof t&&"length"in t?t:Array.from(t)}function Vt(t,n){return t<n?-1:t>n?1:t>=n?0:NaN}function $t(t){return function(){this.removeAttribute(t)}}function Wt(t){return function(){this.removeAttributeNS(t.space,t.local)}}function Zt(t,n){return function(){this.setAttribute(t,n)}}function Kt(t,n){return function(){this.setAttributeNS(t.space,t.local,n)}}function Qt(t,n){return function(){var e=n.apply(this,arguments);null==e?this.removeAttribute(t):this.setAttribute(t,e)}}function Jt(t,n){return function(){var e=n.apply(this,arguments);null==e?this.removeAttributeNS(t.space,t.local):this.setAttributeNS(t.space,t.local,e)}}function tn(t){return t.ownerDocument&&t.ownerDocument.defaultView||t.document&&t||t.defaultView}function nn(t){return function(){this.style.removeProperty(t)}}function en(t,n,e){return function(){this.style.setProperty(t,n,e)}}function rn(t,n,e){return function(){var r=n.apply(this,arguments);null==r?this.style.removeProperty(t):this.style.setProperty(t,r,e)}}function on(t,n){return t.style.getPropertyValue(n)||tn(t).getComputedStyle(t,null).getPropertyValue(n)}function an(t){return function(){delete this[t]}}function un(t,n){return function(){this[t]=n}}function cn(t,n){return function(){var e=n.apply(this,arguments);null==e?delete this[t]:this[t]=e}}function fn(t){return t.trim().split(/^|\s+/)}function sn(t){return t.classList||new ln(t)}function ln(t){this._node=t,this._names=fn(t.getAttribute("class")||"")}function hn(t,n){for(var e=sn(t),r=-1,i=n.length;++r<i;)e.add(n[r])}function dn(t,n){for(var e=sn(t),r=-1,i=n.length;++r<i;)e.remove(n[r])}function pn(t){return function(){hn(this,t)}}function gn(t){return function(){dn(this,t)}}function yn(t,n){return function(){(n.apply(this,arguments)?hn:dn)(this,t)}}function vn(){this.textContent=""}function _n(t){return function(){this.textContent=t}}function bn(t){return function(){var n=t.apply(this,arguments);this.textContent=null==n?"":n}}function mn(){this.innerHTML=""}function xn(t){return function(){this.innerHTML=t}}function wn(t){return function(){var n=t.apply(this,arguments);this.innerHTML=null==n?"":n}}function Mn(){this.nextSibling&&this.parentNode.appendChild(this)}function An(){this.previousSibling&&this.parentNode.insertBefore(this,this.parentNode.firstChild)}function Tn(){return null}function Sn(){var t=this.parentNode;t&&t.removeChild(this)}function En(){var t=this.cloneNode(!1),n=this.parentNode;return n?n.insertBefore(t,this.nextSibling):t}function kn(){var t=this.cloneNode(!0),n=this.parentNode;return n?n.insertBefore(t,this.nextSibling):t}function Nn(t){return t.trim().split(/^|\s+/).map((function(t){var n="",e=t.indexOf(".");return e>=0&&(n=t.slice(e+1),t=t.slice(0,e)),{type:t,name:n}}))}function Cn(t){return function(){var n=this.__on;if(n){for(var e,r=0,i=-1,o=n.length;r<o;++r)e=n[r],t.type&&e.type!==t.type||e.name!==t.name?n[++i]=e:this.removeEventListener(e.type,e.listener,e.options);++i?n.length=i:delete this.__on}}}function Pn(t,n,e){return function(){var r,i=this.__on,o=function(t){return function(n){t.call(this,n,this.__data__)}}(n);if(i)for(var a=0,u=i.length;a<u;++a)if((r=i[a]).type===t.type&&r.name===t.name)return this.removeEventListener(r.type,r.listener,r.options),this.addEventListener(r.type,r.listener=o,r.options=e),void(r.value=n);this.addEventListener(t.type,o,e),r={type:t.type,name:t.name,value:n,listener:o,options:e},i?i.push(r):this.__on=[r]}}function zn(t,n,e){var r=tn(t),i=r.CustomEvent;"function"==typeof i?i=new i(n,e):(i=r.document.createEvent("Event"),e?(i.initEvent(n,e.bubbles,e.cancelable),i.detail=e.detail):i.initEvent(n,!1,!1)),t.dispatchEvent(i)}function Dn(t,n){return function(){return zn(this,t,n)}}function Rn(t,n){return function(){return zn(this,t,n.apply(this,arguments))}}Yt.prototype={constructor:Yt,appendChild:function(t){return this._parent.insertBefore(t,this._next)},insertBefore:function(t,n){return this._parent.insertBefore(t,n)},querySelector:function(t){return this._parent.querySelector(t)},querySelectorAll:function(t){return this._parent.querySelectorAll(t)}},ln.prototype={add:function(t){this._names.indexOf(t)<0&&(this._names.push(t),this._node.setAttribute("class",this._names.join(" ")))},remove:function(t){var n=this._names.indexOf(t);n>=0&&(this._names.splice(n,1),this._node.setAttribute("class",this._names.join(" ")))},contains:function(t){return this._names.indexOf(t)>=0}};var Fn=[null];function qn(t,n){this._groups=t,this._parents=n}function On(){return new qn([[document.documentElement]],Fn)}function Un(t){return"string"==typeof t?new qn([[document.querySelector(t)]],[document.documentElement]):new qn([[t]],Fn)}qn.prototype=On.prototype={constructor:qn,select:function(t){"function"!=typeof t&&(t=Ct(t));for(var n=this._groups,e=n.length,r=new Array(e),i=0;i<e;++i)for(var o,a,u=n[i],c=u.length,f=r[i]=new Array(c),s=0;s<c;++s)(o=u[s])&&(a=t.call(o,o.__data__,s,u))&&("__data__"in o&&(a.__data__=o.__data__),f[s]=a);return new qn(r,this._parents)},selectAll:function(t){t="function"==typeof t?function(t){return function(){return Pt(t.apply(this,arguments))}}(t):Dt(t);for(var n=this._groups,e=n.length,r=[],i=[],o=0;o<e;++o)for(var a,u=n[o],c=u.length,f=0;f<c;++f)(a=u[f])&&(r.push(t.call(a,a.__data__,f,u)),i.push(a));return new qn(r,i)},selectChild:function(t){return this.select(null==t?Ot:function(t){return function(){return qt.call(this.children,t)}}("function"==typeof t?t:Ft(t)))},selectChildren:function(t){return this.selectAll(null==t?It:function(t){return function(){return Ut.call(this.children,t)}}("function"==typeof t?t:Ft(t)))},filter:function(t){"function"!=typeof t&&(t=Rt(t));for(var n=this._groups,e=n.length,r=new Array(e),i=0;i<e;++i)for(var o,a=n[i],u=a.length,c=r[i]=[],f=0;f<u;++f)(o=a[f])&&t.call(o,o.__data__,f,a)&&c.push(o);return new qn(r,this._parents)},data:function(t,n){if(!arguments.length)return Array.from(this,Xt);var e=n?Ht:jt,r=this._parents,i=this._groups;"function"!=typeof t&&(t=Lt(t));for(var o=i.length,a=new Array(o),u=new Array(o),c=new Array(o),f=0;f<o;++f){var s=r[f],l=i[f],h=l.length,d=Gt(t.call(s,s&&s.__data__,f,r)),p=d.length,g=u[f]=new Array(p),y=a[f]=new Array(p),v=c[f]=new Array(h);e(s,l,g,y,v,d,n);for(var _,b,m=0,x=0;m<p;++m)if(_=g[m]){for(m>=x&&(x=m+1);!(b=y[x])&&++x<p;);_._next=b||null}}return(a=new qn(a,r))._enter=u,a._exit=c,a},enter:function(){return new qn(this._enter||this._groups.map(Bt),this._parents)},exit:function(){return new qn(this._exit||this._groups.map(Bt),this._parents)},join:function(t,n,e){var r=this.enter(),i=this,o=this.exit();return"function"==typeof t?(r=t(r))&&(r=r.selection()):r=r.append(t+""),null!=n&&(i=n(i))&&(i=i.selection()),null==e?o.remove():e(o),r&&i?r.merge(i).order():i},merge:function(t){for(var n=t.selection?t.selection():t,e=this._groups,r=n._groups,i=e.length,o=r.length,a=Math.min(i,o),u=new Array(i),c=0;c<a;++c)for(var f,s=e[c],l=r[c],h=s.length,d=u[c]=new Array(h),p=0;p<h;++p)(f=s[p]||l[p])&&(d[p]=f);for(;c<i;++c)u[c]=e[c];return new qn(u,this._parents)},selection:function(){return this},order:function(){for(var t=this._groups,n=-1,e=t.length;++n<e;)for(var r,i=t[n],o=i.length-1,a=i[o];--o>=0;)(r=i[o])&&(a&&4^r.compareDocumentPosition(a)&&a.parentNode.insertBefore(r,a),a=r);return this},sort:function(t){function n(n,e){return n&&e?t(n.__data__,e.__data__):!n-!e}t||(t=Vt);for(var e=this._groups,r=e.length,i=new Array(r),o=0;o<r;++o){for(var a,u=e[o],c=u.length,f=i[o]=new Array(c),s=0;s<c;++s)(a=u[s])&&(f[s]=a);f.sort(n)}return new qn(i,this._parents).order()},call:function(){var t=arguments[0];return arguments[0]=this,t.apply(null,arguments),this},nodes:function(){return Array.from(this)},node:function(){for(var t=this._groups,n=0,e=t.length;n<e;++n)for(var r=t[n],i=0,o=r.length;i<o;++i){var a=r[i];if(a)return a}return null},size:function(){let t=0;for(const n of this)++t;return t},empty:function(){return!this.node()},each:function(t){for(var n=this._groups,e=0,r=n.length;e<r;++e)for(var i,o=n[e],a=0,u=o.length;a<u;++a)(i=o[a])&&t.call(i,i.__data__,a,o);return this},attr:function(t,n){var e=Tt(t);if(arguments.length<2){var r=this.node();return e.local?r.getAttributeNS(e.space,e.local):r.getAttribute(e)}return this.each((null==n?e.local?Wt:$t:"function"==typeof n?e.local?Jt:Qt:e.local?Kt:Zt)(e,n))},style:function(t,n,e){return arguments.length>1?this.each((null==n?nn:"function"==typeof n?rn:en)(t,n,null==e?"":e)):on(this.node(),t)},property:function(t,n){return arguments.length>1?this.each((null==n?an:"function"==typeof n?cn:un)(t,n)):this.node()[t]},classed:function(t,n){var e=fn(t+"");if(arguments.length<2){for(var r=sn(this.node()),i=-1,o=e.length;++i<o;)if(!r.contains(e[i]))return!1;return!0}return this.each(("function"==typeof n?yn:n?pn:gn)(e,n))},text:function(t){return arguments.length?this.each(null==t?vn:("function"==typeof t?bn:_n)(t)):this.node().textContent},html:function(t){return arguments.length?this.each(null==t?mn:("function"==typeof t?wn:xn)(t)):this.node().innerHTML},raise:function(){return this.each(Mn)},lower:function(){return this.each(An)},append:function(t){var n="function"==typeof t?t:kt(t);return this.select((function(){return this.appendChild(n.apply(this,arguments))}))},insert:function(t,n){var e="function"==typeof t?t:kt(t),r=null==n?Tn:"function"==typeof n?n:Ct(n);return this.select((function(){return this.insertBefore(e.apply(this,arguments),r.apply(this,arguments)||null)}))},remove:function(){return this.each(Sn)},clone:function(t){return this.select(t?kn:En)},datum:function(t){return arguments.length?this.property("__data__",t):this.node().__data__},on:function(t,n,e){var r,i,o=Nn(t+""),a=o.length;if(!(arguments.length<2)){for(u=n?Pn:Cn,r=0;r<a;++r)this.each(u(o[r],n,e));return this}var u=this.node().__on;if(u)for(var c,f=0,s=u.length;f<s;++f)for(r=0,c=u[f];r<a;++r)if((i=o[r]).type===c.type&&i.name===c.name)return c.value},dispatch:function(t,n){return this.each(("function"==typeof n?Rn:Dn)(t,n))},[Symbol.iterator]:function*(){for(var t=this._groups,n=0,e=t.length;n<e;++n)for(var r,i=t[n],o=0,a=i.length;o<a;++o)(r=i[o])&&(yield r)}};var In=0;function Bn(){return new Yn}function Yn(){this._="@"+(++In).toString(36)}function Ln(t){let n;for(;n=t.sourceEvent;)t=n;return t}function jn(t,n){if(t=Ln(t),void 0===n&&(n=t.currentTarget),n){var e=n.ownerSVGElement||n;if(e.createSVGPoint){var r=e.createSVGPoint();return r.x=t.clientX,r.y=t.clientY,[(r=r.matrixTransform(n.getScreenCTM().inverse())).x,r.y]}if(n.getBoundingClientRect){var i=n.getBoundingClientRect();return[t.clientX-i.left-n.clientLeft,t.clientY-i.top-n.clientTop]}}return[t.pageX,t.pageY]}Yn.prototype=Bn.prototype={constructor:Yn,get:function(t){for(var n=this._;!(n in t);)if(!(t=t.parentNode))return;return t[n]},set:function(t,n){return t[this._]=n},remove:function(t){return this._ in t&&delete t[this._]},toString:function(){return this._}};const Hn={passive:!1},Xn={capture:!0,passive:!1};function Gn(t){t.stopImmediatePropagation()}function Vn(t){t.preventDefault(),t.stopImmediatePropagation()}function $n(t){var n=t.document.documentElement,e=Un(t).on("dragstart.drag",Vn,Xn);"onselectstart"in n?e.on("selectstart.drag",Vn,Xn):(n.__noselect=n.style.MozUserSelect,n.style.MozUserSelect="none")}function Wn(t,n){var e=t.document.documentElement,r=Un(t).on("dragstart.drag",null);n&&(r.on("click.drag",Vn,Xn),setTimeout((function(){r.on("click.drag",null)}),0)),"onselectstart"in e?r.on("selectstart.drag",null):(e.style.MozUserSelect=e.__noselect,delete e.__noselect)}var Zn=t=>()=>t;function Kn(t,{sourceEvent:n,subject:e,target:r,identifier:i,active:o,x:a,y:u,dx:c,dy:f,dispatch:s}){Object.defineProperties(this,{type:{value:t,enumerable:!0,configurable:!0},sourceEvent:{value:n,enumerable:!0,configurable:!0},subject:{value:e,enumerable:!0,configurable:!0},target:{value:r,enumerable:!0,configurable:!0},identifier:{value:i,enumerable:!0,configurable:!0},active:{value:o,enumerable:!0,configurable:!0},x:{value:a,enumerable:!0,configurable:!0},y:{value:u,enumerable:!0,configurable:!0},dx:{value:c,enumerable:!0,configurable:!0},dy:{value:f,enumerable:!0,configurable:!0},_:{value:s}})}function Qn(t){return!t.ctrlKey&&!t.button}function Jn(){return this.parentNode}function te(t,n){return null==n?{x:t.x,y:t.y}:n}function ne(){return navigator.maxTouchPoints||"ontouchstart"in this}function ee(t,n,e){t.prototype=n.prototype=e,e.constructor=t}function re(t,n){var e=Object.create(t.prototype);for(var r in n)e[r]=n[r];return e}function ie(){}Kn.prototype.on=function(){var t=this._.on.apply(this._,arguments);return t===this._?this:t};var oe=.7,ae=1/oe,ue="\\s*([+-]?\\d+)\\s*",ce="\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",fe="\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",se=/^#([0-9a-f]{3,8})$/,le=new RegExp("^rgb\\("+[ue,ue,ue]+"\\)$"),he=new RegExp("^rgb\\("+[fe,fe,fe]+"\\)$"),de=new RegExp("^rgba\\("+[ue,ue,ue,ce]+"\\)$"),pe=new RegExp("^rgba\\("+[fe,fe,fe,ce]+"\\)$"),ge=new RegExp("^hsl\\("+[ce,fe,fe]+"\\)$"),ye=new RegExp("^hsla\\("+[ce,fe,fe,ce]+"\\)$"),ve={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function _e(){return this.rgb().formatHex()}function be(){return this.rgb().formatRgb()}function me(t){var n,e;return t=(t+"").trim().toLowerCase(),(n=se.exec(t))?(e=n[1].length,n=parseInt(n[1],16),6===e?xe(n):3===e?new Te(n>>8&15|n>>4&240,n>>4&15|240&n,(15&n)<<4|15&n,1):8===e?we(n>>24&255,n>>16&255,n>>8&255,(255&n)/255):4===e?we(n>>12&15|n>>8&240,n>>8&15|n>>4&240,n>>4&15|240&n,((15&n)<<4|15&n)/255):null):(n=le.exec(t))?new Te(n[1],n[2],n[3],1):(n=he.exec(t))?new Te(255*n[1]/100,255*n[2]/100,255*n[3]/100,1):(n=de.exec(t))?we(n[1],n[2],n[3],n[4]):(n=pe.exec(t))?we(255*n[1]/100,255*n[2]/100,255*n[3]/100,n[4]):(n=ge.exec(t))?Ne(n[1],n[2]/100,n[3]/100,1):(n=ye.exec(t))?Ne(n[1],n[2]/100,n[3]/100,n[4]):ve.hasOwnProperty(t)?xe(ve[t]):"transparent"===t?new Te(NaN,NaN,NaN,0):null}function xe(t){return new Te(t>>16&255,t>>8&255,255&t,1)}function we(t,n,e,r){return r<=0&&(t=n=e=NaN),new Te(t,n,e,r)}function Me(t){return t instanceof ie||(t=me(t)),t?new Te((t=t.rgb()).r,t.g,t.b,t.opacity):new Te}function Ae(t,n,e,r){return 1===arguments.length?Me(t):new Te(t,n,e,null==r?1:r)}function Te(t,n,e,r){this.r=+t,this.g=+n,this.b=+e,this.opacity=+r}function Se(){return"#"+ke(this.r)+ke(this.g)+ke(this.b)}function Ee(){var t=this.opacity;return(1===(t=isNaN(t)?1:Math.max(0,Math.min(1,t)))?"rgb(":"rgba(")+Math.max(0,Math.min(255,Math.round(this.r)||0))+", "+Math.max(0,Math.min(255,Math.round(this.g)||0))+", "+Math.max(0,Math.min(255,Math.round(this.b)||0))+(1===t?")":", "+t+")")}function ke(t){return((t=Math.max(0,Math.min(255,Math.round(t)||0)))<16?"0":"")+t.toString(16)}function Ne(t,n,e,r){return r<=0?t=n=e=NaN:e<=0||e>=1?t=n=NaN:n<=0&&(t=NaN),new ze(t,n,e,r)}function Ce(t){if(t instanceof ze)return new ze(t.h,t.s,t.l,t.opacity);if(t instanceof ie||(t=me(t)),!t)return new ze;if(t instanceof ze)return t;var n=(t=t.rgb()).r/255,e=t.g/255,r=t.b/255,i=Math.min(n,e,r),o=Math.max(n,e,r),a=NaN,u=o-i,c=(o+i)/2;return u?(a=n===o?(e-r)/u+6*(e<r):e===o?(r-n)/u+2:(n-e)/u+4,u/=c<.5?o+i:2-o-i,a*=60):u=c>0&&c<1?0:a,new ze(a,u,c,t.opacity)}function Pe(t,n,e,r){return 1===arguments.length?Ce(t):new ze(t,n,e,null==r?1:r)}function ze(t,n,e,r){this.h=+t,this.s=+n,this.l=+e,this.opacity=+r}function De(t,n,e){return 255*(t<60?n+(e-n)*t/60:t<180?e:t<240?n+(e-n)*(240-t)/60:n)}ee(ie,me,{copy:function(t){return Object.assign(new this.constructor,this,t)},displayable:function(){return this.rgb().displayable()},hex:_e,formatHex:_e,formatHsl:function(){return Ce(this).formatHsl()},formatRgb:be,toString:be}),ee(Te,Ae,re(ie,{brighter:function(t){return t=null==t?ae:Math.pow(ae,t),new Te(this.r*t,this.g*t,this.b*t,this.opacity)},darker:function(t){return t=null==t?oe:Math.pow(oe,t),new Te(this.r*t,this.g*t,this.b*t,this.opacity)},rgb:function(){return this},displayable:function(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:Se,formatHex:Se,formatRgb:Ee,toString:Ee})),ee(ze,Pe,re(ie,{brighter:function(t){return t=null==t?ae:Math.pow(ae,t),new ze(this.h,this.s,this.l*t,this.opacity)},darker:function(t){return t=null==t?oe:Math.pow(oe,t),new ze(this.h,this.s,this.l*t,this.opacity)},rgb:function(){var t=this.h%360+360*(this.h<0),n=isNaN(t)||isNaN(this.s)?0:this.s,e=this.l,r=e+(e<.5?e:1-e)*n,i=2*e-r;return new Te(De(t>=240?t-240:t+120,i,r),De(t,i,r),De(t<120?t+240:t-120,i,r),this.opacity)},displayable:function(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl:function(){var t=this.opacity;return(1===(t=isNaN(t)?1:Math.max(0,Math.min(1,t)))?"hsl(":"hsla(")+(this.h||0)+", "+100*(this.s||0)+"%, "+100*(this.l||0)+"%"+(1===t?")":", "+t+")")}}));const Re=Math.PI/180,Fe=180/Math.PI,qe=.96422,Oe=.82521,Ue=4/29,Ie=6/29,Be=3*Ie*Ie;function Ye(t){if(t instanceof je)return new je(t.l,t.a,t.b,t.opacity);if(t instanceof Ze)return Ke(t);t instanceof Te||(t=Me(t));var n,e,r=Ve(t.r),i=Ve(t.g),o=Ve(t.b),a=He((.2225045*r+.7168786*i+.0606169*o)/1);return r===i&&i===o?n=e=a:(n=He((.4360747*r+.3850649*i+.1430804*o)/qe),e=He((.0139322*r+.0971045*i+.7141733*o)/Oe)),new je(116*a-16,500*(n-a),200*(a-e),t.opacity)}function Le(t,n,e,r){return 1===arguments.length?Ye(t):new je(t,n,e,null==r?1:r)}function je(t,n,e,r){this.l=+t,this.a=+n,this.b=+e,this.opacity=+r}function He(t){return t>.008856451679035631?Math.pow(t,1/3):t/Be+Ue}function Xe(t){return t>Ie?t*t*t:Be*(t-Ue)}function Ge(t){return 255*(t<=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055)}function Ve(t){return(t/=255)<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)}function $e(t){if(t instanceof Ze)return new Ze(t.h,t.c,t.l,t.opacity);if(t instanceof je||(t=Ye(t)),0===t.a&&0===t.b)return new Ze(NaN,0<t.l&&t.l<100?0:NaN,t.l,t.opacity);var n=Math.atan2(t.b,t.a)*Fe;return new Ze(n<0?n+360:n,Math.sqrt(t.a*t.a+t.b*t.b),t.l,t.opacity)}function We(t,n,e,r){return 1===arguments.length?$e(t):new Ze(t,n,e,null==r?1:r)}function Ze(t,n,e,r){this.h=+t,this.c=+n,this.l=+e,this.opacity=+r}function Ke(t){if(isNaN(t.h))return new je(t.l,0,0,t.opacity);var n=t.h*Re;return new je(t.l,Math.cos(n)*t.c,Math.sin(n)*t.c,t.opacity)}ee(je,Le,re(ie,{brighter:function(t){return new je(this.l+18*(null==t?1:t),this.a,this.b,this.opacity)},darker:function(t){return new je(this.l-18*(null==t?1:t),this.a,this.b,this.opacity)},rgb:function(){var t=(this.l+16)/116,n=isNaN(this.a)?t:t+this.a/500,e=isNaN(this.b)?t:t-this.b/200;return new Te(Ge(3.1338561*(n=qe*Xe(n))-1.6168667*(t=1*Xe(t))-.4906146*(e=Oe*Xe(e))),Ge(-.9787684*n+1.9161415*t+.033454*e),Ge(.0719453*n-.2289914*t+1.4052427*e),this.opacity)}})),ee(Ze,We,re(ie,{brighter:function(t){return new Ze(this.h,this.c,this.l+18*(null==t?1:t),this.opacity)},darker:function(t){return new Ze(this.h,this.c,this.l-18*(null==t?1:t),this.opacity)},rgb:function(){return Ke(this).rgb()}}));var Qe=-.14861,Je=1.78277,tr=-.29227,nr=-.90649,er=1.97294,rr=er*nr,ir=er*Je,or=Je*tr-nr*Qe;function ar(t){if(t instanceof cr)return new cr(t.h,t.s,t.l,t.opacity);t instanceof Te||(t=Me(t));var n=t.r/255,e=t.g/255,r=t.b/255,i=(or*r+rr*n-ir*e)/(or+rr-ir),o=r-i,a=(er*(e-i)-tr*o)/nr,u=Math.sqrt(a*a+o*o)/(er*i*(1-i)),c=u?Math.atan2(a,o)*Fe-120:NaN;return new cr(c<0?c+360:c,u,i,t.opacity)}function ur(t,n,e,r){return 1===arguments.length?ar(t):new cr(t,n,e,null==r?1:r)}function cr(t,n,e,r){this.h=+t,this.s=+n,this.l=+e,this.opacity=+r}function fr(t,n,e,r,i){var o=t*t,a=o*t;return((1-3*t+3*o-a)*n+(4-6*o+3*a)*e+(1+3*t+3*o-3*a)*r+a*i)/6}function sr(t){var n=t.length-1;return function(e){var r=e<=0?e=0:e>=1?(e=1,n-1):Math.floor(e*n),i=t[r],o=t[r+1],a=r>0?t[r-1]:2*i-o,u=r<n-1?t[r+2]:2*o-i;return fr((e-r/n)*n,a,i,o,u)}}function lr(t){var n=t.length;return function(e){var r=Math.floor(((e%=1)<0?++e:e)*n),i=t[(r+n-1)%n],o=t[r%n],a=t[(r+1)%n],u=t[(r+2)%n];return fr((e-r/n)*n,i,o,a,u)}}ee(cr,ur,re(ie,{brighter:function(t){return t=null==t?ae:Math.pow(ae,t),new cr(this.h,this.s,this.l*t,this.opacity)},darker:function(t){return t=null==t?oe:Math.pow(oe,t),new cr(this.h,this.s,this.l*t,this.opacity)},rgb:function(){var t=isNaN(this.h)?0:(this.h+120)*Re,n=+this.l,e=isNaN(this.s)?0:this.s*n*(1-n),r=Math.cos(t),i=Math.sin(t);return new Te(255*(n+e*(Qe*r+Je*i)),255*(n+e*(tr*r+nr*i)),255*(n+e*(er*r)),this.opacity)}}));var hr=t=>()=>t;function dr(t,n){return function(e){return t+e*n}}function pr(t,n){var e=n-t;return e?dr(t,e>180||e<-180?e-360*Math.round(e/360):e):hr(isNaN(t)?n:t)}function gr(t){return 1==(t=+t)?yr:function(n,e){return e-n?function(t,n,e){return t=Math.pow(t,e),n=Math.pow(n,e)-t,e=1/e,function(r){return Math.pow(t+r*n,e)}}(n,e,t):hr(isNaN(n)?e:n)}}function yr(t,n){var e=n-t;return e?dr(t,e):hr(isNaN(t)?n:t)}var vr=function t(n){var e=gr(n);function r(t,n){var r=e((t=Ae(t)).r,(n=Ae(n)).r),i=e(t.g,n.g),o=e(t.b,n.b),a=yr(t.opacity,n.opacity);return function(n){return t.r=r(n),t.g=i(n),t.b=o(n),t.opacity=a(n),t+""}}return r.gamma=t,r}(1);function _r(t){return function(n){var e,r,i=n.length,o=new Array(i),a=new Array(i),u=new Array(i);for(e=0;e<i;++e)r=Ae(n[e]),o[e]=r.r||0,a[e]=r.g||0,u[e]=r.b||0;return o=t(o),a=t(a),u=t(u),r.opacity=1,function(t){return r.r=o(t),r.g=a(t),r.b=u(t),r+""}}}var br=_r(sr),mr=_r(lr);function xr(t,n){n||(n=[]);var e,r=t?Math.min(n.length,t.length):0,i=n.slice();return function(o){for(e=0;e<r;++e)i[e]=t[e]*(1-o)+n[e]*o;return i}}function wr(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)}function Mr(t,n){var e,r=n?n.length:0,i=t?Math.min(r,t.length):0,o=new Array(i),a=new Array(r);for(e=0;e<i;++e)o[e]=Cr(t[e],n[e]);for(;e<r;++e)a[e]=n[e];return function(t){for(e=0;e<i;++e)a[e]=o[e](t);return a}}function Ar(t,n){var e=new Date;return t=+t,n=+n,function(r){return e.setTime(t*(1-r)+n*r),e}}function Tr(t,n){return t=+t,n=+n,function(e){return t*(1-e)+n*e}}function Sr(t,n){var e,r={},i={};for(e in null!==t&&"object"==typeof t||(t={}),null!==n&&"object"==typeof n||(n={}),n)e in t?r[e]=Cr(t[e],n[e]):i[e]=n[e];return function(t){for(e in r)i[e]=r[e](t);return i}}var Er=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,kr=new RegExp(Er.source,"g");function Nr(t,n){var e,r,i,o=Er.lastIndex=kr.lastIndex=0,a=-1,u=[],c=[];for(t+="",n+="";(e=Er.exec(t))&&(r=kr.exec(n));)(i=r.index)>o&&(i=n.slice(o,i),u[a]?u[a]+=i:u[++a]=i),(e=e[0])===(r=r[0])?u[a]?u[a]+=r:u[++a]=r:(u[++a]=null,c.push({i:a,x:Tr(e,r)})),o=kr.lastIndex;return o<n.length&&(i=n.slice(o),u[a]?u[a]+=i:u[++a]=i),u.length<2?c[0]?function(t){return function(n){return t(n)+""}}(c[0].x):function(t){return function(){return t}}(n):(n=c.length,function(t){for(var e,r=0;r<n;++r)u[(e=c[r]).i]=e.x(t);return u.join("")})}function Cr(t,n){var e,r=typeof n;return null==n||"boolean"===r?hr(n):("number"===r?Tr:"string"===r?(e=me(n))?(n=e,vr):Nr:n instanceof me?vr:n instanceof Date?Ar:wr(n)?xr:Array.isArray(n)?Mr:"function"!=typeof n.valueOf&&"function"!=typeof n.toString||isNaN(n)?Sr:Tr)(t,n)}function Pr(t,n){return t=+t,n=+n,function(e){return Math.round(t*(1-e)+n*e)}}var zr,Dr=180/Math.PI,Rr={translateX:0,translateY:0,rotate:0,skewX:0,scaleX:1,scaleY:1};function Fr(t,n,e,r,i,o){var a,u,c;return(a=Math.sqrt(t*t+n*n))&&(t/=a,n/=a),(c=t*e+n*r)&&(e-=t*c,r-=n*c),(u=Math.sqrt(e*e+r*r))&&(e/=u,r/=u,c/=u),t*r<n*e&&(t=-t,n=-n,c=-c,a=-a),{translateX:i,translateY:o,rotate:Math.atan2(n,t)*Dr,skewX:Math.atan(c)*Dr,scaleX:a,scaleY:u}}function qr(t,n,e,r){function i(t){return t.length?t.pop()+" ":""}return function(o,a){var u=[],c=[];return o=t(o),a=t(a),function(t,r,i,o,a,u){if(t!==i||r!==o){var c=a.push("translate(",null,n,null,e);u.push({i:c-4,x:Tr(t,i)},{i:c-2,x:Tr(r,o)})}else(i||o)&&a.push("translate("+i+n+o+e)}(o.translateX,o.translateY,a.translateX,a.translateY,u,c),function(t,n,e,o){t!==n?(t-n>180?n+=360:n-t>180&&(t+=360),o.push({i:e.push(i(e)+"rotate(",null,r)-2,x:Tr(t,n)})):n&&e.push(i(e)+"rotate("+n+r)}(o.rotate,a.rotate,u,c),function(t,n,e,o){t!==n?o.push({i:e.push(i(e)+"skewX(",null,r)-2,x:Tr(t,n)}):n&&e.push(i(e)+"skewX("+n+r)}(o.skewX,a.skewX,u,c),function(t,n,e,r,o,a){if(t!==e||n!==r){var u=o.push(i(o)+"scale(",null,",",null,")");a.push({i:u-4,x:Tr(t,e)},{i:u-2,x:Tr(n,r)})}else 1===e&&1===r||o.push(i(o)+"scale("+e+","+r+")")}(o.scaleX,o.scaleY,a.scaleX,a.scaleY,u,c),o=a=null,function(t){for(var n,e=-1,r=c.length;++e<r;)u[(n=c[e]).i]=n.x(t);return u.join("")}}}var Or=qr((function(t){const n=new("function"==typeof DOMMatrix?DOMMatrix:WebKitCSSMatrix)(t+"");return n.isIdentity?Rr:Fr(n.a,n.b,n.c,n.d,n.e,n.f)}),"px, ","px)","deg)"),Ur=qr((function(t){return null==t?Rr:(zr||(zr=document.createElementNS("http://www.w3.org/2000/svg","g")),zr.setAttribute("transform",t),(t=zr.transform.baseVal.consolidate())?Fr((t=t.matrix).a,t.b,t.c,t.d,t.e,t.f):Rr)}),", ",")",")");function Ir(t){return((t=Math.exp(t))+1/t)/2}var Br=function t(n,e,r){function i(t,i){var o,a,u=t[0],c=t[1],f=t[2],s=i[0],l=i[1],h=i[2],d=s-u,p=l-c,g=d*d+p*p;if(g<1e-12)a=Math.log(h/f)/n,o=function(t){return[u+t*d,c+t*p,f*Math.exp(n*t*a)]};else{var y=Math.sqrt(g),v=(h*h-f*f+r*g)/(2*f*e*y),_=(h*h-f*f-r*g)/(2*h*e*y),b=Math.log(Math.sqrt(v*v+1)-v),m=Math.log(Math.sqrt(_*_+1)-_);a=(m-b)/n,o=function(t){var r=t*a,i=Ir(b),o=f/(e*y)*(i*function(t){return((t=Math.exp(2*t))-1)/(t+1)}(n*r+b)-function(t){return((t=Math.exp(t))-1/t)/2}(b));return[u+o*d,c+o*p,f*i/Ir(n*r+b)]}}return o.duration=1e3*a*n/Math.SQRT2,o}return i.rho=function(n){var e=Math.max(.001,+n),r=e*e;return t(e,r,r*r)},i}(Math.SQRT2,2,4);function Yr(t){return function(n,e){var r=t((n=Pe(n)).h,(e=Pe(e)).h),i=yr(n.s,e.s),o=yr(n.l,e.l),a=yr(n.opacity,e.opacity);return function(t){return n.h=r(t),n.s=i(t),n.l=o(t),n.opacity=a(t),n+""}}}var Lr=Yr(pr),jr=Yr(yr);function Hr(t){return function(n,e){var r=t((n=We(n)).h,(e=We(e)).h),i=yr(n.c,e.c),o=yr(n.l,e.l),a=yr(n.opacity,e.opacity);return function(t){return n.h=r(t),n.c=i(t),n.l=o(t),n.opacity=a(t),n+""}}}var Xr=Hr(pr),Gr=Hr(yr);function Vr(t){return function n(e){function r(n,r){var i=t((n=ur(n)).h,(r=ur(r)).h),o=yr(n.s,r.s),a=yr(n.l,r.l),u=yr(n.opacity,r.opacity);return function(t){return n.h=i(t),n.s=o(t),n.l=a(Math.pow(t,e)),n.opacity=u(t),n+""}}return e=+e,r.gamma=n,r}(1)}var $r=Vr(pr),Wr=Vr(yr);function Zr(t,n){void 0===n&&(n=t,t=Cr);for(var e=0,r=n.length-1,i=n[0],o=new Array(r<0?0:r);e<r;)o[e]=t(i,i=n[++e]);return function(t){var n=Math.max(0,Math.min(r-1,Math.floor(t*=r)));return o[n](t-n)}}var Kr,Qr,Jr=0,ti=0,ni=0,ei=0,ri=0,ii=0,oi="object"==typeof performance&&performance.now?performance:Date,ai="object"==typeof window&&window.requestAnimationFrame?window.requestAnimationFrame.bind(window):function(t){setTimeout(t,17)};function ui(){return ri||(ai(ci),ri=oi.now()+ii)}function ci(){ri=0}function fi(){this._call=this._time=this._next=null}function si(t,n,e){var r=new fi;return r.restart(t,n,e),r}function li(){ui(),++Jr;for(var t,n=Kr;n;)(t=ri-n._time)>=0&&n._call.call(void 0,t),n=n._next;--Jr}function hi(){ri=(ei=oi.now())+ii,Jr=ti=0;try{li()}finally{Jr=0,function(){var t,n,e=Kr,r=1/0;for(;e;)e._call?(r>e._time&&(r=e._time),t=e,e=e._next):(n=e._next,e._next=null,e=t?t._next=n:Kr=n);Qr=t,pi(r)}(),ri=0}}function di(){var t=oi.now(),n=t-ei;n>1e3&&(ii-=n,ei=t)}function pi(t){Jr||(ti&&(ti=clearTimeout(ti)),t-ri>24?(t<1/0&&(ti=setTimeout(hi,t-oi.now()-ii)),ni&&(ni=clearInterval(ni))):(ni||(ei=oi.now(),ni=setInterval(di,1e3)),Jr=1,ai(hi)))}function gi(t,n,e){var r=new fi;return n=null==n?0:+n,r.restart((e=>{r.stop(),t(e+n)}),n,e),r}fi.prototype=si.prototype={constructor:fi,restart:function(t,n,e){if("function"!=typeof t)throw new TypeError("callback is not a function");e=(null==e?ui():+e)+(null==n?0:+n),this._next||Qr===this||(Qr?Qr._next=this:Kr=this,Qr=this),this._call=t,this._time=e,pi()},stop:function(){this._call&&(this._call=null,this._time=1/0,pi())}};var yi=_t("start","end","cancel","interrupt"),vi=[];function _i(t,n,e,r,i,o){var a=t.__transition;if(a){if(e in a)return}else t.__transition={};!function(t,n,e){var r,i=t.__transition;function o(t){e.state=1,e.timer.restart(a,e.delay,e.time),e.delay<=t&&a(t-e.delay)}function a(o){var f,s,l,h;if(1!==e.state)return c();for(f in i)if((h=i[f]).name===e.name){if(3===h.state)return gi(a);4===h.state?(h.state=6,h.timer.stop(),h.on.call("interrupt",t,t.__data__,h.index,h.group),delete i[f]):+f<n&&(h.state=6,h.timer.stop(),h.on.call("cancel",t,t.__data__,h.index,h.group),delete i[f])}if(gi((function(){3===e.state&&(e.state=4,e.timer.restart(u,e.delay,e.time),u(o))})),e.state=2,e.on.call("start",t,t.__data__,e.index,e.group),2===e.state){for(e.state=3,r=new Array(l=e.tween.length),f=0,s=-1;f<l;++f)(h=e.tween[f].value.call(t,t.__data__,e.index,e.group))&&(r[++s]=h);r.length=s+1}}function u(n){for(var i=n<e.duration?e.ease.call(null,n/e.duration):(e.timer.restart(c),e.state=5,1),o=-1,a=r.length;++o<a;)r[o].call(t,i);5===e.state&&(e.on.call("end",t,t.__data__,e.index,e.group),c())}function c(){for(var r in e.state=6,e.timer.stop(),delete i[n],i)return;delete t.__transition}i[n]=e,e.timer=si(o,0,e.time)}(t,e,{name:n,index:r,group:i,on:yi,tween:vi,time:o.time,delay:o.delay,duration:o.duration,ease:o.ease,timer:null,state:0})}function bi(t,n){var e=xi(t,n);if(e.state>0)throw new Error("too late; already scheduled");return e}function mi(t,n){var e=xi(t,n);if(e.state>3)throw new Error("too late; already running");return e}function xi(t,n){var e=t.__transition;if(!e||!(e=e[n]))throw new Error("transition not found");return e}function wi(t,n){var e,r,i,o=t.__transition,a=!0;if(o){for(i in n=null==n?null:n+"",o)(e=o[i]).name===n?(r=e.state>2&&e.state<5,e.state=6,e.timer.stop(),e.on.call(r?"interrupt":"cancel",t,t.__data__,e.index,e.group),delete o[i]):a=!1;a&&delete t.__transition}}function Mi(t,n){var e,r;return function(){var i=mi(this,t),o=i.tween;if(o!==e)for(var a=0,u=(r=e=o).length;a<u;++a)if(r[a].name===n){(r=r.slice()).splice(a,1);break}i.tween=r}}function Ai(t,n,e){var r,i;if("function"!=typeof e)throw new Error;return function(){var o=mi(this,t),a=o.tween;if(a!==r){i=(r=a).slice();for(var u={name:n,value:e},c=0,f=i.length;c<f;++c)if(i[c].name===n){i[c]=u;break}c===f&&i.push(u)}o.tween=i}}function Ti(t,n,e){var r=t._id;return t.each((function(){var t=mi(this,r);(t.value||(t.value={}))[n]=e.apply(this,arguments)})),function(t){return xi(t,r).value[n]}}function Si(t,n){var e;return("number"==typeof n?Tr:n instanceof me?vr:(e=me(n))?(n=e,vr):Nr)(t,n)}function Ei(t){return function(){this.removeAttribute(t)}}function ki(t){return function(){this.removeAttributeNS(t.space,t.local)}}function Ni(t,n,e){var r,i,o=e+"";return function(){var a=this.getAttribute(t);return a===o?null:a===r?i:i=n(r=a,e)}}function Ci(t,n,e){var r,i,o=e+"";return function(){var a=this.getAttributeNS(t.space,t.local);return a===o?null:a===r?i:i=n(r=a,e)}}function Pi(t,n,e){var r,i,o;return function(){var a,u,c=e(this);if(null!=c)return(a=this.getAttribute(t))===(u=c+"")?null:a===r&&u===i?o:(i=u,o=n(r=a,c));this.removeAttribute(t)}}function zi(t,n,e){var r,i,o;return function(){var a,u,c=e(this);if(null!=c)return(a=this.getAttributeNS(t.space,t.local))===(u=c+"")?null:a===r&&u===i?o:(i=u,o=n(r=a,c));this.removeAttributeNS(t.space,t.local)}}function Di(t,n){return function(e){this.setAttribute(t,n.call(this,e))}}function Ri(t,n){return function(e){this.setAttributeNS(t.space,t.local,n.call(this,e))}}function Fi(t,n){var e,r;function i(){var i=n.apply(this,arguments);return i!==r&&(e=(r=i)&&Ri(t,i)),e}return i._value=n,i}function qi(t,n){var e,r;function i(){var i=n.apply(this,arguments);return i!==r&&(e=(r=i)&&Di(t,i)),e}return i._value=n,i}function Oi(t,n){return function(){bi(this,t).delay=+n.apply(this,arguments)}}function Ui(t,n){return n=+n,function(){bi(this,t).delay=n}}function Ii(t,n){return function(){mi(this,t).duration=+n.apply(this,arguments)}}function Bi(t,n){return n=+n,function(){mi(this,t).duration=n}}function Yi(t,n){if("function"!=typeof n)throw new Error;return function(){mi(this,t).ease=n}}function Li(t,n,e){var r,i,o=function(t){return(t+"").trim().split(/^|\s+/).every((function(t){var n=t.indexOf(".");return n>=0&&(t=t.slice(0,n)),!t||"start"===t}))}(n)?bi:mi;return function(){var a=o(this,t),u=a.on;u!==r&&(i=(r=u).copy()).on(n,e),a.on=i}}var ji=On.prototype.constructor;function Hi(t){return function(){this.style.removeProperty(t)}}function Xi(t,n,e){return function(r){this.style.setProperty(t,n.call(this,r),e)}}function Gi(t,n,e){var r,i;function o(){var o=n.apply(this,arguments);return o!==i&&(r=(i=o)&&Xi(t,o,e)),r}return o._value=n,o}function Vi(t){return function(n){this.textContent=t.call(this,n)}}function $i(t){var n,e;function r(){var r=t.apply(this,arguments);return r!==e&&(n=(e=r)&&Vi(r)),n}return r._value=t,r}var Wi=0;function Zi(t,n,e,r){this._groups=t,this._parents=n,this._name=e,this._id=r}function Ki(t){return On().transition(t)}function Qi(){return++Wi}var Ji=On.prototype;Zi.prototype=Ki.prototype={constructor:Zi,select:function(t){var n=this._name,e=this._id;"function"!=typeof t&&(t=Ct(t));for(var r=this._groups,i=r.length,o=new Array(i),a=0;a<i;++a)for(var u,c,f=r[a],s=f.length,l=o[a]=new Array(s),h=0;h<s;++h)(u=f[h])&&(c=t.call(u,u.__data__,h,f))&&("__data__"in u&&(c.__data__=u.__data__),l[h]=c,_i(l[h],n,e,h,l,xi(u,e)));return new Zi(o,this._parents,n,e)},selectAll:function(t){var n=this._name,e=this._id;"function"!=typeof t&&(t=Dt(t));for(var r=this._groups,i=r.length,o=[],a=[],u=0;u<i;++u)for(var c,f=r[u],s=f.length,l=0;l<s;++l)if(c=f[l]){for(var h,d=t.call(c,c.__data__,l,f),p=xi(c,e),g=0,y=d.length;g<y;++g)(h=d[g])&&_i(h,n,e,g,d,p);o.push(d),a.push(c)}return new Zi(o,a,n,e)},selectChild:Ji.selectChild,selectChildren:Ji.selectChildren,filter:function(t){"function"!=typeof t&&(t=Rt(t));for(var n=this._groups,e=n.length,r=new Array(e),i=0;i<e;++i)for(var o,a=n[i],u=a.length,c=r[i]=[],f=0;f<u;++f)(o=a[f])&&t.call(o,o.__data__,f,a)&&c.push(o);return new Zi(r,this._parents,this._name,this._id)},merge:function(t){if(t._id!==this._id)throw new Error;for(var n=this._groups,e=t._groups,r=n.length,i=e.length,o=Math.min(r,i),a=new Array(r),u=0;u<o;++u)for(var c,f=n[u],s=e[u],l=f.length,h=a[u]=new Array(l),d=0;d<l;++d)(c=f[d]||s[d])&&(h[d]=c);for(;u<r;++u)a[u]=n[u];return new Zi(a,this._parents,this._name,this._id)},selection:function(){return new ji(this._groups,this._parents)},transition:function(){for(var t=this._name,n=this._id,e=Qi(),r=this._groups,i=r.length,o=0;o<i;++o)for(var a,u=r[o],c=u.length,f=0;f<c;++f)if(a=u[f]){var s=xi(a,n);_i(a,t,e,f,u,{time:s.time+s.delay+s.duration,delay:0,duration:s.duration,ease:s.ease})}return new Zi(r,this._parents,t,e)},call:Ji.call,nodes:Ji.nodes,node:Ji.node,size:Ji.size,empty:Ji.empty,each:Ji.each,on:function(t,n){var e=this._id;return arguments.length<2?xi(this.node(),e).on.on(t):this.each(Li(e,t,n))},attr:function(t,n){var e=Tt(t),r="transform"===e?Ur:Si;return this.attrTween(t,"function"==typeof n?(e.local?zi:Pi)(e,r,Ti(this,"attr."+t,n)):null==n?(e.local?ki:Ei)(e):(e.local?Ci:Ni)(e,r,n))},attrTween:function(t,n){var e="attr."+t;if(arguments.length<2)return(e=this.tween(e))&&e._value;if(null==n)return this.tween(e,null);if("function"!=typeof n)throw new Error;var r=Tt(t);return this.tween(e,(r.local?Fi:qi)(r,n))},style:function(t,n,e){var r="transform"==(t+="")?Or:Si;return null==n?this.styleTween(t,function(t,n){var e,r,i;return function(){var o=on(this,t),a=(this.style.removeProperty(t),on(this,t));return o===a?null:o===e&&a===r?i:i=n(e=o,r=a)}}(t,r)).on("end.style."+t,Hi(t)):"function"==typeof n?this.styleTween(t,function(t,n,e){var r,i,o;return function(){var a=on(this,t),u=e(this),c=u+"";return null==u&&(this.style.removeProperty(t),c=u=on(this,t)),a===c?null:a===r&&c===i?o:(i=c,o=n(r=a,u))}}(t,r,Ti(this,"style."+t,n))).each(function(t,n){var e,r,i,o,a="style."+n,u="end."+a;return function(){var c=mi(this,t),f=c.on,s=null==c.value[a]?o||(o=Hi(n)):void 0;f===e&&i===s||(r=(e=f).copy()).on(u,i=s),c.on=r}}(this._id,t)):this.styleTween(t,function(t,n,e){var r,i,o=e+"";return function(){var a=on(this,t);return a===o?null:a===r?i:i=n(r=a,e)}}(t,r,n),e).on("end.style."+t,null)},styleTween:function(t,n,e){var r="style."+(t+="");if(arguments.length<2)return(r=this.tween(r))&&r._value;if(null==n)return this.tween(r,null);if("function"!=typeof n)throw new Error;return this.tween(r,Gi(t,n,null==e?"":e))},text:function(t){return this.tween("text","function"==typeof t?function(t){return function(){var n=t(this);this.textContent=null==n?"":n}}(Ti(this,"text",t)):function(t){return function(){this.textContent=t}}(null==t?"":t+""))},textTween:function(t){var n="text";if(arguments.length<1)return(n=this.tween(n))&&n._value;if(null==t)return this.tween(n,null);if("function"!=typeof t)throw new Error;return this.tween(n,$i(t))},remove:function(){return this.on("end.remove",function(t){return function(){var n=this.parentNode;for(var e in this.__transition)if(+e!==t)return;n&&n.removeChild(this)}}(this._id))},tween:function(t,n){var e=this._id;if(t+="",arguments.length<2){for(var r,i=xi(this.node(),e).tween,o=0,a=i.length;o<a;++o)if((r=i[o]).name===t)return r.value;return null}return this.each((null==n?Mi:Ai)(e,t,n))},delay:function(t){var n=this._id;return arguments.length?this.each(("function"==typeof t?Oi:Ui)(n,t)):xi(this.node(),n).delay},duration:function(t){var n=this._id;return arguments.length?this.each(("function"==typeof t?Ii:Bi)(n,t)):xi(this.node(),n).duration},ease:function(t){var n=this._id;return arguments.length?this.each(Yi(n,t)):xi(this.node(),n).ease},easeVarying:function(t){if("function"!=typeof t)throw new Error;return this.each(function(t,n){return function(){var e=n.apply(this,arguments);if("function"!=typeof e)throw new Error;mi(this,t).ease=e}}(this._id,t))},end:function(){var t,n,e=this,r=e._id,i=e.size();return new Promise((function(o,a){var u={value:a},c={value:function(){0==--i&&o()}};e.each((function(){var e=mi(this,r),i=e.on;i!==t&&((n=(t=i).copy())._.cancel.push(u),n._.interrupt.push(u),n._.end.push(c)),e.on=n})),0===i&&o()}))},[Symbol.iterator]:Ji[Symbol.iterator]};function to(t){return((t*=2)<=1?t*t:--t*(2-t)+1)/2}function no(t){return((t*=2)<=1?t*t*t:(t-=2)*t*t+2)/2}var eo=function t(n){function e(t){return Math.pow(t,n)}return n=+n,e.exponent=t,e}(3),ro=function t(n){function e(t){return 1-Math.pow(1-t,n)}return n=+n,e.exponent=t,e}(3),io=function t(n){function e(t){return((t*=2)<=1?Math.pow(t,n):2-Math.pow(2-t,n))/2}return n=+n,e.exponent=t,e}(3),oo=Math.PI,ao=oo/2;function uo(t){return(1-Math.cos(oo*t))/2}function co(t){return 1.0009775171065494*(Math.pow(2,-10*t)-.0009765625)}function fo(t){return((t*=2)<=1?co(1-t):2-co(t-1))/2}function so(t){return((t*=2)<=1?1-Math.sqrt(1-t*t):Math.sqrt(1-(t-=2)*t)+1)/2}var lo=4/11,ho=7.5625;function po(t){return(t=+t)<lo?ho*t*t:t<.7272727272727273?ho*(t-=.5454545454545454)*t+.75:t<.9090909090909091?ho*(t-=.8181818181818182)*t+.9375:ho*(t-=.9545454545454546)*t+.984375}var go=1.70158,yo=function t(n){function e(t){return(t=+t)*t*(n*(t-1)+t)}return n=+n,e.overshoot=t,e}(go),vo=function t(n){function e(t){return--t*t*((t+1)*n+t)+1}return n=+n,e.overshoot=t,e}(go),_o=function t(n){function e(t){return((t*=2)<1?t*t*((n+1)*t-n):(t-=2)*t*((n+1)*t+n)+2)/2}return n=+n,e.overshoot=t,e}(go),bo=2*Math.PI,mo=function t(n,e){var r=Math.asin(1/(n=Math.max(1,n)))*(e/=bo);function i(t){return n*co(- --t)*Math.sin((r-t)/e)}return i.amplitude=function(n){return t(n,e*bo)},i.period=function(e){return t(n,e)},i}(1,.3),xo=function t(n,e){var r=Math.asin(1/(n=Math.max(1,n)))*(e/=bo);function i(t){return 1-n*co(t=+t)*Math.sin((t+r)/e)}return i.amplitude=function(n){return t(n,e*bo)},i.period=function(e){return t(n,e)},i}(1,.3),wo=function t(n,e){var r=Math.asin(1/(n=Math.max(1,n)))*(e/=bo);function i(t){return((t=2*t-1)<0?n*co(-t)*Math.sin((r-t)/e):2-n*co(t)*Math.sin((r+t)/e))/2}return i.amplitude=function(n){return t(n,e*bo)},i.period=function(e){return t(n,e)},i}(1,.3),Mo={time:null,delay:0,duration:250,ease:no};function Ao(t,n){for(var e;!(e=t.__transition)||!(e=e[n]);)if(!(t=t.parentNode))throw new Error(`transition ${n} not found`);return e}On.prototype.interrupt=function(t){return this.each((function(){wi(this,t)}))},On.prototype.transition=function(t){var n,e;t instanceof Zi?(n=t._id,t=t._name):(n=Qi(),(e=Mo).time=ui(),t=null==t?null:t+"");for(var r=this._groups,i=r.length,o=0;o<i;++o)for(var a,u=r[o],c=u.length,f=0;f<c;++f)(a=u[f])&&_i(a,t,n,f,u,e||Ao(a,n));return new Zi(r,this._parents,t,n)};var To=[null];var So=t=>()=>t;function Eo(t,{sourceEvent:n,target:e,selection:r,mode:i,dispatch:o}){Object.defineProperties(this,{type:{value:t,enumerable:!0,configurable:!0},sourceEvent:{value:n,enumerable:!0,configurable:!0},target:{value:e,enumerable:!0,configurable:!0},selection:{value:r,enumerable:!0,configurable:!0},mode:{value:i,enumerable:!0,configurable:!0},_:{value:o}})}function ko(t){t.stopImmediatePropagation()}function No(t){t.preventDefault(),t.stopImmediatePropagation()}var Co={name:"drag"},Po={name:"space"},zo={name:"handle"},Do={name:"center"};const{abs:Ro,max:Fo,min:qo}=Math;function Oo(t){return[+t[0],+t[1]]}function Uo(t){return[Oo(t[0]),Oo(t[1])]}var Io={name:"x",handles:["w","e"].map(Vo),input:function(t,n){return null==t?null:[[+t[0],n[0][1]],[+t[1],n[1][1]]]},output:function(t){return t&&[t[0][0],t[1][0]]}},Bo={name:"y",handles:["n","s"].map(Vo),input:function(t,n){return null==t?null:[[n[0][0],+t[0]],[n[1][0],+t[1]]]},output:function(t){return t&&[t[0][1],t[1][1]]}},Yo={name:"xy",handles:["n","w","e","s","nw","ne","sw","se"].map(Vo),input:function(t){return null==t?null:Uo(t)},output:function(t){return t}},Lo={overlay:"crosshair",selection:"move",n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},jo={e:"w",w:"e",nw:"ne",ne:"nw",se:"sw",sw:"se"},Ho={n:"s",s:"n",nw:"sw",ne:"se",se:"ne",sw:"nw"},Xo={overlay:1,selection:1,n:null,e:1,s:null,w:-1,nw:-1,ne:1,se:1,sw:-1},Go={overlay:1,selection:1,n:-1,e:null,s:1,w:null,nw:-1,ne:-1,se:1,sw:1};function Vo(t){return{type:t}}function $o(t){return!t.ctrlKey&&!t.button}function Wo(){var t=this.ownerSVGElement||this;return t.hasAttribute("viewBox")?[[(t=t.viewBox.baseVal).x,t.y],[t.x+t.width,t.y+t.height]]:[[0,0],[t.width.baseVal.value,t.height.baseVal.value]]}function Zo(){return navigator.maxTouchPoints||"ontouchstart"in this}function Ko(t){for(;!t.__brush;)if(!(t=t.parentNode))return;return t.__brush}function Qo(t){return t[0][0]===t[1][0]||t[0][1]===t[1][1]}function Jo(t){var n,e=Wo,r=$o,i=Zo,o=!0,a=_t("start","brush","end"),u=6;function c(n){var e=n.property("__brush",g).selectAll(".overlay").data([Vo("overlay")]);e.enter().append("rect").attr("class","overlay").attr("pointer-events","all").attr("cursor",Lo.overlay).merge(e).each((function(){var t=Ko(this).extent;Un(this).attr("x",t[0][0]).attr("y",t[0][1]).attr("width",t[1][0]-t[0][0]).attr("height",t[1][1]-t[0][1])})),n.selectAll(".selection").data([Vo("selection")]).enter().append("rect").attr("class","selection").attr("cursor",Lo.selection).attr("fill","#777").attr("fill-opacity",.3).attr("stroke","#fff").attr("shape-rendering","crispEdges");var r=n.selectAll(".handle").data(t.handles,(function(t){return t.type}));r.exit().remove(),r.enter().append("rect").attr("class",(function(t){return"handle handle--"+t.type})).attr("cursor",(function(t){return Lo[t.type]})),n.each(f).attr("fill","none").attr("pointer-events","all").on("mousedown.brush",h).filter(i).on("touchstart.brush",h).on("touchmove.brush",d).on("touchend.brush touchcancel.brush",p).style("touch-action","none").style("-webkit-tap-highlight-color","rgba(0,0,0,0)")}function f(){var t=Un(this),n=Ko(this).selection;n?(t.selectAll(".selection").style("display",null).attr("x",n[0][0]).attr("y",n[0][1]).attr("width",n[1][0]-n[0][0]).attr("height",n[1][1]-n[0][1]),t.selectAll(".handle").style("display",null).attr("x",(function(t){return"e"===t.type[t.type.length-1]?n[1][0]-u/2:n[0][0]-u/2})).attr("y",(function(t){return"s"===t.type[0]?n[1][1]-u/2:n[0][1]-u/2})).attr("width",(function(t){return"n"===t.type||"s"===t.type?n[1][0]-n[0][0]+u:u})).attr("height",(function(t){return"e"===t.type||"w"===t.type?n[1][1]-n[0][1]+u:u}))):t.selectAll(".selection,.handle").style("display","none").attr("x",null).attr("y",null).attr("width",null).attr("height",null)}function s(t,n,e){var r=t.__brush.emitter;return!r||e&&r.clean?new l(t,n,e):r}function l(t,n,e){this.that=t,this.args=n,this.state=t.__brush,this.active=0,this.clean=e}function h(e){if((!n||e.touches)&&r.apply(this,arguments)){var i,a,u,c,l,h,d,p,g,y,v,_=this,b=e.target.__data__.type,m="selection"===(o&&e.metaKey?b="overlay":b)?Co:o&&e.altKey?Do:zo,x=t===Bo?null:Xo[b],w=t===Io?null:Go[b],M=Ko(_),A=M.extent,T=M.selection,S=A[0][0],E=A[0][1],k=A[1][0],N=A[1][1],C=0,P=0,z=x&&w&&o&&e.shiftKey,D=Array.from(e.touches||[e],(t=>{const n=t.identifier;return(t=jn(t,_)).point0=t.slice(),t.identifier=n,t}));wi(_);var R=s(_,arguments,!0).beforestart();if("overlay"===b){T&&(g=!0);const n=[D[0],D[1]||D[0]];M.selection=T=[[i=t===Bo?S:qo(n[0][0],n[1][0]),u=t===Io?E:qo(n[0][1],n[1][1])],[l=t===Bo?k:Fo(n[0][0],n[1][0]),d=t===Io?N:Fo(n[0][1],n[1][1])]],D.length>1&&I(e)}else i=T[0][0],u=T[0][1],l=T[1][0],d=T[1][1];a=i,c=u,h=l,p=d;var F=Un(_).attr("pointer-events","none"),q=F.selectAll(".overlay").attr("cursor",Lo[b]);if(e.touches)R.moved=U,R.ended=B;else{var O=Un(e.view).on("mousemove.brush",U,!0).on("mouseup.brush",B,!0);o&&O.on("keydown.brush",Y,!0).on("keyup.brush",L,!0),$n(e.view)}f.call(_),R.start(e,m.name)}function U(t){for(const n of t.changedTouches||[t])for(const t of D)t.identifier===n.identifier&&(t.cur=jn(n,_));if(z&&!y&&!v&&1===D.length){const t=D[0];Ro(t.cur[0]-t[0])>Ro(t.cur[1]-t[1])?v=!0:y=!0}for(const t of D)t.cur&&(t[0]=t.cur[0],t[1]=t.cur[1]);g=!0,No(t),I(t)}function I(t){const n=D[0],e=n.point0;var r;switch(C=n[0]-e[0],P=n[1]-e[1],m){case Po:case Co:x&&(C=Fo(S-i,qo(k-l,C)),a=i+C,h=l+C),w&&(P=Fo(E-u,qo(N-d,P)),c=u+P,p=d+P);break;case zo:D[1]?(x&&(a=Fo(S,qo(k,D[0][0])),h=Fo(S,qo(k,D[1][0])),x=1),w&&(c=Fo(E,qo(N,D[0][1])),p=Fo(E,qo(N,D[1][1])),w=1)):(x<0?(C=Fo(S-i,qo(k-i,C)),a=i+C,h=l):x>0&&(C=Fo(S-l,qo(k-l,C)),a=i,h=l+C),w<0?(P=Fo(E-u,qo(N-u,P)),c=u+P,p=d):w>0&&(P=Fo(E-d,qo(N-d,P)),c=u,p=d+P));break;case Do:x&&(a=Fo(S,qo(k,i-C*x)),h=Fo(S,qo(k,l+C*x))),w&&(c=Fo(E,qo(N,u-P*w)),p=Fo(E,qo(N,d+P*w)))}h<a&&(x*=-1,r=i,i=l,l=r,r=a,a=h,h=r,b in jo&&q.attr("cursor",Lo[b=jo[b]])),p<c&&(w*=-1,r=u,u=d,d=r,r=c,c=p,p=r,b in Ho&&q.attr("cursor",Lo[b=Ho[b]])),M.selection&&(T=M.selection),y&&(a=T[0][0],h=T[1][0]),v&&(c=T[0][1],p=T[1][1]),T[0][0]===a&&T[0][1]===c&&T[1][0]===h&&T[1][1]===p||(M.selection=[[a,c],[h,p]],f.call(_),R.brush(t,m.name))}function B(t){if(ko(t),t.touches){if(t.touches.length)return;n&&clearTimeout(n),n=setTimeout((function(){n=null}),500)}else Wn(t.view,g),O.on("keydown.brush keyup.brush mousemove.brush mouseup.brush",null);F.attr("pointer-events","all"),q.attr("cursor",Lo.overlay),M.selection&&(T=M.selection),Qo(T)&&(M.selection=null,f.call(_)),R.end(t,m.name)}function Y(t){switch(t.keyCode){case 16:z=x&&w;break;case 18:m===zo&&(x&&(l=h-C*x,i=a+C*x),w&&(d=p-P*w,u=c+P*w),m=Do,I(t));break;case 32:m!==zo&&m!==Do||(x<0?l=h-C:x>0&&(i=a-C),w<0?d=p-P:w>0&&(u=c-P),m=Po,q.attr("cursor",Lo.selection),I(t));break;default:return}No(t)}function L(t){switch(t.keyCode){case 16:z&&(y=v=z=!1,I(t));break;case 18:m===Do&&(x<0?l=h:x>0&&(i=a),w<0?d=p:w>0&&(u=c),m=zo,I(t));break;case 32:m===Po&&(t.altKey?(x&&(l=h-C*x,i=a+C*x),w&&(d=p-P*w,u=c+P*w),m=Do):(x<0?l=h:x>0&&(i=a),w<0?d=p:w>0&&(u=c),m=zo),q.attr("cursor",Lo[b]),I(t));break;default:return}No(t)}}function d(t){s(this,arguments).moved(t)}function p(t){s(this,arguments).ended(t)}function g(){var n=this.__brush||{selection:null};return n.extent=Uo(e.apply(this,arguments)),n.dim=t,n}return c.move=function(n,e,r){n.tween?n.on("start.brush",(function(t){s(this,arguments).beforestart().start(t)})).on("interrupt.brush end.brush",(function(t){s(this,arguments).end(t)})).tween("brush",(function(){var n=this,r=n.__brush,i=s(n,arguments),o=r.selection,a=t.input("function"==typeof e?e.apply(this,arguments):e,r.extent),u=Cr(o,a);function c(t){r.selection=1===t&&null===a?null:u(t),f.call(n),i.brush()}return null!==o&&null!==a?c:c(1)})):n.each((function(){var n=this,i=arguments,o=n.__brush,a=t.input("function"==typeof e?e.apply(n,i):e,o.extent),u=s(n,i).beforestart();wi(n),o.selection=null===a?null:a,f.call(n),u.start(r).brush(r).end(r)}))},c.clear=function(t,n){c.move(t,null,n)},l.prototype={beforestart:function(){return 1==++this.active&&(this.state.emitter=this,this.starting=!0),this},start:function(t,n){return this.starting?(this.starting=!1,this.emit("start",t,n)):this.emit("brush",t),this},brush:function(t,n){return this.emit("brush",t,n),this},end:function(t,n){return 0==--this.active&&(delete this.state.emitter,this.emit("end",t,n)),this},emit:function(n,e,r){var i=Un(this.that).datum();a.call(n,this.that,new Eo(n,{sourceEvent:e,target:c,selection:t.output(this.state.selection),mode:r,dispatch:a}),i)}},c.extent=function(t){return arguments.length?(e="function"==typeof t?t:So(Uo(t)),c):e},c.filter=function(t){return arguments.length?(r="function"==typeof t?t:So(!!t),c):r},c.touchable=function(t){return arguments.length?(i="function"==typeof t?t:So(!!t),c):i},c.handleSize=function(t){return arguments.length?(u=+t,c):u},c.keyModifiers=function(t){return arguments.length?(o=!!t,c):o},c.on=function(){var t=a.on.apply(a,arguments);return t===a?c:t},c}var ta=Math.abs,na=Math.cos,ea=Math.sin,ra=Math.PI,ia=ra/2,oa=2*ra,aa=Math.max,ua=1e-12;function ca(t,n){return Array.from({length:n-t},((n,e)=>t+e))}function fa(t){return function(n,e){return t(n.source.value+n.target.value,e.source.value+e.target.value)}}function sa(t,n){var e=0,r=null,i=null,o=null;function a(a){var u,c=a.length,f=new Array(c),s=ca(0,c),l=new Array(c*c),h=new Array(c),d=0;a=Float64Array.from({length:c*c},n?(t,n)=>a[n%c][n/c|0]:(t,n)=>a[n/c|0][n%c]);for(let n=0;n<c;++n){let e=0;for(let r=0;r<c;++r)e+=a[n*c+r]+t*a[r*c+n];d+=f[n]=e}u=(d=aa(0,oa-e*c)/d)?e:oa/c;{let n=0;r&&s.sort(((t,n)=>r(f[t],f[n])));for(const e of s){const r=n;if(t){const t=ca(1+~c,c).filter((t=>t<0?a[~t*c+e]:a[e*c+t]));i&&t.sort(((t,n)=>i(t<0?-a[~t*c+e]:a[e*c+t],n<0?-a[~n*c+e]:a[e*c+n])));for(const r of t)if(r<0){(l[~r*c+e]||(l[~r*c+e]={source:null,target:null})).target={index:e,startAngle:n,endAngle:n+=a[~r*c+e]*d,value:a[~r*c+e]}}else{(l[e*c+r]||(l[e*c+r]={source:null,target:null})).source={index:e,startAngle:n,endAngle:n+=a[e*c+r]*d,value:a[e*c+r]}}h[e]={index:e,startAngle:r,endAngle:n,value:f[e]}}else{const t=ca(0,c).filter((t=>a[e*c+t]||a[t*c+e]));i&&t.sort(((t,n)=>i(a[e*c+t],a[e*c+n])));for(const r of t){let t;if(e<r?(t=l[e*c+r]||(l[e*c+r]={source:null,target:null}),t.source={index:e,startAngle:n,endAngle:n+=a[e*c+r]*d,value:a[e*c+r]}):(t=l[r*c+e]||(l[r*c+e]={source:null,target:null}),t.target={index:e,startAngle:n,endAngle:n+=a[e*c+r]*d,value:a[e*c+r]},e===r&&(t.source=t.target)),t.source&&t.target&&t.source.value<t.target.value){const n=t.source;t.source=t.target,t.target=n}}h[e]={index:e,startAngle:r,endAngle:n,value:f[e]}}n+=u}}return(l=Object.values(l)).groups=h,o?l.sort(o):l}return a.padAngle=function(t){return arguments.length?(e=aa(0,t),a):e},a.sortGroups=function(t){return arguments.length?(r=t,a):r},a.sortSubgroups=function(t){return arguments.length?(i=t,a):i},a.sortChords=function(t){return arguments.length?(null==t?o=null:(o=fa(t))._=t,a):o&&o._},a}const la=Math.PI,ha=2*la,da=1e-6,pa=ha-da;function ga(){this._x0=this._y0=this._x1=this._y1=null,this._=""}function ya(){return new ga}ga.prototype=ya.prototype={constructor:ga,moveTo:function(t,n){this._+="M"+(this._x0=this._x1=+t)+","+(this._y0=this._y1=+n)},closePath:function(){null!==this._x1&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")},lineTo:function(t,n){this._+="L"+(this._x1=+t)+","+(this._y1=+n)},quadraticCurveTo:function(t,n,e,r){this._+="Q"+ +t+","+ +n+","+(this._x1=+e)+","+(this._y1=+r)},bezierCurveTo:function(t,n,e,r,i,o){this._+="C"+ +t+","+ +n+","+ +e+","+ +r+","+(this._x1=+i)+","+(this._y1=+o)},arcTo:function(t,n,e,r,i){t=+t,n=+n,e=+e,r=+r,i=+i;var o=this._x1,a=this._y1,u=e-t,c=r-n,f=o-t,s=a-n,l=f*f+s*s;if(i<0)throw new Error("negative radius: "+i);if(null===this._x1)this._+="M"+(this._x1=t)+","+(this._y1=n);else if(l>da)if(Math.abs(s*u-c*f)>da&&i){var h=e-o,d=r-a,p=u*u+c*c,g=h*h+d*d,y=Math.sqrt(p),v=Math.sqrt(l),_=i*Math.tan((la-Math.acos((p+l-g)/(2*y*v)))/2),b=_/v,m=_/y;Math.abs(b-1)>da&&(this._+="L"+(t+b*f)+","+(n+b*s)),this._+="A"+i+","+i+",0,0,"+ +(s*h>f*d)+","+(this._x1=t+m*u)+","+(this._y1=n+m*c)}else this._+="L"+(this._x1=t)+","+(this._y1=n);else;},arc:function(t,n,e,r,i,o){t=+t,n=+n,o=!!o;var a=(e=+e)*Math.cos(r),u=e*Math.sin(r),c=t+a,f=n+u,s=1^o,l=o?r-i:i-r;if(e<0)throw new Error("negative radius: "+e);null===this._x1?this._+="M"+c+","+f:(Math.abs(this._x1-c)>da||Math.abs(this._y1-f)>da)&&(this._+="L"+c+","+f),e&&(l<0&&(l=l%ha+ha),l>pa?this._+="A"+e+","+e+",0,1,"+s+","+(t-a)+","+(n-u)+"A"+e+","+e+",0,1,"+s+","+(this._x1=c)+","+(this._y1=f):l>da&&(this._+="A"+e+","+e+",0,"+ +(l>=la)+","+s+","+(this._x1=t+e*Math.cos(i))+","+(this._y1=n+e*Math.sin(i))))},rect:function(t,n,e,r){this._+="M"+(this._x0=this._x1=+t)+","+(this._y0=this._y1=+n)+"h"+ +e+"v"+ +r+"h"+-e+"Z"},toString:function(){return this._}};var va=Array.prototype.slice;function _a(t){return function(){return t}}function ba(t){return t.source}function ma(t){return t.target}function xa(t){return t.radius}function wa(t){return t.startAngle}function Ma(t){return t.endAngle}function Aa(){return 0}function Ta(){return 10}function Sa(t){var n=ba,e=ma,r=xa,i=xa,o=wa,a=Ma,u=Aa,c=null;function f(){var f,s=n.apply(this,arguments),l=e.apply(this,arguments),h=u.apply(this,arguments)/2,d=va.call(arguments),p=+r.apply(this,(d[0]=s,d)),g=o.apply(this,d)-ia,y=a.apply(this,d)-ia,v=+i.apply(this,(d[0]=l,d)),_=o.apply(this,d)-ia,b=a.apply(this,d)-ia;if(c||(c=f=ya()),h>ua&&(ta(y-g)>2*h+ua?y>g?(g+=h,y-=h):(g-=h,y+=h):g=y=(g+y)/2,ta(b-_)>2*h+ua?b>_?(_+=h,b-=h):(_-=h,b+=h):_=b=(_+b)/2),c.moveTo(p*na(g),p*ea(g)),c.arc(0,0,p,g,y),g!==_||y!==b)if(t){var m=+t.apply(this,arguments),x=v-m,w=(_+b)/2;c.quadraticCurveTo(0,0,x*na(_),x*ea(_)),c.lineTo(v*na(w),v*ea(w)),c.lineTo(x*na(b),x*ea(b))}else c.quadraticCurveTo(0,0,v*na(_),v*ea(_)),c.arc(0,0,v,_,b);if(c.quadraticCurveTo(0,0,p*na(g),p*ea(g)),c.closePath(),f)return c=null,f+""||null}return t&&(f.headRadius=function(n){return arguments.length?(t="function"==typeof n?n:_a(+n),f):t}),f.radius=function(t){return arguments.length?(r=i="function"==typeof t?t:_a(+t),f):r},f.sourceRadius=function(t){return arguments.length?(r="function"==typeof t?t:_a(+t),f):r},f.targetRadius=function(t){return arguments.length?(i="function"==typeof t?t:_a(+t),f):i},f.startAngle=function(t){return arguments.length?(o="function"==typeof t?t:_a(+t),f):o},f.endAngle=function(t){return arguments.length?(a="function"==typeof t?t:_a(+t),f):a},f.padAngle=function(t){return arguments.length?(u="function"==typeof t?t:_a(+t),f):u},f.source=function(t){return arguments.length?(n=t,f):n},f.target=function(t){return arguments.length?(e=t,f):e},f.context=function(t){return arguments.length?(c=null==t?null:t,f):c},f}var Ea=Array.prototype.slice;function ka(t,n){return t-n}var Na=t=>()=>t;function Ca(t,n){for(var e,r=-1,i=n.length;++r<i;)if(e=Pa(t,n[r]))return e;return 0}function Pa(t,n){for(var e=n[0],r=n[1],i=-1,o=0,a=t.length,u=a-1;o<a;u=o++){var c=t[o],f=c[0],s=c[1],l=t[u],h=l[0],d=l[1];if(za(c,l,n))return 0;s>r!=d>r&&e<(h-f)*(r-s)/(d-s)+f&&(i=-i)}return i}function za(t,n,e){var r,i,o,a;return function(t,n,e){return(n[0]-t[0])*(e[1]-t[1])==(e[0]-t[0])*(n[1]-t[1])}(t,n,e)&&(i=t[r=+(t[0]===n[0])],o=e[r],a=n[r],i<=o&&o<=a||a<=o&&o<=i)}function Da(){}var Ra=[[],[[[1,1.5],[.5,1]]],[[[1.5,1],[1,1.5]]],[[[1.5,1],[.5,1]]],[[[1,.5],[1.5,1]]],[[[1,1.5],[.5,1]],[[1,.5],[1.5,1]]],[[[1,.5],[1,1.5]]],[[[1,.5],[.5,1]]],[[[.5,1],[1,.5]]],[[[1,1.5],[1,.5]]],[[[.5,1],[1,.5]],[[1.5,1],[1,1.5]]],[[[1.5,1],[1,.5]]],[[[.5,1],[1.5,1]]],[[[1,1.5],[1.5,1]]],[[[.5,1],[1,1.5]]],[]];function Fa(){var t=1,n=1,e=L,r=u;function i(t){var n=e(t);if(Array.isArray(n))n=n.slice().sort(ka);else{const e=g(t),r=B(e[0],e[1],n);n=U(Math.floor(e[0]/r)*r,Math.floor(e[1]/r-1)*r,n)}return n.map((n=>o(t,n)))}function o(e,i){var o=[],u=[];return function(e,r,i){var o,u,c,f,s,l,h=new Array,d=new Array;o=u=-1,f=e[0]>=r,Ra[f<<1].forEach(p);for(;++o<t-1;)c=f,f=e[o+1]>=r,Ra[c|f<<1].forEach(p);Ra[f<<0].forEach(p);for(;++u<n-1;){for(o=-1,f=e[u*t+t]>=r,s=e[u*t]>=r,Ra[f<<1|s<<2].forEach(p);++o<t-1;)c=f,f=e[u*t+t+o+1]>=r,l=s,s=e[u*t+o+1]>=r,Ra[c|f<<1|s<<2|l<<3].forEach(p);Ra[f|s<<3].forEach(p)}o=-1,s=e[u*t]>=r,Ra[s<<2].forEach(p);for(;++o<t-1;)l=s,s=e[u*t+o+1]>=r,Ra[s<<2|l<<3].forEach(p);function p(t){var n,e,r=[t[0][0]+o,t[0][1]+u],c=[t[1][0]+o,t[1][1]+u],f=a(r),s=a(c);(n=d[f])?(e=h[s])?(delete d[n.end],delete h[e.start],n===e?(n.ring.push(c),i(n.ring)):h[n.start]=d[e.end]={start:n.start,end:e.end,ring:n.ring.concat(e.ring)}):(delete d[n.end],n.ring.push(c),d[n.end=s]=n):(n=h[s])?(e=d[f])?(delete h[n.start],delete d[e.end],n===e?(n.ring.push(c),i(n.ring)):h[e.start]=d[n.end]={start:e.start,end:n.end,ring:e.ring.concat(n.ring)}):(delete h[n.start],n.ring.unshift(r),h[n.start=f]=n):h[f]=d[s]={start:f,end:s,ring:[r,c]}}Ra[s<<3].forEach(p)}(e,i,(function(t){r(t,e,i),function(t){for(var n=0,e=t.length,r=t[e-1][1]*t[0][0]-t[e-1][0]*t[0][1];++n<e;)r+=t[n-1][1]*t[n][0]-t[n-1][0]*t[n][1];return r}(t)>0?o.push([t]):u.push(t)})),u.forEach((function(t){for(var n,e=0,r=o.length;e<r;++e)if(-1!==Ca((n=o[e])[0],t))return void n.push(t)})),{type:"MultiPolygon",value:i,coordinates:o}}function a(n){return 2*n[0]+n[1]*(t+1)*4}function u(e,r,i){e.forEach((function(e){var o,a=e[0],u=e[1],c=0|a,f=0|u,s=r[f*t+c];a>0&&a<t&&c===a&&(o=r[f*t+c-1],e[0]=a+(i-o)/(s-o)-.5),u>0&&u<n&&f===u&&(o=r[(f-1)*t+c],e[1]=u+(i-o)/(s-o)-.5)}))}return i.contour=o,i.size=function(e){if(!arguments.length)return[t,n];var r=Math.floor(e[0]),o=Math.floor(e[1]);if(!(r>=0&&o>=0))throw new Error("invalid size");return t=r,n=o,i},i.thresholds=function(t){return arguments.length?(e="function"==typeof t?t:Array.isArray(t)?Na(Ea.call(t)):Na(t),i):e},i.smooth=function(t){return arguments.length?(r=t?u:Da,i):r===u},i}function qa(t,n,e){for(var r=t.width,i=t.height,o=1+(e<<1),a=0;a<i;++a)for(var u=0,c=0;u<r+e;++u)u<r&&(c+=t.data[u+a*r]),u>=e&&(u>=o&&(c-=t.data[u-o+a*r]),n.data[u-e+a*r]=c/Math.min(u+1,r-1+o-u,o))}function Oa(t,n,e){for(var r=t.width,i=t.height,o=1+(e<<1),a=0;a<r;++a)for(var u=0,c=0;u<i+e;++u)u<i&&(c+=t.data[a+u*r]),u>=e&&(u>=o&&(c-=t.data[a+(u-o)*r]),n.data[a+(u-e)*r]=c/Math.min(u+1,i-1+o-u,o))}function Ua(t){return t[0]}function Ia(t){return t[1]}function Ba(){return 1}const Ya=134217729;function La(t,n,e,r,i){let o,a,u,c,f=n[0],s=r[0],l=0,h=0;s>f==s>-f?(o=f,f=n[++l]):(o=s,s=r[++h]);let d=0;if(l<t&&h<e)for(s>f==s>-f?(a=f+o,u=o-(a-f),f=n[++l]):(a=s+o,u=o-(a-s),s=r[++h]),o=a,0!==u&&(i[d++]=u);l<t&&h<e;)s>f==s>-f?(a=o+f,c=a-o,u=o-(a-c)+(f-c),f=n[++l]):(a=o+s,c=a-o,u=o-(a-c)+(s-c),s=r[++h]),o=a,0!==u&&(i[d++]=u);for(;l<t;)a=o+f,c=a-o,u=o-(a-c)+(f-c),f=n[++l],o=a,0!==u&&(i[d++]=u);for(;h<e;)a=o+s,c=a-o,u=o-(a-c)+(s-c),s=r[++h],o=a,0!==u&&(i[d++]=u);return 0===o&&0!==d||(i[d++]=o),d}function ja(t){return new Float64Array(t)}const Ha=ja(4),Xa=ja(8),Ga=ja(12),Va=ja(16),$a=ja(4);function Wa(t,n,e,r,i,o){const a=(n-o)*(e-i),u=(t-i)*(r-o),c=a-u;if(0===a||0===u||a>0!=u>0)return c;const f=Math.abs(a+u);return Math.abs(c)>=33306690738754716e-32*f?c:-function(t,n,e,r,i,o,a){let u,c,f,s,l,h,d,p,g,y,v,_,b,m,x,w,M,A;const T=t-i,S=e-i,E=n-o,k=r-o;m=T*k,h=Ya*T,d=h-(h-T),p=T-d,h=Ya*k,g=h-(h-k),y=k-g,x=p*y-(m-d*g-p*g-d*y),w=E*S,h=Ya*E,d=h-(h-E),p=E-d,h=Ya*S,g=h-(h-S),y=S-g,M=p*y-(w-d*g-p*g-d*y),v=x-M,l=x-v,Ha[0]=x-(v+l)+(l-M),_=m+v,l=_-m,b=m-(_-l)+(v-l),v=b-w,l=b-v,Ha[1]=b-(v+l)+(l-w),A=_+v,l=A-_,Ha[2]=_-(A-l)+(v-l),Ha[3]=A;let N=function(t,n){let e=n[0];for(let r=1;r<t;r++)e+=n[r];return e}(4,Ha),C=22204460492503146e-32*a;if(N>=C||-N>=C)return N;if(l=t-T,u=t-(T+l)+(l-i),l=e-S,f=e-(S+l)+(l-i),l=n-E,c=n-(E+l)+(l-o),l=r-k,s=r-(k+l)+(l-o),0===u&&0===c&&0===f&&0===s)return N;if(C=11093356479670487e-47*a+33306690738754706e-32*Math.abs(N),N+=T*s+k*u-(E*f+S*c),N>=C||-N>=C)return N;m=u*k,h=Ya*u,d=h-(h-u),p=u-d,h=Ya*k,g=h-(h-k),y=k-g,x=p*y-(m-d*g-p*g-d*y),w=c*S,h=Ya*c,d=h-(h-c),p=c-d,h=Ya*S,g=h-(h-S),y=S-g,M=p*y-(w-d*g-p*g-d*y),v=x-M,l=x-v,$a[0]=x-(v+l)+(l-M),_=m+v,l=_-m,b=m-(_-l)+(v-l),v=b-w,l=b-v,$a[1]=b-(v+l)+(l-w),A=_+v,l=A-_,$a[2]=_-(A-l)+(v-l),$a[3]=A;const P=La(4,Ha,4,$a,Xa);m=T*s,h=Ya*T,d=h-(h-T),p=T-d,h=Ya*s,g=h-(h-s),y=s-g,x=p*y-(m-d*g-p*g-d*y),w=E*f,h=Ya*E,d=h-(h-E),p=E-d,h=Ya*f,g=h-(h-f),y=f-g,M=p*y-(w-d*g-p*g-d*y),v=x-M,l=x-v,$a[0]=x-(v+l)+(l-M),_=m+v,l=_-m,b=m-(_-l)+(v-l),v=b-w,l=b-v,$a[1]=b-(v+l)+(l-w),A=_+v,l=A-_,$a[2]=_-(A-l)+(v-l),$a[3]=A;const z=La(P,Xa,4,$a,Ga);m=u*s,h=Ya*u,d=h-(h-u),p=u-d,h=Ya*s,g=h-(h-s),y=s-g,x=p*y-(m-d*g-p*g-d*y),w=c*f,h=Ya*c,d=h-(h-c),p=c-d,h=Ya*f,g=h-(h-f),y=f-g,M=p*y-(w-d*g-p*g-d*y),v=x-M,l=x-v,$a[0]=x-(v+l)+(l-M),_=m+v,l=_-m,b=m-(_-l)+(v-l),v=b-w,l=b-v,$a[1]=b-(v+l)+(l-w),A=_+v,l=A-_,$a[2]=_-(A-l)+(v-l),$a[3]=A;const D=La(z,Ga,4,$a,Va);return Va[D-1]}(t,n,e,r,i,o,f)}const Za=Math.pow(2,-52),Ka=new Uint32Array(512);class Qa{static from(t,n=iu,e=ou){const r=t.length,i=new Float64Array(2*r);for(let o=0;o<r;o++){const r=t[o];i[2*o]=n(r),i[2*o+1]=e(r)}return new Qa(i)}constructor(t){const n=t.length>>1;if(n>0&&"number"!=typeof t[0])throw new Error("Expected coords to contain numbers.");this.coords=t;const e=Math.max(2*n-5,0);this._triangles=new Uint32Array(3*e),this._halfedges=new Int32Array(3*e),this._hashSize=Math.ceil(Math.sqrt(n)),this._hullPrev=new Uint32Array(n),this._hullNext=new Uint32Array(n),this._hullTri=new Uint32Array(n),this._hullHash=new Int32Array(this._hashSize).fill(-1),this._ids=new Uint32Array(n),this._dists=new Float64Array(n),this.update()}update(){const{coords:t,_hullPrev:n,_hullNext:e,_hullTri:r,_hullHash:i}=this,o=t.length>>1;let a=1/0,u=1/0,c=-1/0,f=-1/0;for(let n=0;n<o;n++){const e=t[2*n],r=t[2*n+1];e<a&&(a=e),r<u&&(u=r),e>c&&(c=e),r>f&&(f=r),this._ids[n]=n}const s=(a+c)/2,l=(u+f)/2;let h,d,p,g=1/0;for(let n=0;n<o;n++){const e=Ja(s,l,t[2*n],t[2*n+1]);e<g&&(h=n,g=e)}const y=t[2*h],v=t[2*h+1];g=1/0;for(let n=0;n<o;n++){if(n===h)continue;const e=Ja(y,v,t[2*n],t[2*n+1]);e<g&&e>0&&(d=n,g=e)}let _=t[2*d],b=t[2*d+1],m=1/0;for(let n=0;n<o;n++){if(n===h||n===d)continue;const e=nu(y,v,_,b,t[2*n],t[2*n+1]);e<m&&(p=n,m=e)}let x=t[2*p],w=t[2*p+1];if(m===1/0){for(let n=0;n<o;n++)this._dists[n]=t[2*n]-t[0]||t[2*n+1]-t[1];eu(this._ids,this._dists,0,o-1);const n=new Uint32Array(o);let e=0;for(let t=0,r=-1/0;t<o;t++){const i=this._ids[t];this._dists[i]>r&&(n[e++]=i,r=this._dists[i])}return this.hull=n.subarray(0,e),this.triangles=new Uint32Array(0),void(this.halfedges=new Uint32Array(0))}if(Wa(y,v,_,b,x,w)<0){const t=d,n=_,e=b;d=p,_=x,b=w,p=t,x=n,w=e}const M=function(t,n,e,r,i,o){const a=e-t,u=r-n,c=i-t,f=o-n,s=a*a+u*u,l=c*c+f*f,h=.5/(a*f-u*c);return{x:t+(f*s-u*l)*h,y:n+(a*l-c*s)*h}}(y,v,_,b,x,w);this._cx=M.x,this._cy=M.y;for(let n=0;n<o;n++)this._dists[n]=Ja(t[2*n],t[2*n+1],M.x,M.y);eu(this._ids,this._dists,0,o-1),this._hullStart=h;let A=3;e[h]=n[p]=d,e[d]=n[h]=p,e[p]=n[d]=h,r[h]=0,r[d]=1,r[p]=2,i.fill(-1),i[this._hashKey(y,v)]=h,i[this._hashKey(_,b)]=d,i[this._hashKey(x,w)]=p,this.trianglesLen=0,this._addTriangle(h,d,p,-1,-1,-1);for(let o,a,u=0;u<this._ids.length;u++){const c=this._ids[u],f=t[2*c],s=t[2*c+1];if(u>0&&Math.abs(f-o)<=Za&&Math.abs(s-a)<=Za)continue;if(o=f,a=s,c===h||c===d||c===p)continue;let l=0;for(let t=0,n=this._hashKey(f,s);t<this._hashSize&&(l=i[(n+t)%this._hashSize],-1===l||l===e[l]);t++);l=n[l];let g,y=l;for(;g=e[y],Wa(f,s,t[2*y],t[2*y+1],t[2*g],t[2*g+1])>=0;)if(y=g,y===l){y=-1;break}if(-1===y)continue;let v=this._addTriangle(y,c,e[y],-1,-1,r[y]);r[c]=this._legalize(v+2),r[y]=v,A++;let _=e[y];for(;g=e[_],Wa(f,s,t[2*_],t[2*_+1],t[2*g],t[2*g+1])<0;)v=this._addTriangle(_,c,g,r[c],-1,r[_]),r[c]=this._legalize(v+2),e[_]=_,A--,_=g;if(y===l)for(;g=n[y],Wa(f,s,t[2*g],t[2*g+1],t[2*y],t[2*y+1])<0;)v=this._addTriangle(g,c,y,-1,r[y],r[g]),this._legalize(v+2),r[g]=v,e[y]=y,A--,y=g;this._hullStart=n[c]=y,e[y]=n[_]=c,e[c]=_,i[this._hashKey(f,s)]=c,i[this._hashKey(t[2*y],t[2*y+1])]=y}this.hull=new Uint32Array(A);for(let t=0,n=this._hullStart;t<A;t++)this.hull[t]=n,n=e[n];this.triangles=this._triangles.subarray(0,this.trianglesLen),this.halfedges=this._halfedges.subarray(0,this.trianglesLen)}_hashKey(t,n){return Math.floor(function(t,n){const e=t/(Math.abs(t)+Math.abs(n));return(n>0?3-e:1+e)/4}(t-this._cx,n-this._cy)*this._hashSize)%this._hashSize}_legalize(t){const{_triangles:n,_halfedges:e,coords:r}=this;let i=0,o=0;for(;;){const a=e[t],u=t-t%3;if(o=u+(t+2)%3,-1===a){if(0===i)break;t=Ka[--i];continue}const c=a-a%3,f=u+(t+1)%3,s=c+(a+2)%3,l=n[o],h=n[t],d=n[f],p=n[s];if(tu(r[2*l],r[2*l+1],r[2*h],r[2*h+1],r[2*d],r[2*d+1],r[2*p],r[2*p+1])){n[t]=p,n[a]=l;const r=e[s];if(-1===r){let n=this._hullStart;do{if(this._hullTri[n]===s){this._hullTri[n]=t;break}n=this._hullPrev[n]}while(n!==this._hullStart)}this._link(t,r),this._link(a,e[o]),this._link(o,s);const u=c+(a+1)%3;i<Ka.length&&(Ka[i++]=u)}else{if(0===i)break;t=Ka[--i]}}return o}_link(t,n){this._halfedges[t]=n,-1!==n&&(this._halfedges[n]=t)}_addTriangle(t,n,e,r,i,o){const a=this.trianglesLen;return this._triangles[a]=t,this._triangles[a+1]=n,this._triangles[a+2]=e,this._link(a,r),this._link(a+1,i),this._link(a+2,o),this.trianglesLen+=3,a}}function Ja(t,n,e,r){const i=t-e,o=n-r;return i*i+o*o}function tu(t,n,e,r,i,o,a,u){const c=t-a,f=n-u,s=e-a,l=r-u,h=i-a,d=o-u,p=s*s+l*l,g=h*h+d*d;return c*(l*g-p*d)-f*(s*g-p*h)+(c*c+f*f)*(s*d-l*h)<0}function nu(t,n,e,r,i,o){const a=e-t,u=r-n,c=i-t,f=o-n,s=a*a+u*u,l=c*c+f*f,h=.5/(a*f-u*c),d=(f*s-u*l)*h,p=(a*l-c*s)*h;return d*d+p*p}function eu(t,n,e,r){if(r-e<=20)for(let i=e+1;i<=r;i++){const r=t[i],o=n[r];let a=i-1;for(;a>=e&&n[t[a]]>o;)t[a+1]=t[a--];t[a+1]=r}else{let i=e+1,o=r;ru(t,e+r>>1,i),n[t[e]]>n[t[r]]&&ru(t,e,r),n[t[i]]>n[t[r]]&&ru(t,i,r),n[t[e]]>n[t[i]]&&ru(t,e,i);const a=t[i],u=n[a];for(;;){do{i++}while(n[t[i]]<u);do{o--}while(n[t[o]]>u);if(o<i)break;ru(t,i,o)}t[e+1]=t[o],t[o]=a,r-i+1>=o-e?(eu(t,n,i,r),eu(t,n,e,o-1)):(eu(t,n,e,o-1),eu(t,n,i,r))}}function ru(t,n,e){const r=t[n];t[n]=t[e],t[e]=r}function iu(t){return t[0]}function ou(t){return t[1]}const au=1e-6;class uu{constructor(){this._x0=this._y0=this._x1=this._y1=null,this._=""}moveTo(t,n){this._+=`M${this._x0=this._x1=+t},${this._y0=this._y1=+n}`}closePath(){null!==this._x1&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")}lineTo(t,n){this._+=`L${this._x1=+t},${this._y1=+n}`}arc(t,n,e){const r=(t=+t)+(e=+e),i=n=+n;if(e<0)throw new Error("negative radius");null===this._x1?this._+=`M${r},${i}`:(Math.abs(this._x1-r)>au||Math.abs(this._y1-i)>au)&&(this._+="L"+r+","+i),e&&(this._+=`A${e},${e},0,1,1,${t-e},${n}A${e},${e},0,1,1,${this._x1=r},${this._y1=i}`)}rect(t,n,e,r){this._+=`M${this._x0=this._x1=+t},${this._y0=this._y1=+n}h${+e}v${+r}h${-e}Z`}value(){return this._||null}}class cu{constructor(){this._=[]}moveTo(t,n){this._.push([t,n])}closePath(){this._.push(this._[0].slice())}lineTo(t,n){this._.push([t,n])}value(){return this._.length?this._:null}}class fu{constructor(t,[n,e,r,i]=[0,0,960,500]){if(!((r=+r)>=(n=+n)&&(i=+i)>=(e=+e)))throw new Error("invalid bounds");this.delaunay=t,this._circumcenters=new Float64Array(2*t.points.length),this.vectors=new Float64Array(2*t.points.length),this.xmax=r,this.xmin=n,this.ymax=i,this.ymin=e,this._init()}update(){return this.delaunay.update(),this._init(),this}_init(){const{delaunay:{points:t,hull:n,triangles:e},vectors:r}=this,i=this.circumcenters=this._circumcenters.subarray(0,e.length/3*2);for(let n,r,o=0,a=0,u=e.length;o<u;o+=3,a+=2){const u=2*e[o],c=2*e[o+1],f=2*e[o+2],s=t[u],l=t[u+1],h=t[c],d=t[c+1],p=t[f],g=t[f+1],y=h-s,v=d-l,_=p-s,b=g-l,m=2*(y*b-v*_);if(Math.abs(m)<1e-9){let i=1e9;const o=2*e[0];i*=Math.sign((t[o]-s)*b-(t[o+1]-l)*_),n=(s+p)/2-i*b,r=(l+g)/2+i*_}else{const t=1/m,e=y*y+v*v,i=_*_+b*b;n=s+(b*e-v*i)*t,r=l+(y*i-_*e)*t}i[a]=n,i[a+1]=r}let o,a,u,c=n[n.length-1],f=4*c,s=t[2*c],l=t[2*c+1];r.fill(0);for(let e=0;e<n.length;++e)c=n[e],o=f,a=s,u=l,f=4*c,s=t[2*c],l=t[2*c+1],r[o+2]=r[f]=u-l,r[o+3]=r[f+1]=s-a}render(t){const n=null==t?t=new uu:void 0,{delaunay:{halfedges:e,inedges:r,hull:i},circumcenters:o,vectors:a}=this;if(i.length<=1)return null;for(let n=0,r=e.length;n<r;++n){const r=e[n];if(r<n)continue;const i=2*Math.floor(n/3),a=2*Math.floor(r/3),u=o[i],c=o[i+1],f=o[a],s=o[a+1];this._renderSegment(u,c,f,s,t)}let u,c=i[i.length-1];for(let n=0;n<i.length;++n){u=c,c=i[n];const e=2*Math.floor(r[c]/3),f=o[e],s=o[e+1],l=4*u,h=this._project(f,s,a[l+2],a[l+3]);h&&this._renderSegment(f,s,h[0],h[1],t)}return n&&n.value()}renderBounds(t){const n=null==t?t=new uu:void 0;return t.rect(this.xmin,this.ymin,this.xmax-this.xmin,this.ymax-this.ymin),n&&n.value()}renderCell(t,n){const e=null==n?n=new uu:void 0,r=this._clip(t);if(null===r||!r.length)return;n.moveTo(r[0],r[1]);let i=r.length;for(;r[0]===r[i-2]&&r[1]===r[i-1]&&i>1;)i-=2;for(let t=2;t<i;t+=2)r[t]===r[t-2]&&r[t+1]===r[t-1]||n.lineTo(r[t],r[t+1]);return n.closePath(),e&&e.value()}*cellPolygons(){const{delaunay:{points:t}}=this;for(let n=0,e=t.length/2;n<e;++n){const t=this.cellPolygon(n);t&&(t.index=n,yield t)}}cellPolygon(t){const n=new cu;return this.renderCell(t,n),n.value()}_renderSegment(t,n,e,r,i){let o;const a=this._regioncode(t,n),u=this._regioncode(e,r);0===a&&0===u?(i.moveTo(t,n),i.lineTo(e,r)):(o=this._clipSegment(t,n,e,r,a,u))&&(i.moveTo(o[0],o[1]),i.lineTo(o[2],o[3]))}contains(t,n,e){return(n=+n)==n&&(e=+e)==e&&this.delaunay._step(t,n,e)===t}*neighbors(t){const n=this._clip(t);if(n)for(const e of this.delaunay.neighbors(t)){const t=this._clip(e);if(t)t:for(let r=0,i=n.length;r<i;r+=2)for(let o=0,a=t.length;o<a;o+=2)if(n[r]==t[o]&&n[r+1]==t[o+1]&&n[(r+2)%i]==t[(o+a-2)%a]&&n[(r+3)%i]==t[(o+a-1)%a]){yield e;break t}}}_cell(t){const{circumcenters:n,delaunay:{inedges:e,halfedges:r,triangles:i}}=this,o=e[t];if(-1===o)return null;const a=[];let u=o;do{const e=Math.floor(u/3);if(a.push(n[2*e],n[2*e+1]),u=u%3==2?u-2:u+1,i[u]!==t)break;u=r[u]}while(u!==o&&-1!==u);return a}_clip(t){if(0===t&&1===this.delaunay.hull.length)return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];const n=this._cell(t);if(null===n)return null;const{vectors:e}=this,r=4*t;return e[r]||e[r+1]?this._clipInfinite(t,n,e[r],e[r+1],e[r+2],e[r+3]):this._clipFinite(t,n)}_clipFinite(t,n){const e=n.length;let r,i,o,a,u=null,c=n[e-2],f=n[e-1],s=this._regioncode(c,f),l=0;for(let h=0;h<e;h+=2)if(r=c,i=f,c=n[h],f=n[h+1],o=s,s=this._regioncode(c,f),0===o&&0===s)a=l,l=0,u?u.push(c,f):u=[c,f];else{let n,e,h,d,p;if(0===o){if(null===(n=this._clipSegment(r,i,c,f,o,s)))continue;[e,h,d,p]=n}else{if(null===(n=this._clipSegment(c,f,r,i,s,o)))continue;[d,p,e,h]=n,a=l,l=this._edgecode(e,h),a&&l&&this._edge(t,a,l,u,u.length),u?u.push(e,h):u=[e,h]}a=l,l=this._edgecode(d,p),a&&l&&this._edge(t,a,l,u,u.length),u?u.push(d,p):u=[d,p]}if(u)a=l,l=this._edgecode(u[0],u[1]),a&&l&&this._edge(t,a,l,u,u.length);else if(this.contains(t,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2))return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];return u}_clipSegment(t,n,e,r,i,o){for(;;){if(0===i&&0===o)return[t,n,e,r];if(i&o)return null;let a,u,c=i||o;8&c?(a=t+(e-t)*(this.ymax-n)/(r-n),u=this.ymax):4&c?(a=t+(e-t)*(this.ymin-n)/(r-n),u=this.ymin):2&c?(u=n+(r-n)*(this.xmax-t)/(e-t),a=this.xmax):(u=n+(r-n)*(this.xmin-t)/(e-t),a=this.xmin),i?(t=a,n=u,i=this._regioncode(t,n)):(e=a,r=u,o=this._regioncode(e,r))}}_clipInfinite(t,n,e,r,i,o){let a,u=Array.from(n);if((a=this._project(u[0],u[1],e,r))&&u.unshift(a[0],a[1]),(a=this._project(u[u.length-2],u[u.length-1],i,o))&&u.push(a[0],a[1]),u=this._clipFinite(t,u))for(let n,e=0,r=u.length,i=this._edgecode(u[r-2],u[r-1]);e<r;e+=2)n=i,i=this._edgecode(u[e],u[e+1]),n&&i&&(e=this._edge(t,n,i,u,e),r=u.length);else this.contains(t,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2)&&(u=[this.xmin,this.ymin,this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax]);return u}_edge(t,n,e,r,i){for(;n!==e;){let e,o;switch(n){case 5:n=4;continue;case 4:n=6,e=this.xmax,o=this.ymin;break;case 6:n=2;continue;case 2:n=10,e=this.xmax,o=this.ymax;break;case 10:n=8;continue;case 8:n=9,e=this.xmin,o=this.ymax;break;case 9:n=1;continue;case 1:n=5,e=this.xmin,o=this.ymin}r[i]===e&&r[i+1]===o||!this.contains(t,e,o)||(r.splice(i,0,e,o),i+=2)}if(r.length>4)for(let t=0;t<r.length;t+=2){const n=(t+2)%r.length,e=(t+4)%r.length;(r[t]===r[n]&&r[n]===r[e]||r[t+1]===r[n+1]&&r[n+1]===r[e+1])&&(r.splice(n,2),t-=2)}return i}_project(t,n,e,r){let i,o,a,u=1/0;if(r<0){if(n<=this.ymin)return null;(i=(this.ymin-n)/r)<u&&(a=this.ymin,o=t+(u=i)*e)}else if(r>0){if(n>=this.ymax)return null;(i=(this.ymax-n)/r)<u&&(a=this.ymax,o=t+(u=i)*e)}if(e>0){if(t>=this.xmax)return null;(i=(this.xmax-t)/e)<u&&(o=this.xmax,a=n+(u=i)*r)}else if(e<0){if(t<=this.xmin)return null;(i=(this.xmin-t)/e)<u&&(o=this.xmin,a=n+(u=i)*r)}return[o,a]}_edgecode(t,n){return(t===this.xmin?1:t===this.xmax?2:0)|(n===this.ymin?4:n===this.ymax?8:0)}_regioncode(t,n){return(t<this.xmin?1:t>this.xmax?2:0)|(n<this.ymin?4:n>this.ymax?8:0)}}const su=2*Math.PI,lu=Math.pow;function hu(t){return t[0]}function du(t){return t[1]}function pu(t,n,e){return[t+Math.sin(t+n)*e,n+Math.cos(t-n)*e]}class gu{static from(t,n=hu,e=du,r){return new gu("length"in t?function(t,n,e,r){const i=t.length,o=new Float64Array(2*i);for(let a=0;a<i;++a){const i=t[a];o[2*a]=n.call(r,i,a,t),o[2*a+1]=e.call(r,i,a,t)}return o}(t,n,e,r):Float64Array.from(function*(t,n,e,r){let i=0;for(const o of t)yield n.call(r,o,i,t),yield e.call(r,o,i,t),++i}(t,n,e,r)))}constructor(t){this._delaunator=new Qa(t),this.inedges=new Int32Array(t.length/2),this._hullIndex=new Int32Array(t.length/2),this.points=this._delaunator.coords,this._init()}update(){return this._delaunator.update(),this._init(),this}_init(){const t=this._delaunator,n=this.points;if(t.hull&&t.hull.length>2&&function(t){const{triangles:n,coords:e}=t;for(let t=0;t<n.length;t+=3){const r=2*n[t],i=2*n[t+1],o=2*n[t+2];if((e[o]-e[r])*(e[i+1]-e[r+1])-(e[i]-e[r])*(e[o+1]-e[r+1])>1e-10)return!1}return!0}(t)){this.collinear=Int32Array.from({length:n.length/2},((t,n)=>n)).sort(((t,e)=>n[2*t]-n[2*e]||n[2*t+1]-n[2*e+1]));const t=this.collinear[0],e=this.collinear[this.collinear.length-1],r=[n[2*t],n[2*t+1],n[2*e],n[2*e+1]],i=1e-8*Math.hypot(r[3]-r[1],r[2]-r[0]);for(let t=0,e=n.length/2;t<e;++t){const e=pu(n[2*t],n[2*t+1],i);n[2*t]=e[0],n[2*t+1]=e[1]}this._delaunator=new Qa(n)}else delete this.collinear;const e=this.halfedges=this._delaunator.halfedges,r=this.hull=this._delaunator.hull,i=this.triangles=this._delaunator.triangles,o=this.inedges.fill(-1),a=this._hullIndex.fill(-1);for(let t=0,n=e.length;t<n;++t){const n=i[t%3==2?t-2:t+1];-1!==e[t]&&-1!==o[n]||(o[n]=t)}for(let t=0,n=r.length;t<n;++t)a[r[t]]=t;r.length<=2&&r.length>0&&(this.triangles=new Int32Array(3).fill(-1),this.halfedges=new Int32Array(3).fill(-1),this.triangles[0]=r[0],o[r[0]]=1,2===r.length&&(o[r[1]]=0,this.triangles[1]=r[1],this.triangles[2]=r[1]))}voronoi(t){return new fu(this,t)}*neighbors(t){const{inedges:n,hull:e,_hullIndex:r,halfedges:i,triangles:o,collinear:a}=this;if(a){const n=a.indexOf(t);return n>0&&(yield a[n-1]),void(n<a.length-1&&(yield a[n+1]))}const u=n[t];if(-1===u)return;let c=u,f=-1;do{if(yield f=o[c],c=c%3==2?c-2:c+1,o[c]!==t)return;if(c=i[c],-1===c){const n=e[(r[t]+1)%e.length];return void(n!==f&&(yield n))}}while(c!==u)}find(t,n,e=0){if((t=+t)!=t||(n=+n)!=n)return-1;const r=e;let i;for(;(i=this._step(e,t,n))>=0&&i!==e&&i!==r;)e=i;return i}_step(t,n,e){const{inedges:r,hull:i,_hullIndex:o,halfedges:a,triangles:u,points:c}=this;if(-1===r[t]||!c.length)return(t+1)%(c.length>>1);let f=t,s=lu(n-c[2*t],2)+lu(e-c[2*t+1],2);const l=r[t];let h=l;do{let r=u[h];const l=lu(n-c[2*r],2)+lu(e-c[2*r+1],2);if(l<s&&(s=l,f=r),h=h%3==2?h-2:h+1,u[h]!==t)break;if(h=a[h],-1===h){if(h=i[(o[t]+1)%i.length],h!==r&&lu(n-c[2*h],2)+lu(e-c[2*h+1],2)<s)return h;break}}while(h!==l);return f}render(t){const n=null==t?t=new uu:void 0,{points:e,halfedges:r,triangles:i}=this;for(let n=0,o=r.length;n<o;++n){const o=r[n];if(o<n)continue;const a=2*i[n],u=2*i[o];t.moveTo(e[a],e[a+1]),t.lineTo(e[u],e[u+1])}return this.renderHull(t),n&&n.value()}renderPoints(t,n){void 0!==n||t&&"function"==typeof t.moveTo||(n=t,t=null),n=null==n?2:+n;const e=null==t?t=new uu:void 0,{points:r}=this;for(let e=0,i=r.length;e<i;e+=2){const i=r[e],o=r[e+1];t.moveTo(i+n,o),t.arc(i,o,n,0,su)}return e&&e.value()}renderHull(t){const n=null==t?t=new uu:void 0,{hull:e,points:r}=this,i=2*e[0],o=e.length;t.moveTo(r[i],r[i+1]);for(let n=1;n<o;++n){const i=2*e[n];t.lineTo(r[i],r[i+1])}return t.closePath(),n&&n.value()}hullPolygon(){const t=new cu;return this.renderHull(t),t.value()}renderTriangle(t,n){const e=null==n?n=new uu:void 0,{points:r,triangles:i}=this,o=2*i[t*=3],a=2*i[t+1],u=2*i[t+2];return n.moveTo(r[o],r[o+1]),n.lineTo(r[a],r[a+1]),n.lineTo(r[u],r[u+1]),n.closePath(),e&&e.value()}*trianglePolygons(){const{triangles:t}=this;for(let n=0,e=t.length/3;n<e;++n)yield this.trianglePolygon(n)}trianglePolygon(t){const n=new cu;return this.renderTriangle(t,n),n.value()}}var yu={},vu={};function _u(t){return new Function("d","return {"+t.map((function(t,n){return JSON.stringify(t)+": d["+n+'] || ""'})).join(",")+"}")}function bu(t){var n=Object.create(null),e=[];return t.forEach((function(t){for(var r in t)r in n||e.push(n[r]=r)})),e}function mu(t,n){var e=t+"",r=e.length;return r<n?new Array(n-r+1).join(0)+e:e}function xu(t){var n=t.getUTCHours(),e=t.getUTCMinutes(),r=t.getUTCSeconds(),i=t.getUTCMilliseconds();return isNaN(t)?"Invalid Date":function(t){return t<0?"-"+mu(-t,6):t>9999?"+"+mu(t,6):mu(t,4)}(t.getUTCFullYear())+"-"+mu(t.getUTCMonth()+1,2)+"-"+mu(t.getUTCDate(),2)+(i?"T"+mu(n,2)+":"+mu(e,2)+":"+mu(r,2)+"."+mu(i,3)+"Z":r?"T"+mu(n,2)+":"+mu(e,2)+":"+mu(r,2)+"Z":e||n?"T"+mu(n,2)+":"+mu(e,2)+"Z":"")}function wu(t){var n=new RegExp('["'+t+"\n\r]"),e=t.charCodeAt(0);function r(t,n){var r,i=[],o=t.length,a=0,u=0,c=o<=0,f=!1;function s(){if(c)return vu;if(f)return f=!1,yu;var n,r,i=a;if(34===t.charCodeAt(i)){for(;a++<o&&34!==t.charCodeAt(a)||34===t.charCodeAt(++a););return(n=a)>=o?c=!0:10===(r=t.charCodeAt(a++))?f=!0:13===r&&(f=!0,10===t.charCodeAt(a)&&++a),t.slice(i+1,n-1).replace(/""/g,'"')}for(;a<o;){if(10===(r=t.charCodeAt(n=a++)))f=!0;else if(13===r)f=!0,10===t.charCodeAt(a)&&++a;else if(r!==e)continue;return t.slice(i,n)}return c=!0,t.slice(i,o)}for(10===t.charCodeAt(o-1)&&--o,13===t.charCodeAt(o-1)&&--o;(r=s())!==vu;){for(var l=[];r!==yu&&r!==vu;)l.push(r),r=s();n&&null==(l=n(l,u++))||i.push(l)}return i}function i(n,e){return n.map((function(n){return e.map((function(t){return a(n[t])})).join(t)}))}function o(n){return n.map(a).join(t)}function a(t){return null==t?"":t instanceof Date?xu(t):n.test(t+="")?'"'+t.replace(/"/g,'""')+'"':t}return{parse:function(t,n){var e,i,o=r(t,(function(t,r){if(e)return e(t,r-1);i=t,e=n?function(t,n){var e=_u(t);return function(r,i){return n(e(r),i,t)}}(t,n):_u(t)}));return o.columns=i||[],o},parseRows:r,format:function(n,e){return null==e&&(e=bu(n)),[e.map(a).join(t)].concat(i(n,e)).join("\n")},formatBody:function(t,n){return null==n&&(n=bu(t)),i(t,n).join("\n")},formatRows:function(t){return t.map(o).join("\n")},formatRow:o,formatValue:a}}var Mu=wu(","),Au=Mu.parse,Tu=Mu.parseRows,Su=Mu.format,Eu=Mu.formatBody,ku=Mu.formatRows,Nu=Mu.formatRow,Cu=Mu.formatValue,Pu=wu("\t"),zu=Pu.parse,Du=Pu.parseRows,Ru=Pu.format,Fu=Pu.formatBody,qu=Pu.formatRows,Ou=Pu.formatRow,Uu=Pu.formatValue;const Iu=new Date("2019-01-01T00:00").getHours()||new Date("2019-07-01T00:00").getHours();function Bu(t){if(!t.ok)throw new Error(t.status+" "+t.statusText);return t.blob()}function Yu(t){if(!t.ok)throw new Error(t.status+" "+t.statusText);return t.arrayBuffer()}function Lu(t){if(!t.ok)throw new Error(t.status+" "+t.statusText);return t.text()}function ju(t,n){return fetch(t,n).then(Lu)}function Hu(t){return function(n,e,r){return 2===arguments.length&&"function"==typeof e&&(r=e,e=void 0),ju(n,e).then((function(n){return t(n,r)}))}}var Xu=Hu(Au),Gu=Hu(zu);function Vu(t){if(!t.ok)throw new Error(t.status+" "+t.statusText);if(204!==t.status&&205!==t.status)return t.json()}function $u(t){return(n,e)=>ju(n,e).then((n=>(new DOMParser).parseFromString(n,t)))}var Wu=$u("application/xml"),Zu=$u("text/html"),Ku=$u("image/svg+xml");function Qu(t,n,e,r){if(isNaN(n)||isNaN(e))return t;var i,o,a,u,c,f,s,l,h,d=t._root,p={data:r},g=t._x0,y=t._y0,v=t._x1,_=t._y1;if(!d)return t._root=p,t;for(;d.length;)if((f=n>=(o=(g+v)/2))?g=o:v=o,(s=e>=(a=(y+_)/2))?y=a:_=a,i=d,!(d=d[l=s<<1|f]))return i[l]=p,t;if(u=+t._x.call(null,d.data),c=+t._y.call(null,d.data),n===u&&e===c)return p.next=d,i?i[l]=p:t._root=p,t;do{i=i?i[l]=new Array(4):t._root=new Array(4),(f=n>=(o=(g+v)/2))?g=o:v=o,(s=e>=(a=(y+_)/2))?y=a:_=a}while((l=s<<1|f)==(h=(c>=a)<<1|u>=o));return i[h]=d,i[l]=p,t}function Ju(t,n,e,r,i){this.node=t,this.x0=n,this.y0=e,this.x1=r,this.y1=i}function tc(t){return t[0]}function nc(t){return t[1]}function ec(t,n,e){var r=new rc(null==n?tc:n,null==e?nc:e,NaN,NaN,NaN,NaN);return null==t?r:r.addAll(t)}function rc(t,n,e,r,i,o){this._x=t,this._y=n,this._x0=e,this._y0=r,this._x1=i,this._y1=o,this._root=void 0}function ic(t){for(var n={data:t.data},e=n;t=t.next;)e=e.next={data:t.data};return n}var oc=ec.prototype=rc.prototype;function ac(t){return function(){return t}}function uc(t){return 1e-6*(t()-.5)}function cc(t){return t.x+t.vx}function fc(t){return t.y+t.vy}function sc(t){return t.index}function lc(t,n){var e=t.get(n);if(!e)throw new Error("node not found: "+n);return e}oc.copy=function(){var t,n,e=new rc(this._x,this._y,this._x0,this._y0,this._x1,this._y1),r=this._root;if(!r)return e;if(!r.length)return e._root=ic(r),e;for(t=[{source:r,target:e._root=new Array(4)}];r=t.pop();)for(var i=0;i<4;++i)(n=r.source[i])&&(n.length?t.push({source:n,target:r.target[i]=new Array(4)}):r.target[i]=ic(n));return e},oc.add=function(t){const n=+this._x.call(null,t),e=+this._y.call(null,t);return Qu(this.cover(n,e),n,e,t)},oc.addAll=function(t){var n,e,r,i,o=t.length,a=new Array(o),u=new Array(o),c=1/0,f=1/0,s=-1/0,l=-1/0;for(e=0;e<o;++e)isNaN(r=+this._x.call(null,n=t[e]))||isNaN(i=+this._y.call(null,n))||(a[e]=r,u[e]=i,r<c&&(c=r),r>s&&(s=r),i<f&&(f=i),i>l&&(l=i));if(c>s||f>l)return this;for(this.cover(c,f).cover(s,l),e=0;e<o;++e)Qu(this,a[e],u[e],t[e]);return this},oc.cover=function(t,n){if(isNaN(t=+t)||isNaN(n=+n))return this;var e=this._x0,r=this._y0,i=this._x1,o=this._y1;if(isNaN(e))i=(e=Math.floor(t))+1,o=(r=Math.floor(n))+1;else{for(var a,u,c=i-e||1,f=this._root;e>t||t>=i||r>n||n>=o;)switch(u=(n<r)<<1|t<e,(a=new Array(4))[u]=f,f=a,c*=2,u){case 0:i=e+c,o=r+c;break;case 1:e=i-c,o=r+c;break;case 2:i=e+c,r=o-c;break;case 3:e=i-c,r=o-c}this._root&&this._root.length&&(this._root=f)}return this._x0=e,this._y0=r,this._x1=i,this._y1=o,this},oc.data=function(){var t=[];return this.visit((function(n){if(!n.length)do{t.push(n.data)}while(n=n.next)})),t},oc.extent=function(t){return arguments.length?this.cover(+t[0][0],+t[0][1]).cover(+t[1][0],+t[1][1]):isNaN(this._x0)?void 0:[[this._x0,this._y0],[this._x1,this._y1]]},oc.find=function(t,n,e){var r,i,o,a,u,c,f,s=this._x0,l=this._y0,h=this._x1,d=this._y1,p=[],g=this._root;for(g&&p.push(new Ju(g,s,l,h,d)),null==e?e=1/0:(s=t-e,l=n-e,h=t+e,d=n+e,e*=e);c=p.pop();)if(!(!(g=c.node)||(i=c.x0)>h||(o=c.y0)>d||(a=c.x1)<s||(u=c.y1)<l))if(g.length){var y=(i+a)/2,v=(o+u)/2;p.push(new Ju(g[3],y,v,a,u),new Ju(g[2],i,v,y,u),new Ju(g[1],y,o,a,v),new Ju(g[0],i,o,y,v)),(f=(n>=v)<<1|t>=y)&&(c=p[p.length-1],p[p.length-1]=p[p.length-1-f],p[p.length-1-f]=c)}else{var _=t-+this._x.call(null,g.data),b=n-+this._y.call(null,g.data),m=_*_+b*b;if(m<e){var x=Math.sqrt(e=m);s=t-x,l=n-x,h=t+x,d=n+x,r=g.data}}return r},oc.remove=function(t){if(isNaN(o=+this._x.call(null,t))||isNaN(a=+this._y.call(null,t)))return this;var n,e,r,i,o,a,u,c,f,s,l,h,d=this._root,p=this._x0,g=this._y0,y=this._x1,v=this._y1;if(!d)return this;if(d.length)for(;;){if((f=o>=(u=(p+y)/2))?p=u:y=u,(s=a>=(c=(g+v)/2))?g=c:v=c,n=d,!(d=d[l=s<<1|f]))return this;if(!d.length)break;(n[l+1&3]||n[l+2&3]||n[l+3&3])&&(e=n,h=l)}for(;d.data!==t;)if(r=d,!(d=d.next))return this;return(i=d.next)&&delete d.next,r?(i?r.next=i:delete r.next,this):n?(i?n[l]=i:delete n[l],(d=n[0]||n[1]||n[2]||n[3])&&d===(n[3]||n[2]||n[1]||n[0])&&!d.length&&(e?e[h]=d:this._root=d),this):(this._root=i,this)},oc.removeAll=function(t){for(var n=0,e=t.length;n<e;++n)this.remove(t[n]);return this},oc.root=function(){return this._root},oc.size=function(){var t=0;return this.visit((function(n){if(!n.length)do{++t}while(n=n.next)})),t},oc.visit=function(t){var n,e,r,i,o,a,u=[],c=this._root;for(c&&u.push(new Ju(c,this._x0,this._y0,this._x1,this._y1));n=u.pop();)if(!t(c=n.node,r=n.x0,i=n.y0,o=n.x1,a=n.y1)&&c.length){var f=(r+o)/2,s=(i+a)/2;(e=c[3])&&u.push(new Ju(e,f,s,o,a)),(e=c[2])&&u.push(new Ju(e,r,s,f,a)),(e=c[1])&&u.push(new Ju(e,f,i,o,s)),(e=c[0])&&u.push(new Ju(e,r,i,f,s))}return this},oc.visitAfter=function(t){var n,e=[],r=[];for(this._root&&e.push(new Ju(this._root,this._x0,this._y0,this._x1,this._y1));n=e.pop();){var i=n.node;if(i.length){var o,a=n.x0,u=n.y0,c=n.x1,f=n.y1,s=(a+c)/2,l=(u+f)/2;(o=i[0])&&e.push(new Ju(o,a,u,s,l)),(o=i[1])&&e.push(new Ju(o,s,u,c,l)),(o=i[2])&&e.push(new Ju(o,a,l,s,f)),(o=i[3])&&e.push(new Ju(o,s,l,c,f))}r.push(n)}for(;n=r.pop();)t(n.node,n.x0,n.y0,n.x1,n.y1);return this},oc.x=function(t){return arguments.length?(this._x=t,this):this._x},oc.y=function(t){return arguments.length?(this._y=t,this):this._y};const hc=4294967296;function dc(t){return t.x}function pc(t){return t.y}var gc=Math.PI*(3-Math.sqrt(5));function yc(t,n){if((e=(t=n?t.toExponential(n-1):t.toExponential()).indexOf("e"))<0)return null;var e,r=t.slice(0,e);return[r.length>1?r[0]+r.slice(2):r,+t.slice(e+1)]}function vc(t){return(t=yc(Math.abs(t)))?t[1]:NaN}var _c,bc=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function mc(t){if(!(n=bc.exec(t)))throw new Error("invalid format: "+t);var n;return new xc({fill:n[1],align:n[2],sign:n[3],symbol:n[4],zero:n[5],width:n[6],comma:n[7],precision:n[8]&&n[8].slice(1),trim:n[9],type:n[10]})}function xc(t){this.fill=void 0===t.fill?" ":t.fill+"",this.align=void 0===t.align?">":t.align+"",this.sign=void 0===t.sign?"-":t.sign+"",this.symbol=void 0===t.symbol?"":t.symbol+"",this.zero=!!t.zero,this.width=void 0===t.width?void 0:+t.width,this.comma=!!t.comma,this.precision=void 0===t.precision?void 0:+t.precision,this.trim=!!t.trim,this.type=void 0===t.type?"":t.type+""}function wc(t,n){var e=yc(t,n);if(!e)return t+"";var r=e[0],i=e[1];return i<0?"0."+new Array(-i).join("0")+r:r.length>i+1?r.slice(0,i+1)+"."+r.slice(i+1):r+new Array(i-r.length+2).join("0")}mc.prototype=xc.prototype,xc.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(void 0===this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(void 0===this.precision?"":"."+Math.max(0,0|this.precision))+(this.trim?"~":"")+this.type};var Mc={"%":(t,n)=>(100*t).toFixed(n),b:t=>Math.round(t).toString(2),c:t=>t+"",d:function(t){return Math.abs(t=Math.round(t))>=1e21?t.toLocaleString("en").replace(/,/g,""):t.toString(10)},e:(t,n)=>t.toExponential(n),f:(t,n)=>t.toFixed(n),g:(t,n)=>t.toPrecision(n),o:t=>Math.round(t).toString(8),p:(t,n)=>wc(100*t,n),r:wc,s:function(t,n){var e=yc(t,n);if(!e)return t+"";var r=e[0],i=e[1],o=i-(_c=3*Math.max(-8,Math.min(8,Math.floor(i/3))))+1,a=r.length;return o===a?r:o>a?r+new Array(o-a+1).join("0"):o>0?r.slice(0,o)+"."+r.slice(o):"0."+new Array(1-o).join("0")+yc(t,Math.max(0,n+o-1))[0]},X:t=>Math.round(t).toString(16).toUpperCase(),x:t=>Math.round(t).toString(16)};function Ac(t){return t}var Tc,Sc=Array.prototype.map,Ec=["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];function kc(t){var n,e,r=void 0===t.grouping||void 0===t.thousands?Ac:(n=Sc.call(t.grouping,Number),e=t.thousands+"",function(t,r){for(var i=t.length,o=[],a=0,u=n[0],c=0;i>0&&u>0&&(c+u+1>r&&(u=Math.max(1,r-c)),o.push(t.substring(i-=u,i+u)),!((c+=u+1)>r));)u=n[a=(a+1)%n.length];return o.reverse().join(e)}),i=void 0===t.currency?"":t.currency[0]+"",o=void 0===t.currency?"":t.currency[1]+"",a=void 0===t.decimal?".":t.decimal+"",u=void 0===t.numerals?Ac:function(t){return function(n){return n.replace(/[0-9]/g,(function(n){return t[+n]}))}}(Sc.call(t.numerals,String)),c=void 0===t.percent?"%":t.percent+"",f=void 0===t.minus?"−":t.minus+"",s=void 0===t.nan?"NaN":t.nan+"";function l(t){var n=(t=mc(t)).fill,e=t.align,l=t.sign,h=t.symbol,d=t.zero,p=t.width,g=t.comma,y=t.precision,v=t.trim,_=t.type;"n"===_?(g=!0,_="g"):Mc[_]||(void 0===y&&(y=12),v=!0,_="g"),(d||"0"===n&&"="===e)&&(d=!0,n="0",e="=");var b="$"===h?i:"#"===h&&/[boxX]/.test(_)?"0"+_.toLowerCase():"",m="$"===h?o:/[%p]/.test(_)?c:"",x=Mc[_],w=/[defgprs%]/.test(_);function M(t){var i,o,c,h=b,M=m;if("c"===_)M=x(t)+M,t="";else{var A=(t=+t)<0||1/t<0;if(t=isNaN(t)?s:x(Math.abs(t),y),v&&(t=function(t){t:for(var n,e=t.length,r=1,i=-1;r<e;++r)switch(t[r]){case".":i=n=r;break;case"0":0===i&&(i=r),n=r;break;default:if(!+t[r])break t;i>0&&(i=0)}return i>0?t.slice(0,i)+t.slice(n+1):t}(t)),A&&0==+t&&"+"!==l&&(A=!1),h=(A?"("===l?l:f:"-"===l||"("===l?"":l)+h,M=("s"===_?Ec[8+_c/3]:"")+M+(A&&"("===l?")":""),w)for(i=-1,o=t.length;++i<o;)if(48>(c=t.charCodeAt(i))||c>57){M=(46===c?a+t.slice(i+1):t.slice(i))+M,t=t.slice(0,i);break}}g&&!d&&(t=r(t,1/0));var T=h.length+t.length+M.length,S=T<p?new Array(p-T+1).join(n):"";switch(g&&d&&(t=r(S+t,S.length?p-M.length:1/0),S=""),e){case"<":t=h+t+M+S;break;case"=":t=h+S+t+M;break;case"^":t=S.slice(0,T=S.length>>1)+h+t+M+S.slice(T);break;default:t=S+h+t+M}return u(t)}return y=void 0===y?6:/[gprs]/.test(_)?Math.max(1,Math.min(21,y)):Math.max(0,Math.min(20,y)),M.toString=function(){return t+""},M}return{format:l,formatPrefix:function(t,n){var e=l(((t=mc(t)).type="f",t)),r=3*Math.max(-8,Math.min(8,Math.floor(vc(n)/3))),i=Math.pow(10,-r),o=Ec[8+r/3];return function(t){return e(i*t)+o}}}}function Nc(n){return Tc=kc(n),t.format=Tc.format,t.formatPrefix=Tc.formatPrefix,Tc}function Cc(t){return Math.max(0,-vc(Math.abs(t)))}function Pc(t,n){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(vc(n)/3)))-vc(Math.abs(t)))}function zc(t,n){return t=Math.abs(t),n=Math.abs(n)-t,Math.max(0,vc(n)-vc(t))+1}t.format=void 0,t.formatPrefix=void 0,Nc({thousands:",",grouping:[3],currency:["$",""]});var Dc=1e-6,Rc=1e-12,Fc=Math.PI,qc=Fc/2,Oc=Fc/4,Uc=2*Fc,Ic=180/Fc,Bc=Fc/180,Yc=Math.abs,Lc=Math.atan,jc=Math.atan2,Hc=Math.cos,Xc=Math.ceil,Gc=Math.exp,Vc=Math.hypot,$c=Math.log,Wc=Math.pow,Zc=Math.sin,Kc=Math.sign||function(t){return t>0?1:t<0?-1:0},Qc=Math.sqrt,Jc=Math.tan;function tf(t){return t>1?0:t<-1?Fc:Math.acos(t)}function nf(t){return t>1?qc:t<-1?-qc:Math.asin(t)}function ef(t){return(t=Zc(t/2))*t}function rf(){}function of(t,n){t&&uf.hasOwnProperty(t.type)&&uf[t.type](t,n)}var af={Feature:function(t,n){of(t.geometry,n)},FeatureCollection:function(t,n){for(var e=t.features,r=-1,i=e.length;++r<i;)of(e[r].geometry,n)}},uf={Sphere:function(t,n){n.sphere()},Point:function(t,n){t=t.coordinates,n.point(t[0],t[1],t[2])},MultiPoint:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)t=e[r],n.point(t[0],t[1],t[2])},LineString:function(t,n){cf(t.coordinates,n,0)},MultiLineString:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)cf(e[r],n,0)},Polygon:function(t,n){ff(t.coordinates,n)},MultiPolygon:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)ff(e[r],n)},GeometryCollection:function(t,n){for(var e=t.geometries,r=-1,i=e.length;++r<i;)of(e[r],n)}};function cf(t,n,e){var r,i=-1,o=t.length-e;for(n.lineStart();++i<o;)r=t[i],n.point(r[0],r[1],r[2]);n.lineEnd()}function ff(t,n){var e=-1,r=t.length;for(n.polygonStart();++e<r;)cf(t[e],n,1);n.polygonEnd()}function sf(t,n){t&&af.hasOwnProperty(t.type)?af[t.type](t,n):of(t,n)}var lf,hf,df,pf,gf,yf,vf,_f,bf,mf,xf,wf,Mf,Af,Tf,Sf,Ef=new y,kf=new y,Nf={point:rf,lineStart:rf,lineEnd:rf,polygonStart:function(){Ef=new y,Nf.lineStart=Cf,Nf.lineEnd=Pf},polygonEnd:function(){var t=+Ef;kf.add(t<0?Uc+t:t),this.lineStart=this.lineEnd=this.point=rf},sphere:function(){kf.add(Uc)}};function Cf(){Nf.point=zf}function Pf(){Df(lf,hf)}function zf(t,n){Nf.point=Df,lf=t,hf=n,df=t*=Bc,pf=Hc(n=(n*=Bc)/2+Oc),gf=Zc(n)}function Df(t,n){var e=(t*=Bc)-df,r=e>=0?1:-1,i=r*e,o=Hc(n=(n*=Bc)/2+Oc),a=Zc(n),u=gf*a,c=pf*o+u*Hc(i),f=u*r*Zc(i);Ef.add(jc(f,c)),df=t,pf=o,gf=a}function Rf(t){return[jc(t[1],t[0]),nf(t[2])]}function Ff(t){var n=t[0],e=t[1],r=Hc(e);return[r*Hc(n),r*Zc(n),Zc(e)]}function qf(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]}function Of(t,n){return[t[1]*n[2]-t[2]*n[1],t[2]*n[0]-t[0]*n[2],t[0]*n[1]-t[1]*n[0]]}function Uf(t,n){t[0]+=n[0],t[1]+=n[1],t[2]+=n[2]}function If(t,n){return[t[0]*n,t[1]*n,t[2]*n]}function Bf(t){var n=Qc(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);t[0]/=n,t[1]/=n,t[2]/=n}var Yf,Lf,jf,Hf,Xf,Gf,Vf,$f,Wf,Zf,Kf,Qf,Jf,ts,ns,es,rs={point:is,lineStart:as,lineEnd:us,polygonStart:function(){rs.point=cs,rs.lineStart=fs,rs.lineEnd=ss,Af=new y,Nf.polygonStart()},polygonEnd:function(){Nf.polygonEnd(),rs.point=is,rs.lineStart=as,rs.lineEnd=us,Ef<0?(yf=-(_f=180),vf=-(bf=90)):Af>Dc?bf=90:Af<-1e-6&&(vf=-90),Sf[0]=yf,Sf[1]=_f},sphere:function(){yf=-(_f=180),vf=-(bf=90)}};function is(t,n){Tf.push(Sf=[yf=t,_f=t]),n<vf&&(vf=n),n>bf&&(bf=n)}function os(t,n){var e=Ff([t*Bc,n*Bc]);if(Mf){var r=Of(Mf,e),i=Of([r[1],-r[0],0],r);Bf(i),i=Rf(i);var o,a=t-mf,u=a>0?1:-1,c=i[0]*Ic*u,f=Yc(a)>180;f^(u*mf<c&&c<u*t)?(o=i[1]*Ic)>bf&&(bf=o):f^(u*mf<(c=(c+360)%360-180)&&c<u*t)?(o=-i[1]*Ic)<vf&&(vf=o):(n<vf&&(vf=n),n>bf&&(bf=n)),f?t<mf?ls(yf,t)>ls(yf,_f)&&(_f=t):ls(t,_f)>ls(yf,_f)&&(yf=t):_f>=yf?(t<yf&&(yf=t),t>_f&&(_f=t)):t>mf?ls(yf,t)>ls(yf,_f)&&(_f=t):ls(t,_f)>ls(yf,_f)&&(yf=t)}else Tf.push(Sf=[yf=t,_f=t]);n<vf&&(vf=n),n>bf&&(bf=n),Mf=e,mf=t}function as(){rs.point=os}function us(){Sf[0]=yf,Sf[1]=_f,rs.point=is,Mf=null}function cs(t,n){if(Mf){var e=t-mf;Af.add(Yc(e)>180?e+(e>0?360:-360):e)}else xf=t,wf=n;Nf.point(t,n),os(t,n)}function fs(){Nf.lineStart()}function ss(){cs(xf,wf),Nf.lineEnd(),Yc(Af)>Dc&&(yf=-(_f=180)),Sf[0]=yf,Sf[1]=_f,Mf=null}function ls(t,n){return(n-=t)<0?n+360:n}function hs(t,n){return t[0]-n[0]}function ds(t,n){return t[0]<=t[1]?t[0]<=n&&n<=t[1]:n<t[0]||t[1]<n}var ps={sphere:rf,point:gs,lineStart:vs,lineEnd:ms,polygonStart:function(){ps.lineStart=xs,ps.lineEnd=ws},polygonEnd:function(){ps.lineStart=vs,ps.lineEnd=ms}};function gs(t,n){t*=Bc;var e=Hc(n*=Bc);ys(e*Hc(t),e*Zc(t),Zc(n))}function ys(t,n,e){++Yf,jf+=(t-jf)/Yf,Hf+=(n-Hf)/Yf,Xf+=(e-Xf)/Yf}function vs(){ps.point=_s}function _s(t,n){t*=Bc;var e=Hc(n*=Bc);ts=e*Hc(t),ns=e*Zc(t),es=Zc(n),ps.point=bs,ys(ts,ns,es)}function bs(t,n){t*=Bc;var e=Hc(n*=Bc),r=e*Hc(t),i=e*Zc(t),o=Zc(n),a=jc(Qc((a=ns*o-es*i)*a+(a=es*r-ts*o)*a+(a=ts*i-ns*r)*a),ts*r+ns*i+es*o);Lf+=a,Gf+=a*(ts+(ts=r)),Vf+=a*(ns+(ns=i)),$f+=a*(es+(es=o)),ys(ts,ns,es)}function ms(){ps.point=gs}function xs(){ps.point=Ms}function ws(){As(Qf,Jf),ps.point=gs}function Ms(t,n){Qf=t,Jf=n,t*=Bc,n*=Bc,ps.point=As;var e=Hc(n);ts=e*Hc(t),ns=e*Zc(t),es=Zc(n),ys(ts,ns,es)}function As(t,n){t*=Bc;var e=Hc(n*=Bc),r=e*Hc(t),i=e*Zc(t),o=Zc(n),a=ns*o-es*i,u=es*r-ts*o,c=ts*i-ns*r,f=Vc(a,u,c),s=nf(f),l=f&&-s/f;Wf.add(l*a),Zf.add(l*u),Kf.add(l*c),Lf+=s,Gf+=s*(ts+(ts=r)),Vf+=s*(ns+(ns=i)),$f+=s*(es+(es=o)),ys(ts,ns,es)}function Ts(t){return function(){return t}}function Ss(t,n){function e(e,r){return e=t(e,r),n(e[0],e[1])}return t.invert&&n.invert&&(e.invert=function(e,r){return(e=n.invert(e,r))&&t.invert(e[0],e[1])}),e}function Es(t,n){return[Yc(t)>Fc?t+Math.round(-t/Uc)*Uc:t,n]}function ks(t,n,e){return(t%=Uc)?n||e?Ss(Cs(t),Ps(n,e)):Cs(t):n||e?Ps(n,e):Es}function Ns(t){return function(n,e){return[(n+=t)>Fc?n-Uc:n<-Fc?n+Uc:n,e]}}function Cs(t){var n=Ns(t);return n.invert=Ns(-t),n}function Ps(t,n){var e=Hc(t),r=Zc(t),i=Hc(n),o=Zc(n);function a(t,n){var a=Hc(n),u=Hc(t)*a,c=Zc(t)*a,f=Zc(n),s=f*e+u*r;return[jc(c*i-s*o,u*e-f*r),nf(s*i+c*o)]}return a.invert=function(t,n){var a=Hc(n),u=Hc(t)*a,c=Zc(t)*a,f=Zc(n),s=f*i-c*o;return[jc(c*i+f*o,u*e+s*r),nf(s*e-u*r)]},a}function zs(t){function n(n){return(n=t(n[0]*Bc,n[1]*Bc))[0]*=Ic,n[1]*=Ic,n}return t=ks(t[0]*Bc,t[1]*Bc,t.length>2?t[2]*Bc:0),n.invert=function(n){return(n=t.invert(n[0]*Bc,n[1]*Bc))[0]*=Ic,n[1]*=Ic,n},n}function Ds(t,n,e,r,i,o){if(e){var a=Hc(n),u=Zc(n),c=r*e;null==i?(i=n+r*Uc,o=n-c/2):(i=Rs(a,i),o=Rs(a,o),(r>0?i<o:i>o)&&(i+=r*Uc));for(var f,s=i;r>0?s>o:s<o;s-=c)f=Rf([a,-u*Hc(s),-u*Zc(s)]),t.point(f[0],f[1])}}function Rs(t,n){(n=Ff(n))[0]-=t,Bf(n);var e=tf(-n[1]);return((-n[2]<0?-e:e)+Uc-Dc)%Uc}function Fs(){var t,n=[];return{point:function(n,e,r){t.push([n,e,r])},lineStart:function(){n.push(t=[])},lineEnd:rf,rejoin:function(){n.length>1&&n.push(n.pop().concat(n.shift()))},result:function(){var e=n;return n=[],t=null,e}}}function qs(t,n){return Yc(t[0]-n[0])<Dc&&Yc(t[1]-n[1])<Dc}function Os(t,n,e,r){this.x=t,this.z=n,this.o=e,this.e=r,this.v=!1,this.n=this.p=null}function Us(t,n,e,r,i){var o,a,u=[],c=[];if(t.forEach((function(t){if(!((n=t.length-1)<=0)){var n,e,r=t[0],a=t[n];if(qs(r,a)){if(!r[2]&&!a[2]){for(i.lineStart(),o=0;o<n;++o)i.point((r=t[o])[0],r[1]);return void i.lineEnd()}a[0]+=2e-6}u.push(e=new Os(r,t,null,!0)),c.push(e.o=new Os(r,null,e,!1)),u.push(e=new Os(a,t,null,!1)),c.push(e.o=new Os(a,null,e,!0))}})),u.length){for(c.sort(n),Is(u),Is(c),o=0,a=c.length;o<a;++o)c[o].e=e=!e;for(var f,s,l=u[0];;){for(var h=l,d=!0;h.v;)if((h=h.n)===l)return;f=h.z,i.lineStart();do{if(h.v=h.o.v=!0,h.e){if(d)for(o=0,a=f.length;o<a;++o)i.point((s=f[o])[0],s[1]);else r(h.x,h.n.x,1,i);h=h.n}else{if(d)for(f=h.p.z,o=f.length-1;o>=0;--o)i.point((s=f[o])[0],s[1]);else r(h.x,h.p.x,-1,i);h=h.p}f=(h=h.o).z,d=!d}while(!h.v);i.lineEnd()}}}function Is(t){if(n=t.length){for(var n,e,r=0,i=t[0];++r<n;)i.n=e=t[r],e.p=i,i=e;i.n=e=t[0],e.p=i}}function Bs(t){return Yc(t[0])<=Fc?t[0]:Kc(t[0])*((Yc(t[0])+Fc)%Uc-Fc)}function Ys(t,n){var e=Bs(n),r=n[1],i=Zc(r),o=[Zc(e),-Hc(e),0],a=0,u=0,c=new y;1===i?r=qc+Dc:-1===i&&(r=-qc-Dc);for(var f=0,s=t.length;f<s;++f)if(h=(l=t[f]).length)for(var l,h,d=l[h-1],p=Bs(d),g=d[1]/2+Oc,v=Zc(g),_=Hc(g),b=0;b<h;++b,p=x,v=M,_=A,d=m){var m=l[b],x=Bs(m),w=m[1]/2+Oc,M=Zc(w),A=Hc(w),T=x-p,S=T>=0?1:-1,E=S*T,k=E>Fc,N=v*M;if(c.add(jc(N*S*Zc(E),_*A+N*Hc(E))),a+=k?T+S*Uc:T,k^p>=e^x>=e){var C=Of(Ff(d),Ff(m));Bf(C);var P=Of(o,C);Bf(P);var z=(k^T>=0?-1:1)*nf(P[2]);(r>z||r===z&&(C[0]||C[1]))&&(u+=k^T>=0?1:-1)}}return(a<-1e-6||a<Dc&&c<-1e-12)^1&u}function Ls(t,n,e,r){return function(i){var o,a,u,c=n(i),f=Fs(),s=n(f),l=!1,h={point:d,lineStart:g,lineEnd:y,polygonStart:function(){h.point=v,h.lineStart=_,h.lineEnd=b,a=[],o=[]},polygonEnd:function(){h.point=d,h.lineStart=g,h.lineEnd=y,a=K(a);var t=Ys(o,r);a.length?(l||(i.polygonStart(),l=!0),Us(a,Hs,t,e,i)):t&&(l||(i.polygonStart(),l=!0),i.lineStart(),e(null,null,1,i),i.lineEnd()),l&&(i.polygonEnd(),l=!1),a=o=null},sphere:function(){i.polygonStart(),i.lineStart(),e(null,null,1,i),i.lineEnd(),i.polygonEnd()}};function d(n,e){t(n,e)&&i.point(n,e)}function p(t,n){c.point(t,n)}function g(){h.point=p,c.lineStart()}function y(){h.point=d,c.lineEnd()}function v(t,n){u.push([t,n]),s.point(t,n)}function _(){s.lineStart(),u=[]}function b(){v(u[0][0],u[0][1]),s.lineEnd();var t,n,e,r,c=s.clean(),h=f.result(),d=h.length;if(u.pop(),o.push(u),u=null,d)if(1&c){if((n=(e=h[0]).length-1)>0){for(l||(i.polygonStart(),l=!0),i.lineStart(),t=0;t<n;++t)i.point((r=e[t])[0],r[1]);i.lineEnd()}}else d>1&&2&c&&h.push(h.pop().concat(h.shift())),a.push(h.filter(js))}return h}}function js(t){return t.length>1}function Hs(t,n){return((t=t.x)[0]<0?t[1]-qc-Dc:qc-t[1])-((n=n.x)[0]<0?n[1]-qc-Dc:qc-n[1])}Es.invert=Es;var Xs=Ls((function(){return!0}),(function(t){var n,e=NaN,r=NaN,i=NaN;return{lineStart:function(){t.lineStart(),n=1},point:function(o,a){var u=o>0?Fc:-Fc,c=Yc(o-e);Yc(c-Fc)<Dc?(t.point(e,r=(r+a)/2>0?qc:-qc),t.point(i,r),t.lineEnd(),t.lineStart(),t.point(u,r),t.point(o,r),n=0):i!==u&&c>=Fc&&(Yc(e-i)<Dc&&(e-=i*Dc),Yc(o-u)<Dc&&(o-=u*Dc),r=function(t,n,e,r){var i,o,a=Zc(t-e);return Yc(a)>Dc?Lc((Zc(n)*(o=Hc(r))*Zc(e)-Zc(r)*(i=Hc(n))*Zc(t))/(i*o*a)):(n+r)/2}(e,r,o,a),t.point(i,r),t.lineEnd(),t.lineStart(),t.point(u,r),n=0),t.point(e=o,r=a),i=u},lineEnd:function(){t.lineEnd(),e=r=NaN},clean:function(){return 2-n}}}),(function(t,n,e,r){var i;if(null==t)i=e*qc,r.point(-Fc,i),r.point(0,i),r.point(Fc,i),r.point(Fc,0),r.point(Fc,-i),r.point(0,-i),r.point(-Fc,-i),r.point(-Fc,0),r.point(-Fc,i);else if(Yc(t[0]-n[0])>Dc){var o=t[0]<n[0]?Fc:-Fc;i=e*o/2,r.point(-o,i),r.point(0,i),r.point(o,i)}else r.point(n[0],n[1])}),[-Fc,-qc]);function Gs(t){var n=Hc(t),e=6*Bc,r=n>0,i=Yc(n)>Dc;function o(t,e){return Hc(t)*Hc(e)>n}function a(t,e,r){var i=[1,0,0],o=Of(Ff(t),Ff(e)),a=qf(o,o),u=o[0],c=a-u*u;if(!c)return!r&&t;var f=n*a/c,s=-n*u/c,l=Of(i,o),h=If(i,f);Uf(h,If(o,s));var d=l,p=qf(h,d),g=qf(d,d),y=p*p-g*(qf(h,h)-1);if(!(y<0)){var v=Qc(y),_=If(d,(-p-v)/g);if(Uf(_,h),_=Rf(_),!r)return _;var b,m=t[0],x=e[0],w=t[1],M=e[1];x<m&&(b=m,m=x,x=b);var A=x-m,T=Yc(A-Fc)<Dc;if(!T&&M<w&&(b=w,w=M,M=b),T||A<Dc?T?w+M>0^_[1]<(Yc(_[0]-m)<Dc?w:M):w<=_[1]&&_[1]<=M:A>Fc^(m<=_[0]&&_[0]<=x)){var S=If(d,(-p+v)/g);return Uf(S,h),[_,Rf(S)]}}}function u(n,e){var i=r?t:Fc-t,o=0;return n<-i?o|=1:n>i&&(o|=2),e<-i?o|=4:e>i&&(o|=8),o}return Ls(o,(function(t){var n,e,c,f,s;return{lineStart:function(){f=c=!1,s=1},point:function(l,h){var d,p=[l,h],g=o(l,h),y=r?g?0:u(l,h):g?u(l+(l<0?Fc:-Fc),h):0;if(!n&&(f=c=g)&&t.lineStart(),g!==c&&(!(d=a(n,p))||qs(n,d)||qs(p,d))&&(p[2]=1),g!==c)s=0,g?(t.lineStart(),d=a(p,n),t.point(d[0],d[1])):(d=a(n,p),t.point(d[0],d[1],2),t.lineEnd()),n=d;else if(i&&n&&r^g){var v;y&e||!(v=a(p,n,!0))||(s=0,r?(t.lineStart(),t.point(v[0][0],v[0][1]),t.point(v[1][0],v[1][1]),t.lineEnd()):(t.point(v[1][0],v[1][1]),t.lineEnd(),t.lineStart(),t.point(v[0][0],v[0][1],3)))}!g||n&&qs(n,p)||t.point(p[0],p[1]),n=p,c=g,e=y},lineEnd:function(){c&&t.lineEnd(),n=null},clean:function(){return s|(f&&c)<<1}}}),(function(n,r,i,o){Ds(o,t,e,i,n,r)}),r?[0,-t]:[-Fc,t-Fc])}var Vs,$s,Ws,Zs,Ks=1e9,Qs=-Ks;function Js(t,n,e,r){function i(i,o){return t<=i&&i<=e&&n<=o&&o<=r}function o(i,o,u,f){var s=0,l=0;if(null==i||(s=a(i,u))!==(l=a(o,u))||c(i,o)<0^u>0)do{f.point(0===s||3===s?t:e,s>1?r:n)}while((s=(s+u+4)%4)!==l);else f.point(o[0],o[1])}function a(r,i){return Yc(r[0]-t)<Dc?i>0?0:3:Yc(r[0]-e)<Dc?i>0?2:1:Yc(r[1]-n)<Dc?i>0?1:0:i>0?3:2}function u(t,n){return c(t.x,n.x)}function c(t,n){var e=a(t,1),r=a(n,1);return e!==r?e-r:0===e?n[1]-t[1]:1===e?t[0]-n[0]:2===e?t[1]-n[1]:n[0]-t[0]}return function(a){var c,f,s,l,h,d,p,g,y,v,_,b=a,m=Fs(),x={point:w,lineStart:function(){x.point=M,f&&f.push(s=[]);v=!0,y=!1,p=g=NaN},lineEnd:function(){c&&(M(l,h),d&&y&&m.rejoin(),c.push(m.result()));x.point=w,y&&b.lineEnd()},polygonStart:function(){b=m,c=[],f=[],_=!0},polygonEnd:function(){var n=function(){for(var n=0,e=0,i=f.length;e<i;++e)for(var o,a,u=f[e],c=1,s=u.length,l=u[0],h=l[0],d=l[1];c<s;++c)o=h,a=d,h=(l=u[c])[0],d=l[1],a<=r?d>r&&(h-o)*(r-a)>(d-a)*(t-o)&&++n:d<=r&&(h-o)*(r-a)<(d-a)*(t-o)&&--n;return n}(),e=_&&n,i=(c=K(c)).length;(e||i)&&(a.polygonStart(),e&&(a.lineStart(),o(null,null,1,a),a.lineEnd()),i&&Us(c,u,n,o,a),a.polygonEnd());b=a,c=f=s=null}};function w(t,n){i(t,n)&&b.point(t,n)}function M(o,a){var u=i(o,a);if(f&&s.push([o,a]),v)l=o,h=a,d=u,v=!1,u&&(b.lineStart(),b.point(o,a));else if(u&&y)b.point(o,a);else{var c=[p=Math.max(Qs,Math.min(Ks,p)),g=Math.max(Qs,Math.min(Ks,g))],m=[o=Math.max(Qs,Math.min(Ks,o)),a=Math.max(Qs,Math.min(Ks,a))];!function(t,n,e,r,i,o){var a,u=t[0],c=t[1],f=0,s=1,l=n[0]-u,h=n[1]-c;if(a=e-u,l||!(a>0)){if(a/=l,l<0){if(a<f)return;a<s&&(s=a)}else if(l>0){if(a>s)return;a>f&&(f=a)}if(a=i-u,l||!(a<0)){if(a/=l,l<0){if(a>s)return;a>f&&(f=a)}else if(l>0){if(a<f)return;a<s&&(s=a)}if(a=r-c,h||!(a>0)){if(a/=h,h<0){if(a<f)return;a<s&&(s=a)}else if(h>0){if(a>s)return;a>f&&(f=a)}if(a=o-c,h||!(a<0)){if(a/=h,h<0){if(a>s)return;a>f&&(f=a)}else if(h>0){if(a<f)return;a<s&&(s=a)}return f>0&&(t[0]=u+f*l,t[1]=c+f*h),s<1&&(n[0]=u+s*l,n[1]=c+s*h),!0}}}}}(c,m,t,n,e,r)?u&&(b.lineStart(),b.point(o,a),_=!1):(y||(b.lineStart(),b.point(c[0],c[1])),b.point(m[0],m[1]),u||b.lineEnd(),_=!1)}p=o,g=a,y=u}return x}}var tl={sphere:rf,point:rf,lineStart:function(){tl.point=el,tl.lineEnd=nl},lineEnd:rf,polygonStart:rf,polygonEnd:rf};function nl(){tl.point=tl.lineEnd=rf}function el(t,n){$s=t*=Bc,Ws=Zc(n*=Bc),Zs=Hc(n),tl.point=rl}function rl(t,n){t*=Bc;var e=Zc(n*=Bc),r=Hc(n),i=Yc(t-$s),o=Hc(i),a=r*Zc(i),u=Zs*e-Ws*r*o,c=Ws*e+Zs*r*o;Vs.add(jc(Qc(a*a+u*u),c)),$s=t,Ws=e,Zs=r}function il(t){return Vs=new y,sf(t,tl),+Vs}var ol=[null,null],al={type:"LineString",coordinates:ol};function ul(t,n){return ol[0]=t,ol[1]=n,il(al)}var cl={Feature:function(t,n){return sl(t.geometry,n)},FeatureCollection:function(t,n){for(var e=t.features,r=-1,i=e.length;++r<i;)if(sl(e[r].geometry,n))return!0;return!1}},fl={Sphere:function(){return!0},Point:function(t,n){return ll(t.coordinates,n)},MultiPoint:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)if(ll(e[r],n))return!0;return!1},LineString:function(t,n){return hl(t.coordinates,n)},MultiLineString:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)if(hl(e[r],n))return!0;return!1},Polygon:function(t,n){return dl(t.coordinates,n)},MultiPolygon:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)if(dl(e[r],n))return!0;return!1},GeometryCollection:function(t,n){for(var e=t.geometries,r=-1,i=e.length;++r<i;)if(sl(e[r],n))return!0;return!1}};function sl(t,n){return!(!t||!fl.hasOwnProperty(t.type))&&fl[t.type](t,n)}function ll(t,n){return 0===ul(t,n)}function hl(t,n){for(var e,r,i,o=0,a=t.length;o<a;o++){if(0===(r=ul(t[o],n)))return!0;if(o>0&&(i=ul(t[o],t[o-1]))>0&&e<=i&&r<=i&&(e+r-i)*(1-Math.pow((e-r)/i,2))<Rc*i)return!0;e=r}return!1}function dl(t,n){return!!Ys(t.map(pl),gl(n))}function pl(t){return(t=t.map(gl)).pop(),t}function gl(t){return[t[0]*Bc,t[1]*Bc]}function yl(t,n,e){var r=tt(t,n-Dc,e).concat(n);return function(t){return r.map((function(n){return[t,n]}))}}function vl(t,n,e){var r=tt(t,n-Dc,e).concat(n);return function(t){return r.map((function(n){return[n,t]}))}}function _l(){var t,n,e,r,i,o,a,u,c,f,s,l,h=10,d=h,p=90,g=360,y=2.5;function v(){return{type:"MultiLineString",coordinates:_()}}function _(){return tt(Xc(r/p)*p,e,p).map(s).concat(tt(Xc(u/g)*g,a,g).map(l)).concat(tt(Xc(n/h)*h,t,h).filter((function(t){return Yc(t%p)>Dc})).map(c)).concat(tt(Xc(o/d)*d,i,d).filter((function(t){return Yc(t%g)>Dc})).map(f))}return v.lines=function(){return _().map((function(t){return{type:"LineString",coordinates:t}}))},v.outline=function(){return{type:"Polygon",coordinates:[s(r).concat(l(a).slice(1),s(e).reverse().slice(1),l(u).reverse().slice(1))]}},v.extent=function(t){return arguments.length?v.extentMajor(t).extentMinor(t):v.extentMinor()},v.extentMajor=function(t){return arguments.length?(r=+t[0][0],e=+t[1][0],u=+t[0][1],a=+t[1][1],r>e&&(t=r,r=e,e=t),u>a&&(t=u,u=a,a=t),v.precision(y)):[[r,u],[e,a]]},v.extentMinor=function(e){return arguments.length?(n=+e[0][0],t=+e[1][0],o=+e[0][1],i=+e[1][1],n>t&&(e=n,n=t,t=e),o>i&&(e=o,o=i,i=e),v.precision(y)):[[n,o],[t,i]]},v.step=function(t){return arguments.length?v.stepMajor(t).stepMinor(t):v.stepMinor()},v.stepMajor=function(t){return arguments.length?(p=+t[0],g=+t[1],v):[p,g]},v.stepMinor=function(t){return arguments.length?(h=+t[0],d=+t[1],v):[h,d]},v.precision=function(h){return arguments.length?(y=+h,c=yl(o,i,90),f=vl(n,t,y),s=yl(u,a,90),l=vl(r,e,y),v):y},v.extentMajor([[-180,-89.999999],[180,89.999999]]).extentMinor([[-180,-80.000001],[180,80.000001]])}var bl,ml,xl,wl,Ml=t=>t,Al=new y,Tl=new y,Sl={point:rf,lineStart:rf,lineEnd:rf,polygonStart:function(){Sl.lineStart=El,Sl.lineEnd=Cl},polygonEnd:function(){Sl.lineStart=Sl.lineEnd=Sl.point=rf,Al.add(Yc(Tl)),Tl=new y},result:function(){var t=Al/2;return Al=new y,t}};function El(){Sl.point=kl}function kl(t,n){Sl.point=Nl,bl=xl=t,ml=wl=n}function Nl(t,n){Tl.add(wl*t-xl*n),xl=t,wl=n}function Cl(){Nl(bl,ml)}var Pl=Sl,zl=1/0,Dl=zl,Rl=-zl,Fl=Rl,ql={point:function(t,n){t<zl&&(zl=t);t>Rl&&(Rl=t);n<Dl&&(Dl=n);n>Fl&&(Fl=n)},lineStart:rf,lineEnd:rf,polygonStart:rf,polygonEnd:rf,result:function(){var t=[[zl,Dl],[Rl,Fl]];return Rl=Fl=-(Dl=zl=1/0),t}};var Ol,Ul,Il,Bl,Yl=ql,Ll=0,jl=0,Hl=0,Xl=0,Gl=0,Vl=0,$l=0,Wl=0,Zl=0,Kl={point:Ql,lineStart:Jl,lineEnd:eh,polygonStart:function(){Kl.lineStart=rh,Kl.lineEnd=ih},polygonEnd:function(){Kl.point=Ql,Kl.lineStart=Jl,Kl.lineEnd=eh},result:function(){var t=Zl?[$l/Zl,Wl/Zl]:Vl?[Xl/Vl,Gl/Vl]:Hl?[Ll/Hl,jl/Hl]:[NaN,NaN];return Ll=jl=Hl=Xl=Gl=Vl=$l=Wl=Zl=0,t}};function Ql(t,n){Ll+=t,jl+=n,++Hl}function Jl(){Kl.point=th}function th(t,n){Kl.point=nh,Ql(Il=t,Bl=n)}function nh(t,n){var e=t-Il,r=n-Bl,i=Qc(e*e+r*r);Xl+=i*(Il+t)/2,Gl+=i*(Bl+n)/2,Vl+=i,Ql(Il=t,Bl=n)}function eh(){Kl.point=Ql}function rh(){Kl.point=oh}function ih(){ah(Ol,Ul)}function oh(t,n){Kl.point=ah,Ql(Ol=Il=t,Ul=Bl=n)}function ah(t,n){var e=t-Il,r=n-Bl,i=Qc(e*e+r*r);Xl+=i*(Il+t)/2,Gl+=i*(Bl+n)/2,Vl+=i,$l+=(i=Bl*t-Il*n)*(Il+t),Wl+=i*(Bl+n),Zl+=3*i,Ql(Il=t,Bl=n)}var uh=Kl;function ch(t){this._context=t}ch.prototype={_radius:4.5,pointRadius:function(t){return this._radius=t,this},polygonStart:function(){this._line=0},polygonEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){0===this._line&&this._context.closePath(),this._point=NaN},point:function(t,n){switch(this._point){case 0:this._context.moveTo(t,n),this._point=1;break;case 1:this._context.lineTo(t,n);break;default:this._context.moveTo(t+this._radius,n),this._context.arc(t,n,this._radius,0,Uc)}},result:rf};var fh,sh,lh,hh,dh,ph=new y,gh={point:rf,lineStart:function(){gh.point=yh},lineEnd:function(){fh&&vh(sh,lh),gh.point=rf},polygonStart:function(){fh=!0},polygonEnd:function(){fh=null},result:function(){var t=+ph;return ph=new y,t}};function yh(t,n){gh.point=vh,sh=hh=t,lh=dh=n}function vh(t,n){hh-=t,dh-=n,ph.add(Qc(hh*hh+dh*dh)),hh=t,dh=n}var _h=gh;function bh(){this._string=[]}function mh(t){return"m0,"+t+"a"+t+","+t+" 0 1,1 0,"+-2*t+"a"+t+","+t+" 0 1,1 0,"+2*t+"z"}function xh(t){return function(n){var e=new wh;for(var r in t)e[r]=t[r];return e.stream=n,e}}function wh(){}function Mh(t,n,e){var r=t.clipExtent&&t.clipExtent();return t.scale(150).translate([0,0]),null!=r&&t.clipExtent(null),sf(e,t.stream(Yl)),n(Yl.result()),null!=r&&t.clipExtent(r),t}function Ah(t,n,e){return Mh(t,(function(e){var r=n[1][0]-n[0][0],i=n[1][1]-n[0][1],o=Math.min(r/(e[1][0]-e[0][0]),i/(e[1][1]-e[0][1])),a=+n[0][0]+(r-o*(e[1][0]+e[0][0]))/2,u=+n[0][1]+(i-o*(e[1][1]+e[0][1]))/2;t.scale(150*o).translate([a,u])}),e)}function Th(t,n,e){return Ah(t,[[0,0],n],e)}function Sh(t,n,e){return Mh(t,(function(e){var r=+n,i=r/(e[1][0]-e[0][0]),o=(r-i*(e[1][0]+e[0][0]))/2,a=-i*e[0][1];t.scale(150*i).translate([o,a])}),e)}function Eh(t,n,e){return Mh(t,(function(e){var r=+n,i=r/(e[1][1]-e[0][1]),o=-i*e[0][0],a=(r-i*(e[1][1]+e[0][1]))/2;t.scale(150*i).translate([o,a])}),e)}bh.prototype={_radius:4.5,_circle:mh(4.5),pointRadius:function(t){return(t=+t)!==this._radius&&(this._radius=t,this._circle=null),this},polygonStart:function(){this._line=0},polygonEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){0===this._line&&this._string.push("Z"),this._point=NaN},point:function(t,n){switch(this._point){case 0:this._string.push("M",t,",",n),this._point=1;break;case 1:this._string.push("L",t,",",n);break;default:null==this._circle&&(this._circle=mh(this._radius)),this._string.push("M",t,",",n,this._circle)}},result:function(){if(this._string.length){var t=this._string.join("");return this._string=[],t}return null}},wh.prototype={constructor:wh,point:function(t,n){this.stream.point(t,n)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}};var kh=Hc(30*Bc);function Nh(t,n){return+n?function(t,n){function e(r,i,o,a,u,c,f,s,l,h,d,p,g,y){var v=f-r,_=s-i,b=v*v+_*_;if(b>4*n&&g--){var m=a+h,x=u+d,w=c+p,M=Qc(m*m+x*x+w*w),A=nf(w/=M),T=Yc(Yc(w)-1)<Dc||Yc(o-l)<Dc?(o+l)/2:jc(x,m),S=t(T,A),E=S[0],k=S[1],N=E-r,C=k-i,P=_*N-v*C;(P*P/b>n||Yc((v*N+_*C)/b-.5)>.3||a*h+u*d+c*p<kh)&&(e(r,i,o,a,u,c,E,k,T,m/=M,x/=M,w,g,y),y.point(E,k),e(E,k,T,m,x,w,f,s,l,h,d,p,g,y))}}return function(n){var r,i,o,a,u,c,f,s,l,h,d,p,g={point:y,lineStart:v,lineEnd:b,polygonStart:function(){n.polygonStart(),g.lineStart=m},polygonEnd:function(){n.polygonEnd(),g.lineStart=v}};function y(e,r){e=t(e,r),n.point(e[0],e[1])}function v(){s=NaN,g.point=_,n.lineStart()}function _(r,i){var o=Ff([r,i]),a=t(r,i);e(s,l,f,h,d,p,s=a[0],l=a[1],f=r,h=o[0],d=o[1],p=o[2],16,n),n.point(s,l)}function b(){g.point=y,n.lineEnd()}function m(){v(),g.point=x,g.lineEnd=w}function x(t,n){_(r=t,n),i=s,o=l,a=h,u=d,c=p,g.point=_}function w(){e(s,l,f,h,d,p,i,o,r,a,u,c,16,n),g.lineEnd=b,b()}return g}}(t,n):function(t){return xh({point:function(n,e){n=t(n,e),this.stream.point(n[0],n[1])}})}(t)}var Ch=xh({point:function(t,n){this.stream.point(t*Bc,n*Bc)}});function Ph(t,n,e,r,i,o){if(!o)return function(t,n,e,r,i){function o(o,a){return[n+t*(o*=r),e-t*(a*=i)]}return o.invert=function(o,a){return[(o-n)/t*r,(e-a)/t*i]},o}(t,n,e,r,i);var a=Hc(o),u=Zc(o),c=a*t,f=u*t,s=a/t,l=u/t,h=(u*e-a*n)/t,d=(u*n+a*e)/t;function p(t,o){return[c*(t*=r)-f*(o*=i)+n,e-f*t-c*o]}return p.invert=function(t,n){return[r*(s*t-l*n+h),i*(d-l*t-s*n)]},p}function zh(t){return Dh((function(){return t}))()}function Dh(t){var n,e,r,i,o,a,u,c,f,s,l=150,h=480,d=250,p=0,g=0,y=0,v=0,_=0,b=0,m=1,x=1,w=null,M=Xs,A=null,T=Ml,S=.5;function E(t){return c(t[0]*Bc,t[1]*Bc)}function k(t){return(t=c.invert(t[0],t[1]))&&[t[0]*Ic,t[1]*Ic]}function N(){var t=Ph(l,0,0,m,x,b).apply(null,n(p,g)),r=Ph(l,h-t[0],d-t[1],m,x,b);return e=ks(y,v,_),u=Ss(n,r),c=Ss(e,u),a=Nh(u,S),C()}function C(){return f=s=null,E}return E.stream=function(t){return f&&s===t?f:f=Ch(function(t){return xh({point:function(n,e){var r=t(n,e);return this.stream.point(r[0],r[1])}})}(e)(M(a(T(s=t)))))},E.preclip=function(t){return arguments.length?(M=t,w=void 0,C()):M},E.postclip=function(t){return arguments.length?(T=t,A=r=i=o=null,C()):T},E.clipAngle=function(t){return arguments.length?(M=+t?Gs(w=t*Bc):(w=null,Xs),C()):w*Ic},E.clipExtent=function(t){return arguments.length?(T=null==t?(A=r=i=o=null,Ml):Js(A=+t[0][0],r=+t[0][1],i=+t[1][0],o=+t[1][1]),C()):null==A?null:[[A,r],[i,o]]},E.scale=function(t){return arguments.length?(l=+t,N()):l},E.translate=function(t){return arguments.length?(h=+t[0],d=+t[1],N()):[h,d]},E.center=function(t){return arguments.length?(p=t[0]%360*Bc,g=t[1]%360*Bc,N()):[p*Ic,g*Ic]},E.rotate=function(t){return arguments.length?(y=t[0]%360*Bc,v=t[1]%360*Bc,_=t.length>2?t[2]%360*Bc:0,N()):[y*Ic,v*Ic,_*Ic]},E.angle=function(t){return arguments.length?(b=t%360*Bc,N()):b*Ic},E.reflectX=function(t){return arguments.length?(m=t?-1:1,N()):m<0},E.reflectY=function(t){return arguments.length?(x=t?-1:1,N()):x<0},E.precision=function(t){return arguments.length?(a=Nh(u,S=t*t),C()):Qc(S)},E.fitExtent=function(t,n){return Ah(E,t,n)},E.fitSize=function(t,n){return Th(E,t,n)},E.fitWidth=function(t,n){return Sh(E,t,n)},E.fitHeight=function(t,n){return Eh(E,t,n)},function(){return n=t.apply(this,arguments),E.invert=n.invert&&k,N()}}function Rh(t){var n=0,e=Fc/3,r=Dh(t),i=r(n,e);return i.parallels=function(t){return arguments.length?r(n=t[0]*Bc,e=t[1]*Bc):[n*Ic,e*Ic]},i}function Fh(t,n){var e=Zc(t),r=(e+Zc(n))/2;if(Yc(r)<Dc)return function(t){var n=Hc(t);function e(t,e){return[t*n,Zc(e)/n]}return e.invert=function(t,e){return[t/n,nf(e*n)]},e}(t);var i=1+e*(2*r-e),o=Qc(i)/r;function a(t,n){var e=Qc(i-2*r*Zc(n))/r;return[e*Zc(t*=r),o-e*Hc(t)]}return a.invert=function(t,n){var e=o-n,a=jc(t,Yc(e))*Kc(e);return e*r<0&&(a-=Fc*Kc(t)*Kc(e)),[a/r,nf((i-(t*t+e*e)*r*r)/(2*r))]},a}function qh(){return Rh(Fh).scale(155.424).center([0,33.6442])}function Oh(){return qh().parallels([29.5,45.5]).scale(1070).translate([480,250]).rotate([96,0]).center([-.6,38.7])}function Uh(t){return function(n,e){var r=Hc(n),i=Hc(e),o=t(r*i);return o===1/0?[2,0]:[o*i*Zc(n),o*Zc(e)]}}function Ih(t){return function(n,e){var r=Qc(n*n+e*e),i=t(r),o=Zc(i),a=Hc(i);return[jc(n*o,r*a),nf(r&&e*o/r)]}}var Bh=Uh((function(t){return Qc(2/(1+t))}));Bh.invert=Ih((function(t){return 2*nf(t/2)}));var Yh=Uh((function(t){return(t=tf(t))&&t/Zc(t)}));function Lh(t,n){return[t,$c(Jc((qc+n)/2))]}function jh(t){var n,e,r,i=zh(t),o=i.center,a=i.scale,u=i.translate,c=i.clipExtent,f=null;function s(){var o=Fc*a(),u=i(zs(i.rotate()).invert([0,0]));return c(null==f?[[u[0]-o,u[1]-o],[u[0]+o,u[1]+o]]:t===Lh?[[Math.max(u[0]-o,f),n],[Math.min(u[0]+o,e),r]]:[[f,Math.max(u[1]-o,n)],[e,Math.min(u[1]+o,r)]])}return i.scale=function(t){return arguments.length?(a(t),s()):a()},i.translate=function(t){return arguments.length?(u(t),s()):u()},i.center=function(t){return arguments.length?(o(t),s()):o()},i.clipExtent=function(t){return arguments.length?(null==t?f=n=e=r=null:(f=+t[0][0],n=+t[0][1],e=+t[1][0],r=+t[1][1]),s()):null==f?null:[[f,n],[e,r]]},s()}function Hh(t){return Jc((qc+t)/2)}function Xh(t,n){var e=Hc(t),r=t===n?Zc(t):$c(e/Hc(n))/$c(Hh(n)/Hh(t)),i=e*Wc(Hh(t),r)/r;if(!r)return Lh;function o(t,n){i>0?n<-qc+Dc&&(n=-qc+Dc):n>qc-Dc&&(n=qc-Dc);var e=i/Wc(Hh(n),r);return[e*Zc(r*t),i-e*Hc(r*t)]}return o.invert=function(t,n){var e=i-n,o=Kc(r)*Qc(t*t+e*e),a=jc(t,Yc(e))*Kc(e);return e*r<0&&(a-=Fc*Kc(t)*Kc(e)),[a/r,2*Lc(Wc(i/o,1/r))-qc]},o}function Gh(t,n){return[t,n]}function Vh(t,n){var e=Hc(t),r=t===n?Zc(t):(e-Hc(n))/(n-t),i=e/r+t;if(Yc(r)<Dc)return Gh;function o(t,n){var e=i-n,o=r*t;return[e*Zc(o),i-e*Hc(o)]}return o.invert=function(t,n){var e=i-n,o=jc(t,Yc(e))*Kc(e);return e*r<0&&(o-=Fc*Kc(t)*Kc(e)),[o/r,i-Kc(r)*Qc(t*t+e*e)]},o}Yh.invert=Ih((function(t){return t})),Lh.invert=function(t,n){return[t,2*Lc(Gc(n))-qc]},Gh.invert=Gh;var $h=1.340264,Wh=-.081106,Zh=893e-6,Kh=.003796,Qh=Qc(3)/2;function Jh(t,n){var e=nf(Qh*Zc(n)),r=e*e,i=r*r*r;return[t*Hc(e)/(Qh*($h+3*Wh*r+i*(7*Zh+9*Kh*r))),e*($h+Wh*r+i*(Zh+Kh*r))]}function td(t,n){var e=Hc(n),r=Hc(t)*e;return[e*Zc(t)/r,Zc(n)/r]}function nd(t,n){var e=n*n,r=e*e;return[t*(.8707-.131979*e+r*(r*(.003971*e-.001529*r)-.013791)),n*(1.007226+e*(.015085+r*(.028874*e-.044475-.005916*r)))]}function ed(t,n){return[Hc(n)*Zc(t),Zc(n)]}function rd(t,n){var e=Hc(n),r=1+Hc(t)*e;return[e*Zc(t)/r,Zc(n)/r]}function id(t,n){return[$c(Jc((qc+n)/2)),-t]}function od(t,n){return t.parent===n.parent?1:2}function ad(t,n){return t+n.x}function ud(t,n){return Math.max(t,n.y)}function cd(t){var n=0,e=t.children,r=e&&e.length;if(r)for(;--r>=0;)n+=e[r].value;else n=1;t.value=n}function fd(t,n){t instanceof Map?(t=[void 0,t],void 0===n&&(n=ld)):void 0===n&&(n=sd);for(var e,r,i,o,a,u=new pd(t),c=[u];e=c.pop();)if((i=n(e.data))&&(a=(i=Array.from(i)).length))for(e.children=i,o=a-1;o>=0;--o)c.push(r=i[o]=new pd(i[o])),r.parent=e,r.depth=e.depth+1;return u.eachBefore(dd)}function sd(t){return t.children}function ld(t){return Array.isArray(t)?t[1]:null}function hd(t){void 0!==t.data.value&&(t.value=t.data.value),t.data=t.data.data}function dd(t){var n=0;do{t.height=n}while((t=t.parent)&&t.height<++n)}function pd(t){this.data=t,this.depth=this.height=0,this.parent=null}function gd(t){for(var n,e,r=0,i=(t=function(t){for(var n,e,r=t.length;r;)e=Math.random()*r--|0,n=t[r],t[r]=t[e],t[e]=n;return t}(Array.from(t))).length,o=[];r<i;)n=t[r],e&&_d(e,n)?++r:(e=md(o=yd(o,n)),r=0);return e}function yd(t,n){var e,r;if(bd(n,t))return[n];for(e=0;e<t.length;++e)if(vd(n,t[e])&&bd(xd(t[e],n),t))return[t[e],n];for(e=0;e<t.length-1;++e)for(r=e+1;r<t.length;++r)if(vd(xd(t[e],t[r]),n)&&vd(xd(t[e],n),t[r])&&vd(xd(t[r],n),t[e])&&bd(wd(t[e],t[r],n),t))return[t[e],t[r],n];throw new Error}function vd(t,n){var e=t.r-n.r,r=n.x-t.x,i=n.y-t.y;return e<0||e*e<r*r+i*i}function _d(t,n){var e=t.r-n.r+1e-9*Math.max(t.r,n.r,1),r=n.x-t.x,i=n.y-t.y;return e>0&&e*e>r*r+i*i}function bd(t,n){for(var e=0;e<n.length;++e)if(!_d(t,n[e]))return!1;return!0}function md(t){switch(t.length){case 1:return function(t){return{x:t.x,y:t.y,r:t.r}}(t[0]);case 2:return xd(t[0],t[1]);case 3:return wd(t[0],t[1],t[2])}}function xd(t,n){var e=t.x,r=t.y,i=t.r,o=n.x,a=n.y,u=n.r,c=o-e,f=a-r,s=u-i,l=Math.sqrt(c*c+f*f);return{x:(e+o+c/l*s)/2,y:(r+a+f/l*s)/2,r:(l+i+u)/2}}function wd(t,n,e){var r=t.x,i=t.y,o=t.r,a=n.x,u=n.y,c=n.r,f=e.x,s=e.y,l=e.r,h=r-a,d=r-f,p=i-u,g=i-s,y=c-o,v=l-o,_=r*r+i*i-o*o,b=_-a*a-u*u+c*c,m=_-f*f-s*s+l*l,x=d*p-h*g,w=(p*m-g*b)/(2*x)-r,M=(g*y-p*v)/x,A=(d*b-h*m)/(2*x)-i,T=(h*v-d*y)/x,S=M*M+T*T-1,E=2*(o+w*M+A*T),k=w*w+A*A-o*o,N=-(S?(E+Math.sqrt(E*E-4*S*k))/(2*S):k/E);return{x:r+w+M*N,y:i+A+T*N,r:N}}function Md(t,n,e){var r,i,o,a,u=t.x-n.x,c=t.y-n.y,f=u*u+c*c;f?(i=n.r+e.r,i*=i,a=t.r+e.r,i>(a*=a)?(r=(f+a-i)/(2*f),o=Math.sqrt(Math.max(0,a/f-r*r)),e.x=t.x-r*u-o*c,e.y=t.y-r*c+o*u):(r=(f+i-a)/(2*f),o=Math.sqrt(Math.max(0,i/f-r*r)),e.x=n.x+r*u-o*c,e.y=n.y+r*c+o*u)):(e.x=n.x+e.r,e.y=n.y)}function Ad(t,n){var e=t.r+n.r-1e-6,r=n.x-t.x,i=n.y-t.y;return e>0&&e*e>r*r+i*i}function Td(t){var n=t._,e=t.next._,r=n.r+e.r,i=(n.x*e.r+e.x*n.r)/r,o=(n.y*e.r+e.y*n.r)/r;return i*i+o*o}function Sd(t){this._=t,this.next=null,this.previous=null}function Ed(t){if(!(i=(t=function(t){return"object"==typeof t&&"length"in t?t:Array.from(t)}(t)).length))return 0;var n,e,r,i,o,a,u,c,f,s,l;if((n=t[0]).x=0,n.y=0,!(i>1))return n.r;if(e=t[1],n.x=-e.r,e.x=n.r,e.y=0,!(i>2))return n.r+e.r;Md(e,n,r=t[2]),n=new Sd(n),e=new Sd(e),r=new Sd(r),n.next=r.previous=e,e.next=n.previous=r,r.next=e.previous=n;t:for(u=3;u<i;++u){Md(n._,e._,r=t[u]),r=new Sd(r),c=e.next,f=n.previous,s=e._.r,l=n._.r;do{if(s<=l){if(Ad(c._,r._)){e=c,n.next=e,e.previous=n,--u;continue t}s+=c._.r,c=c.next}else{if(Ad(f._,r._)){(n=f).next=e,e.previous=n,--u;continue t}l+=f._.r,f=f.previous}}while(c!==f.next);for(r.previous=n,r.next=e,n.next=e.previous=e=r,o=Td(n);(r=r.next)!==e;)(a=Td(r))<o&&(n=r,o=a);e=n.next}for(n=[e._],r=e;(r=r.next)!==e;)n.push(r._);for(r=gd(n),u=0;u<i;++u)(n=t[u]).x-=r.x,n.y-=r.y;return r.r}function kd(t){return null==t?null:Nd(t)}function Nd(t){if("function"!=typeof t)throw new Error;return t}function Cd(){return 0}function Pd(t){return function(){return t}}function zd(t){return Math.sqrt(t.value)}function Dd(t){return function(n){n.children||(n.r=Math.max(0,+t(n)||0))}}function Rd(t,n){return function(e){if(r=e.children){var r,i,o,a=r.length,u=t(e)*n||0;if(u)for(i=0;i<a;++i)r[i].r+=u;if(o=Ed(r),u)for(i=0;i<a;++i)r[i].r-=u;e.r=o+u}}}function Fd(t){return function(n){var e=n.parent;n.r*=t,e&&(n.x=e.x+t*n.x,n.y=e.y+t*n.y)}}function qd(t){t.x0=Math.round(t.x0),t.y0=Math.round(t.y0),t.x1=Math.round(t.x1),t.y1=Math.round(t.y1)}function Od(t,n,e,r,i){for(var o,a=t.children,u=-1,c=a.length,f=t.value&&(r-n)/t.value;++u<c;)(o=a[u]).y0=e,o.y1=i,o.x0=n,o.x1=n+=o.value*f}Jh.invert=function(t,n){for(var e,r=n,i=r*r,o=i*i*i,a=0;a<12&&(o=(i=(r-=e=(r*($h+Wh*i+o*(Zh+Kh*i))-n)/($h+3*Wh*i+o*(7*Zh+9*Kh*i)))*r)*i*i,!(Yc(e)<Rc));++a);return[Qh*t*($h+3*Wh*i+o*(7*Zh+9*Kh*i))/Hc(r),nf(Zc(r)/Qh)]},td.invert=Ih(Lc),nd.invert=function(t,n){var e,r=n,i=25;do{var o=r*r,a=o*o;r-=e=(r*(1.007226+o*(.015085+a*(.028874*o-.044475-.005916*a)))-n)/(1.007226+o*(.045255+a*(.259866*o-.311325-.005916*11*a)))}while(Yc(e)>Dc&&--i>0);return[t/(.8707+(o=r*r)*(o*(o*o*o*(.003971-.001529*o)-.013791)-.131979)),r]},ed.invert=Ih(nf),rd.invert=Ih((function(t){return 2*Lc(t)})),id.invert=function(t,n){return[-n,2*Lc(Gc(t))-qc]},pd.prototype=fd.prototype={constructor:pd,count:function(){return this.eachAfter(cd)},each:function(t,n){let e=-1;for(const r of this)t.call(n,r,++e,this);return this},eachAfter:function(t,n){for(var e,r,i,o=this,a=[o],u=[],c=-1;o=a.pop();)if(u.push(o),e=o.children)for(r=0,i=e.length;r<i;++r)a.push(e[r]);for(;o=u.pop();)t.call(n,o,++c,this);return this},eachBefore:function(t,n){for(var e,r,i=this,o=[i],a=-1;i=o.pop();)if(t.call(n,i,++a,this),e=i.children)for(r=e.length-1;r>=0;--r)o.push(e[r]);return this},find:function(t,n){let e=-1;for(const r of this)if(t.call(n,r,++e,this))return r},sum:function(t){return this.eachAfter((function(n){for(var e=+t(n.data)||0,r=n.children,i=r&&r.length;--i>=0;)e+=r[i].value;n.value=e}))},sort:function(t){return this.eachBefore((function(n){n.children&&n.children.sort(t)}))},path:function(t){for(var n=this,e=function(t,n){if(t===n)return t;var e=t.ancestors(),r=n.ancestors(),i=null;t=e.pop(),n=r.pop();for(;t===n;)i=t,t=e.pop(),n=r.pop();return i}(n,t),r=[n];n!==e;)n=n.parent,r.push(n);for(var i=r.length;t!==e;)r.splice(i,0,t),t=t.parent;return r},ancestors:function(){for(var t=this,n=[t];t=t.parent;)n.push(t);return n},descendants:function(){return Array.from(this)},leaves:function(){var t=[];return this.eachBefore((function(n){n.children||t.push(n)})),t},links:function(){var t=this,n=[];return t.each((function(e){e!==t&&n.push({source:e.parent,target:e})})),n},copy:function(){return fd(this).eachBefore(hd)},[Symbol.iterator]:function*(){var t,n,e,r,i=this,o=[i];do{for(t=o.reverse(),o=[];i=t.pop();)if(yield i,n=i.children)for(e=0,r=n.length;e<r;++e)o.push(n[e])}while(o.length)}};var Ud={depth:-1},Id={},Bd={};function Yd(t){return t.id}function Ld(t){return t.parentId}function jd(t){let n=t.length;if(n<2)return"";for(;--n>1&&!Hd(t,n););return t.slice(0,n)}function Hd(t,n){if("/"===t[n]){let e=0;for(;n>0&&"\\"===t[--n];)++e;if(0==(1&e))return!0}return!1}function Xd(t,n){return t.parent===n.parent?1:2}function Gd(t){var n=t.children;return n?n[0]:t.t}function Vd(t){var n=t.children;return n?n[n.length-1]:t.t}function $d(t,n,e){var r=e/(n.i-t.i);n.c-=r,n.s+=e,t.c+=r,n.z+=e,n.m+=e}function Wd(t,n,e){return t.a.parent===n.parent?t.a:e}function Zd(t,n){this._=t,this.parent=null,this.children=null,this.A=null,this.a=this,this.z=0,this.m=0,this.c=0,this.s=0,this.t=null,this.i=n}function Kd(t,n,e,r,i){for(var o,a=t.children,u=-1,c=a.length,f=t.value&&(i-e)/t.value;++u<c;)(o=a[u]).x0=n,o.x1=r,o.y0=e,o.y1=e+=o.value*f}Zd.prototype=Object.create(pd.prototype);var Qd=(1+Math.sqrt(5))/2;function Jd(t,n,e,r,i,o){for(var a,u,c,f,s,l,h,d,p,g,y,v=[],_=n.children,b=0,m=0,x=_.length,w=n.value;b<x;){c=i-e,f=o-r;do{s=_[m++].value}while(!s&&m<x);for(l=h=s,y=s*s*(g=Math.max(f/c,c/f)/(w*t)),p=Math.max(h/y,y/l);m<x;++m){if(s+=u=_[m].value,u<l&&(l=u),u>h&&(h=u),y=s*s*g,(d=Math.max(h/y,y/l))>p){s-=u;break}p=d}v.push(a={value:s,dice:c<f,children:_.slice(b,m)}),a.dice?Od(a,e,r,i,w?r+=f*s/w:o):Kd(a,e,r,w?e+=c*s/w:i,o),w-=s,b=m}return v}var tp=function t(n){function e(t,e,r,i,o){Jd(n,t,e,r,i,o)}return e.ratio=function(n){return t((n=+n)>1?n:1)},e}(Qd);var np=function t(n){function e(t,e,r,i,o){if((a=t._squarify)&&a.ratio===n)for(var a,u,c,f,s,l=-1,h=a.length,d=t.value;++l<h;){for(c=(u=a[l]).children,f=u.value=0,s=c.length;f<s;++f)u.value+=c[f].value;u.dice?Od(u,e,r,i,d?r+=(o-r)*u.value/d:o):Kd(u,e,r,d?e+=(i-e)*u.value/d:i,o),d-=u.value}else t._squarify=a=Jd(n,t,e,r,i,o),a.ratio=n}return e.ratio=function(n){return t((n=+n)>1?n:1)},e}(Qd);function ep(t,n,e){return(n[0]-t[0])*(e[1]-t[1])-(n[1]-t[1])*(e[0]-t[0])}function rp(t,n){return t[0]-n[0]||t[1]-n[1]}function ip(t){const n=t.length,e=[0,1];let r,i=2;for(r=2;r<n;++r){for(;i>1&&ep(t[e[i-2]],t[e[i-1]],t[r])<=0;)--i;e[i++]=r}return e.slice(0,i)}var op=Math.random,ap=function t(n){function e(t,e){return t=null==t?0:+t,e=null==e?1:+e,1===arguments.length?(e=t,t=0):e-=t,function(){return n()*e+t}}return e.source=t,e}(op),up=function t(n){function e(t,e){return arguments.length<2&&(e=t,t=0),t=Math.floor(t),e=Math.floor(e)-t,function(){return Math.floor(n()*e+t)}}return e.source=t,e}(op),cp=function t(n){function e(t,e){var r,i;return t=null==t?0:+t,e=null==e?1:+e,function(){var o;if(null!=r)o=r,r=null;else do{r=2*n()-1,o=2*n()-1,i=r*r+o*o}while(!i||i>1);return t+e*o*Math.sqrt(-2*Math.log(i)/i)}}return e.source=t,e}(op),fp=function t(n){var e=cp.source(n);function r(){var t=e.apply(this,arguments);return function(){return Math.exp(t())}}return r.source=t,r}(op),sp=function t(n){function e(t){return(t=+t)<=0?()=>0:function(){for(var e=0,r=t;r>1;--r)e+=n();return e+r*n()}}return e.source=t,e}(op),lp=function t(n){var e=sp.source(n);function r(t){if(0==(t=+t))return n;var r=e(t);return function(){return r()/t}}return r.source=t,r}(op),hp=function t(n){function e(t){return function(){return-Math.log1p(-n())/t}}return e.source=t,e}(op),dp=function t(n){function e(t){if((t=+t)<0)throw new RangeError("invalid alpha");return t=1/-t,function(){return Math.pow(1-n(),t)}}return e.source=t,e}(op),pp=function t(n){function e(t){if((t=+t)<0||t>1)throw new RangeError("invalid p");return function(){return Math.floor(n()+t)}}return e.source=t,e}(op),gp=function t(n){function e(t){if((t=+t)<0||t>1)throw new RangeError("invalid p");return 0===t?()=>1/0:1===t?()=>1:(t=Math.log1p(-t),function(){return 1+Math.floor(Math.log1p(-n())/t)})}return e.source=t,e}(op),yp=function t(n){var e=cp.source(n)();function r(t,r){if((t=+t)<0)throw new RangeError("invalid k");if(0===t)return()=>0;if(r=null==r?1:+r,1===t)return()=>-Math.log1p(-n())*r;var i=(t<1?t+1:t)-1/3,o=1/(3*Math.sqrt(i)),a=t<1?()=>Math.pow(n(),1/t):()=>1;return function(){do{do{var t=e(),u=1+o*t}while(u<=0);u*=u*u;var c=1-n()}while(c>=1-.0331*t*t*t*t&&Math.log(c)>=.5*t*t+i*(1-u+Math.log(u)));return i*u*a()*r}}return r.source=t,r}(op),vp=function t(n){var e=yp.source(n);function r(t,n){var r=e(t),i=e(n);return function(){var t=r();return 0===t?0:t/(t+i())}}return r.source=t,r}(op),_p=function t(n){var e=gp.source(n),r=vp.source(n);function i(t,n){return t=+t,(n=+n)>=1?()=>t:n<=0?()=>0:function(){for(var i=0,o=t,a=n;o*a>16&&o*(1-a)>16;){var u=Math.floor((o+1)*a),c=r(u,o-u+1)();c<=a?(i+=u,o-=u,a=(a-c)/(1-c)):(o=u-1,a/=c)}for(var f=a<.5,s=e(f?a:1-a),l=s(),h=0;l<=o;++h)l+=s();return i+(f?h:o-h)}}return i.source=t,i}(op),bp=function t(n){function e(t,e,r){var i;return 0==(t=+t)?i=t=>-Math.log(t):(t=1/t,i=n=>Math.pow(n,t)),e=null==e?0:+e,r=null==r?1:+r,function(){return e+r*i(-Math.log1p(-n()))}}return e.source=t,e}(op),mp=function t(n){function e(t,e){return t=null==t?0:+t,e=null==e?1:+e,function(){return t+e*Math.tan(Math.PI*n())}}return e.source=t,e}(op),xp=function t(n){function e(t,e){return t=null==t?0:+t,e=null==e?1:+e,function(){var r=n();return t+e*Math.log(r/(1-r))}}return e.source=t,e}(op),wp=function t(n){var e=yp.source(n),r=_p.source(n);function i(t){return function(){for(var i=0,o=t;o>16;){var a=Math.floor(.875*o),u=e(a)();if(u>o)return i+r(a-1,o/u)();i+=a,o-=u}for(var c=-Math.log1p(-n()),f=0;c<=o;++f)c-=Math.log1p(-n());return i+f}}return i.source=t,i}(op);const Mp=1/4294967296;function Ap(t,n){switch(arguments.length){case 0:break;case 1:this.range(t);break;default:this.range(n).domain(t)}return this}function Tp(t,n){switch(arguments.length){case 0:break;case 1:"function"==typeof t?this.interpolator(t):this.range(t);break;default:this.domain(t),"function"==typeof n?this.interpolator(n):this.range(n)}return this}const Sp=Symbol("implicit");function Ep(){var t=new InternMap,n=[],e=[],r=Sp;function i(i){let o=t.get(i);if(void 0===o){if(r!==Sp)return r;t.set(i,o=n.push(i)-1)}return e[o%e.length]}return i.domain=function(e){if(!arguments.length)return n.slice();n=[],t=new InternMap;for(const r of e)t.has(r)||t.set(r,n.push(r)-1);return i},i.range=function(t){return arguments.length?(e=Array.from(t),i):e.slice()},i.unknown=function(t){return arguments.length?(r=t,i):r},i.copy=function(){return Ep(n,e).unknown(r)},Ap.apply(i,arguments),i}function kp(){var t,n,e=Ep().unknown(void 0),r=e.domain,i=e.range,o=0,a=1,u=!1,c=0,f=0,s=.5;function l(){var e=r().length,l=a<o,h=l?a:o,d=l?o:a;t=(d-h)/Math.max(1,e-c+2*f),u&&(t=Math.floor(t)),h+=(d-h-t*(e-c))*s,n=t*(1-c),u&&(h=Math.round(h),n=Math.round(n));var p=tt(e).map((function(n){return h+t*n}));return i(l?p.reverse():p)}return delete e.unknown,e.domain=function(t){return arguments.length?(r(t),l()):r()},e.range=function(t){return arguments.length?([o,a]=t,o=+o,a=+a,l()):[o,a]},e.rangeRound=function(t){return[o,a]=t,o=+o,a=+a,u=!0,l()},e.bandwidth=function(){return n},e.step=function(){return t},e.round=function(t){return arguments.length?(u=!!t,l()):u},e.padding=function(t){return arguments.length?(c=Math.min(1,f=+t),l()):c},e.paddingInner=function(t){return arguments.length?(c=Math.min(1,t),l()):c},e.paddingOuter=function(t){return arguments.length?(f=+t,l()):f},e.align=function(t){return arguments.length?(s=Math.max(0,Math.min(1,t)),l()):s},e.copy=function(){return kp(r(),[o,a]).round(u).paddingInner(c).paddingOuter(f).align(s)},Ap.apply(l(),arguments)}function Np(t){var n=t.copy;return t.padding=t.paddingOuter,delete t.paddingInner,delete t.paddingOuter,t.copy=function(){return Np(n())},t}function Cp(t){return+t}var Pp=[0,1];function zp(t){return t}function Dp(t,n){return(n-=t=+t)?function(e){return(e-t)/n}:function(t){return function(){return t}}(isNaN(n)?NaN:.5)}function Rp(t,n,e){var r=t[0],i=t[1],o=n[0],a=n[1];return i<r?(r=Dp(i,r),o=e(a,o)):(r=Dp(r,i),o=e(o,a)),function(t){return o(r(t))}}function Fp(t,n,e){var r=Math.min(t.length,n.length)-1,i=new Array(r),o=new Array(r),a=-1;for(t[r]<t[0]&&(t=t.slice().reverse(),n=n.slice().reverse());++a<r;)i[a]=Dp(t[a],t[a+1]),o[a]=e(n[a],n[a+1]);return function(n){var e=c(t,n,1,r)-1;return o[e](i[e](n))}}function qp(t,n){return n.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown())}function Op(){var t,n,e,r,i,o,a=Pp,u=Pp,c=Cr,f=zp;function s(){var t=Math.min(a.length,u.length);return f!==zp&&(f=function(t,n){var e;return t>n&&(e=t,t=n,n=e),function(e){return Math.max(t,Math.min(n,e))}}(a[0],a[t-1])),r=t>2?Fp:Rp,i=o=null,l}function l(n){return null==n||isNaN(n=+n)?e:(i||(i=r(a.map(t),u,c)))(t(f(n)))}return l.invert=function(e){return f(n((o||(o=r(u,a.map(t),Tr)))(e)))},l.domain=function(t){return arguments.length?(a=Array.from(t,Cp),s()):a.slice()},l.range=function(t){return arguments.length?(u=Array.from(t),s()):u.slice()},l.rangeRound=function(t){return u=Array.from(t),c=Pr,s()},l.clamp=function(t){return arguments.length?(f=!!t||zp,s()):f!==zp},l.interpolate=function(t){return arguments.length?(c=t,s()):c},l.unknown=function(t){return arguments.length?(e=t,l):e},function(e,r){return t=e,n=r,s()}}function Up(){return Op()(zp,zp)}function Ip(n,e,r,i){var o,a=B(n,e,r);switch((i=mc(null==i?",f":i)).type){case"s":var u=Math.max(Math.abs(n),Math.abs(e));return null!=i.precision||isNaN(o=Pc(a,u))||(i.precision=o),t.formatPrefix(i,u);case"":case"e":case"g":case"p":case"r":null!=i.precision||isNaN(o=zc(a,Math.max(Math.abs(n),Math.abs(e))))||(i.precision=o-("e"===i.type));break;case"f":case"%":null!=i.precision||isNaN(o=Cc(a))||(i.precision=o-2*("%"===i.type))}return t.format(i)}function Bp(t){var n=t.domain;return t.ticks=function(t){var e=n();return U(e[0],e[e.length-1],null==t?10:t)},t.tickFormat=function(t,e){var r=n();return Ip(r[0],r[r.length-1],null==t?10:t,e)},t.nice=function(e){null==e&&(e=10);var r,i,o=n(),a=0,u=o.length-1,c=o[a],f=o[u],s=10;for(f<c&&(i=c,c=f,f=i,i=a,a=u,u=i);s-- >0;){if((i=I(c,f,e))===r)return o[a]=c,o[u]=f,n(o);if(i>0)c=Math.floor(c/i)*i,f=Math.ceil(f/i)*i;else{if(!(i<0))break;c=Math.ceil(c*i)/i,f=Math.floor(f*i)/i}r=i}return t},t}function Yp(t,n){var e,r=0,i=(t=t.slice()).length-1,o=t[r],a=t[i];return a<o&&(e=r,r=i,i=e,e=o,o=a,a=e),t[r]=n.floor(o),t[i]=n.ceil(a),t}function Lp(t){return Math.log(t)}function jp(t){return Math.exp(t)}function Hp(t){return-Math.log(-t)}function Xp(t){return-Math.exp(-t)}function Gp(t){return isFinite(t)?+("1e"+t):t<0?0:t}function Vp(t){return(n,e)=>-t(-n,e)}function $p(n){const e=n(Lp,jp),r=e.domain;let i,o,a=10;function u(){return i=function(t){return t===Math.E?Math.log:10===t&&Math.log10||2===t&&Math.log2||(t=Math.log(t),n=>Math.log(n)/t)}(a),o=function(t){return 10===t?Gp:t===Math.E?Math.exp:n=>Math.pow(t,n)}(a),r()[0]<0?(i=Vp(i),o=Vp(o),n(Hp,Xp)):n(Lp,jp),e}return e.base=function(t){return arguments.length?(a=+t,u()):a},e.domain=function(t){return arguments.length?(r(t),u()):r()},e.ticks=t=>{const n=r();let e=n[0],u=n[n.length-1];const c=u<e;c&&([e,u]=[u,e]);let f,s,l=i(e),h=i(u);const d=null==t?10:+t;let p=[];if(!(a%1)&&h-l<d){if(l=Math.floor(l),h=Math.ceil(h),e>0){for(;l<=h;++l)for(f=1;f<a;++f)if(s=l<0?f/o(-l):f*o(l),!(s<e)){if(s>u)break;p.push(s)}}else for(;l<=h;++l)for(f=a-1;f>=1;--f)if(s=l>0?f/o(-l):f*o(l),!(s<e)){if(s>u)break;p.push(s)}2*p.length<d&&(p=U(e,u,d))}else p=U(l,h,Math.min(h-l,d)).map(o);return c?p.reverse():p},e.tickFormat=(n,r)=>{if(null==n&&(n=10),null==r&&(r=10===a?"s":","),"function"!=typeof r&&(a%1||null!=(r=mc(r)).precision||(r.trim=!0),r=t.format(r)),n===1/0)return r;const u=Math.max(1,a*n/e.ticks().length);return t=>{let n=t/o(Math.round(i(t)));return n*a<a-.5&&(n*=a),n<=u?r(t):""}},e.nice=()=>r(Yp(r(),{floor:t=>o(Math.floor(i(t))),ceil:t=>o(Math.ceil(i(t)))})),e}function Wp(t){return function(n){return Math.sign(n)*Math.log1p(Math.abs(n/t))}}function Zp(t){return function(n){return Math.sign(n)*Math.expm1(Math.abs(n))*t}}function Kp(t){var n=1,e=t(Wp(n),Zp(n));return e.constant=function(e){return arguments.length?t(Wp(n=+e),Zp(n)):n},Bp(e)}function Qp(t){return function(n){return n<0?-Math.pow(-n,t):Math.pow(n,t)}}function Jp(t){return t<0?-Math.sqrt(-t):Math.sqrt(t)}function tg(t){return t<0?-t*t:t*t}function ng(t){var n=t(zp,zp),e=1;function r(){return 1===e?t(zp,zp):.5===e?t(Jp,tg):t(Qp(e),Qp(1/e))}return n.exponent=function(t){return arguments.length?(e=+t,r()):e},Bp(n)}function eg(){var t=ng(Op());return t.copy=function(){return qp(t,eg()).exponent(t.exponent())},Ap.apply(t,arguments),t}function rg(t){return Math.sign(t)*t*t}function ig(t){return Math.sign(t)*Math.sqrt(Math.abs(t))}var og=new Date,ag=new Date;function ug(t,n,e,r){function i(n){return t(n=0===arguments.length?new Date:new Date(+n)),n}return i.floor=function(n){return t(n=new Date(+n)),n},i.ceil=function(e){return t(e=new Date(e-1)),n(e,1),t(e),e},i.round=function(t){var n=i(t),e=i.ceil(t);return t-n<e-t?n:e},i.offset=function(t,e){return n(t=new Date(+t),null==e?1:Math.floor(e)),t},i.range=function(e,r,o){var a,u=[];if(e=i.ceil(e),o=null==o?1:Math.floor(o),!(e<r&&o>0))return u;do{u.push(a=new Date(+e)),n(e,o),t(e)}while(a<e&&e<r);return u},i.filter=function(e){return ug((function(n){if(n>=n)for(;t(n),!e(n);)n.setTime(n-1)}),(function(t,r){if(t>=t)if(r<0)for(;++r<=0;)for(;n(t,-1),!e(t););else for(;--r>=0;)for(;n(t,1),!e(t););}))},e&&(i.count=function(n,r){return og.setTime(+n),ag.setTime(+r),t(og),t(ag),Math.floor(e(og,ag))},i.every=function(t){return t=Math.floor(t),isFinite(t)&&t>0?t>1?i.filter(r?function(n){return r(n)%t==0}:function(n){return i.count(0,n)%t==0}):i:null}),i}var cg=ug((function(){}),(function(t,n){t.setTime(+t+n)}),(function(t,n){return n-t}));cg.every=function(t){return t=Math.floor(t),isFinite(t)&&t>0?t>1?ug((function(n){n.setTime(Math.floor(n/t)*t)}),(function(n,e){n.setTime(+n+e*t)}),(function(n,e){return(e-n)/t})):cg:null};var fg=cg,sg=cg.range;const lg=1e3,hg=6e4,dg=36e5,pg=864e5,gg=6048e5,yg=2592e6,vg=31536e6;var _g=ug((function(t){t.setTime(t-t.getMilliseconds())}),(function(t,n){t.setTime(+t+n*lg)}),(function(t,n){return(n-t)/lg}),(function(t){return t.getUTCSeconds()})),bg=_g,mg=_g.range,xg=ug((function(t){t.setTime(t-t.getMilliseconds()-t.getSeconds()*lg)}),(function(t,n){t.setTime(+t+n*hg)}),(function(t,n){return(n-t)/hg}),(function(t){return t.getMinutes()})),wg=xg,Mg=xg.range,Ag=ug((function(t){t.setTime(t-t.getMilliseconds()-t.getSeconds()*lg-t.getMinutes()*hg)}),(function(t,n){t.setTime(+t+n*dg)}),(function(t,n){return(n-t)/dg}),(function(t){return t.getHours()})),Tg=Ag,Sg=Ag.range,Eg=ug((t=>t.setHours(0,0,0,0)),((t,n)=>t.setDate(t.getDate()+n)),((t,n)=>(n-t-(n.getTimezoneOffset()-t.getTimezoneOffset())*hg)/pg),(t=>t.getDate()-1)),kg=Eg,Ng=Eg.range;function Cg(t){return ug((function(n){n.setDate(n.getDate()-(n.getDay()+7-t)%7),n.setHours(0,0,0,0)}),(function(t,n){t.setDate(t.getDate()+7*n)}),(function(t,n){return(n-t-(n.getTimezoneOffset()-t.getTimezoneOffset())*hg)/gg}))}var Pg=Cg(0),zg=Cg(1),Dg=Cg(2),Rg=Cg(3),Fg=Cg(4),qg=Cg(5),Og=Cg(6),Ug=Pg.range,Ig=zg.range,Bg=Dg.range,Yg=Rg.range,Lg=Fg.range,jg=qg.range,Hg=Og.range,Xg=ug((function(t){t.setDate(1),t.setHours(0,0,0,0)}),(function(t,n){t.setMonth(t.getMonth()+n)}),(function(t,n){return n.getMonth()-t.getMonth()+12*(n.getFullYear()-t.getFullYear())}),(function(t){return t.getMonth()})),Gg=Xg,Vg=Xg.range,$g=ug((function(t){t.setMonth(0,1),t.setHours(0,0,0,0)}),(function(t,n){t.setFullYear(t.getFullYear()+n)}),(function(t,n){return n.getFullYear()-t.getFullYear()}),(function(t){return t.getFullYear()}));$g.every=function(t){return isFinite(t=Math.floor(t))&&t>0?ug((function(n){n.setFullYear(Math.floor(n.getFullYear()/t)*t),n.setMonth(0,1),n.setHours(0,0,0,0)}),(function(n,e){n.setFullYear(n.getFullYear()+e*t)})):null};var Wg=$g,Zg=$g.range,Kg=ug((function(t){t.setUTCSeconds(0,0)}),(function(t,n){t.setTime(+t+n*hg)}),(function(t,n){return(n-t)/hg}),(function(t){return t.getUTCMinutes()})),Qg=Kg,Jg=Kg.range,ty=ug((function(t){t.setUTCMinutes(0,0,0)}),(function(t,n){t.setTime(+t+n*dg)}),(function(t,n){return(n-t)/dg}),(function(t){return t.getUTCHours()})),ny=ty,ey=ty.range,ry=ug((function(t){t.setUTCHours(0,0,0,0)}),(function(t,n){t.setUTCDate(t.getUTCDate()+n)}),(function(t,n){return(n-t)/pg}),(function(t){return t.getUTCDate()-1})),iy=ry,oy=ry.range;function ay(t){return ug((function(n){n.setUTCDate(n.getUTCDate()-(n.getUTCDay()+7-t)%7),n.setUTCHours(0,0,0,0)}),(function(t,n){t.setUTCDate(t.getUTCDate()+7*n)}),(function(t,n){return(n-t)/gg}))}var uy=ay(0),cy=ay(1),fy=ay(2),sy=ay(3),ly=ay(4),hy=ay(5),dy=ay(6),py=uy.range,gy=cy.range,yy=fy.range,vy=sy.range,_y=ly.range,by=hy.range,my=dy.range,xy=ug((function(t){t.setUTCDate(1),t.setUTCHours(0,0,0,0)}),(function(t,n){t.setUTCMonth(t.getUTCMonth()+n)}),(function(t,n){return n.getUTCMonth()-t.getUTCMonth()+12*(n.getUTCFullYear()-t.getUTCFullYear())}),(function(t){return t.getUTCMonth()})),wy=xy,My=xy.range,Ay=ug((function(t){t.setUTCMonth(0,1),t.setUTCHours(0,0,0,0)}),(function(t,n){t.setUTCFullYear(t.getUTCFullYear()+n)}),(function(t,n){return n.getUTCFullYear()-t.getUTCFullYear()}),(function(t){return t.getUTCFullYear()}));Ay.every=function(t){return isFinite(t=Math.floor(t))&&t>0?ug((function(n){n.setUTCFullYear(Math.floor(n.getUTCFullYear()/t)*t),n.setUTCMonth(0,1),n.setUTCHours(0,0,0,0)}),(function(n,e){n.setUTCFullYear(n.getUTCFullYear()+e*t)})):null};var Ty=Ay,Sy=Ay.range;function Ey(t,n,r,i,o,a){const u=[[bg,1,lg],[bg,5,5e3],[bg,15,15e3],[bg,30,3e4],[a,1,hg],[a,5,3e5],[a,15,9e5],[a,30,18e5],[o,1,dg],[o,3,108e5],[o,6,216e5],[o,12,432e5],[i,1,pg],[i,2,1728e5],[r,1,gg],[n,1,yg],[n,3,7776e6],[t,1,vg]];function c(n,r,i){const o=Math.abs(r-n)/i,a=e((([,,t])=>t)).right(u,o);if(a===u.length)return t.every(B(n/vg,r/vg,i));if(0===a)return fg.every(Math.max(B(n,r,i),1));const[c,f]=u[o/u[a-1][2]<u[a][2]/o?a-1:a];return c.every(f)}return[function(t,n,e){const r=n<t;r&&([t,n]=[n,t]);const i=e&&"function"==typeof e.range?e:c(t,n,e),o=i?i.range(t,+n+1):[];return r?o.reverse():o},c]}const[ky,Ny]=Ey(Ty,wy,uy,iy,ny,Qg),[Cy,Py]=Ey(Wg,Gg,Pg,kg,Tg,wg);function zy(t){if(0<=t.y&&t.y<100){var n=new Date(-1,t.m,t.d,t.H,t.M,t.S,t.L);return n.setFullYear(t.y),n}return new Date(t.y,t.m,t.d,t.H,t.M,t.S,t.L)}function Dy(t){if(0<=t.y&&t.y<100){var n=new Date(Date.UTC(-1,t.m,t.d,t.H,t.M,t.S,t.L));return n.setUTCFullYear(t.y),n}return new Date(Date.UTC(t.y,t.m,t.d,t.H,t.M,t.S,t.L))}function Ry(t,n,e){return{y:t,m:n,d:e,H:0,M:0,S:0,L:0}}function Fy(t){var n=t.dateTime,e=t.date,r=t.time,i=t.periods,o=t.days,a=t.shortDays,u=t.months,c=t.shortMonths,f=jy(i),s=Hy(i),l=jy(o),h=Hy(o),d=jy(a),p=Hy(a),g=jy(u),y=Hy(u),v=jy(c),_=Hy(c),b={a:function(t){return a[t.getDay()]},A:function(t){return o[t.getDay()]},b:function(t){return c[t.getMonth()]},B:function(t){return u[t.getMonth()]},c:null,d:lv,e:lv,f:yv,g:Ev,G:Nv,H:hv,I:dv,j:pv,L:gv,m:vv,M:_v,p:function(t){return i[+(t.getHours()>=12)]},q:function(t){return 1+~~(t.getMonth()/3)},Q:Qv,s:Jv,S:bv,u:mv,U:xv,V:Mv,w:Av,W:Tv,x:null,X:null,y:Sv,Y:kv,Z:Cv,"%":Kv},m={a:function(t){return a[t.getUTCDay()]},A:function(t){return o[t.getUTCDay()]},b:function(t){return c[t.getUTCMonth()]},B:function(t){return u[t.getUTCMonth()]},c:null,d:Pv,e:Pv,f:qv,g:Vv,G:Wv,H:zv,I:Dv,j:Rv,L:Fv,m:Ov,M:Uv,p:function(t){return i[+(t.getUTCHours()>=12)]},q:function(t){return 1+~~(t.getUTCMonth()/3)},Q:Qv,s:Jv,S:Iv,u:Bv,U:Yv,V:jv,w:Hv,W:Xv,x:null,X:null,y:Gv,Y:$v,Z:Zv,"%":Kv},x={a:function(t,n,e){var r=d.exec(n.slice(e));return r?(t.w=p.get(r[0].toLowerCase()),e+r[0].length):-1},A:function(t,n,e){var r=l.exec(n.slice(e));return r?(t.w=h.get(r[0].toLowerCase()),e+r[0].length):-1},b:function(t,n,e){var r=v.exec(n.slice(e));return r?(t.m=_.get(r[0].toLowerCase()),e+r[0].length):-1},B:function(t,n,e){var r=g.exec(n.slice(e));return r?(t.m=y.get(r[0].toLowerCase()),e+r[0].length):-1},c:function(t,e,r){return A(t,n,e,r)},d:nv,e:nv,f:uv,g:Ky,G:Zy,H:rv,I:rv,j:ev,L:av,m:tv,M:iv,p:function(t,n,e){var r=f.exec(n.slice(e));return r?(t.p=s.get(r[0].toLowerCase()),e+r[0].length):-1},q:Jy,Q:fv,s:sv,S:ov,u:Gy,U:Vy,V:$y,w:Xy,W:Wy,x:function(t,n,r){return A(t,e,n,r)},X:function(t,n,e){return A(t,r,n,e)},y:Ky,Y:Zy,Z:Qy,"%":cv};function w(t,n){return function(e){var r,i,o,a=[],u=-1,c=0,f=t.length;for(e instanceof Date||(e=new Date(+e));++u<f;)37===t.charCodeAt(u)&&(a.push(t.slice(c,u)),null!=(i=Oy[r=t.charAt(++u)])?r=t.charAt(++u):i="e"===r?" ":"0",(o=n[r])&&(r=o(e,i)),a.push(r),c=u+1);return a.push(t.slice(c,u)),a.join("")}}function M(t,n){return function(e){var r,i,o=Ry(1900,void 0,1);if(A(o,t,e+="",0)!=e.length)return null;if("Q"in o)return new Date(o.Q);if("s"in o)return new Date(1e3*o.s+("L"in o?o.L:0));if(n&&!("Z"in o)&&(o.Z=0),"p"in o&&(o.H=o.H%12+12*o.p),void 0===o.m&&(o.m="q"in o?o.q:0),"V"in o){if(o.V<1||o.V>53)return null;"w"in o||(o.w=1),"Z"in o?(i=(r=Dy(Ry(o.y,0,1))).getUTCDay(),r=i>4||0===i?cy.ceil(r):cy(r),r=iy.offset(r,7*(o.V-1)),o.y=r.getUTCFullYear(),o.m=r.getUTCMonth(),o.d=r.getUTCDate()+(o.w+6)%7):(i=(r=zy(Ry(o.y,0,1))).getDay(),r=i>4||0===i?zg.ceil(r):zg(r),r=kg.offset(r,7*(o.V-1)),o.y=r.getFullYear(),o.m=r.getMonth(),o.d=r.getDate()+(o.w+6)%7)}else("W"in o||"U"in o)&&("w"in o||(o.w="u"in o?o.u%7:"W"in o?1:0),i="Z"in o?Dy(Ry(o.y,0,1)).getUTCDay():zy(Ry(o.y,0,1)).getDay(),o.m=0,o.d="W"in o?(o.w+6)%7+7*o.W-(i+5)%7:o.w+7*o.U-(i+6)%7);return"Z"in o?(o.H+=o.Z/100|0,o.M+=o.Z%100,Dy(o)):zy(o)}}function A(t,n,e,r){for(var i,o,a=0,u=n.length,c=e.length;a<u;){if(r>=c)return-1;if(37===(i=n.charCodeAt(a++))){if(i=n.charAt(a++),!(o=x[i in Oy?n.charAt(a++):i])||(r=o(t,e,r))<0)return-1}else if(i!=e.charCodeAt(r++))return-1}return r}return b.x=w(e,b),b.X=w(r,b),b.c=w(n,b),m.x=w(e,m),m.X=w(r,m),m.c=w(n,m),{format:function(t){var n=w(t+="",b);return n.toString=function(){return t},n},parse:function(t){var n=M(t+="",!1);return n.toString=function(){return t},n},utcFormat:function(t){var n=w(t+="",m);return n.toString=function(){return t},n},utcParse:function(t){var n=M(t+="",!0);return n.toString=function(){return t},n}}}var qy,Oy={"-":"",_:" ",0:"0"},Uy=/^\s*\d+/,Iy=/^%/,By=/[\\^$*+?|[\]().{}]/g;function Yy(t,n,e){var r=t<0?"-":"",i=(r?-t:t)+"",o=i.length;return r+(o<e?new Array(e-o+1).join(n)+i:i)}function Ly(t){return t.replace(By,"\\$&")}function jy(t){return new RegExp("^(?:"+t.map(Ly).join("|")+")","i")}function Hy(t){return new Map(t.map(((t,n)=>[t.toLowerCase(),n])))}function Xy(t,n,e){var r=Uy.exec(n.slice(e,e+1));return r?(t.w=+r[0],e+r[0].length):-1}function Gy(t,n,e){var r=Uy.exec(n.slice(e,e+1));return r?(t.u=+r[0],e+r[0].length):-1}function Vy(t,n,e){var r=Uy.exec(n.slice(e,e+2));return r?(t.U=+r[0],e+r[0].length):-1}function $y(t,n,e){var r=Uy.exec(n.slice(e,e+2));return r?(t.V=+r[0],e+r[0].length):-1}function Wy(t,n,e){var r=Uy.exec(n.slice(e,e+2));return r?(t.W=+r[0],e+r[0].length):-1}function Zy(t,n,e){var r=Uy.exec(n.slice(e,e+4));return r?(t.y=+r[0],e+r[0].length):-1}function Ky(t,n,e){var r=Uy.exec(n.slice(e,e+2));return r?(t.y=+r[0]+(+r[0]>68?1900:2e3),e+r[0].length):-1}function Qy(t,n,e){var r=/^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(n.slice(e,e+6));return r?(t.Z=r[1]?0:-(r[2]+(r[3]||"00")),e+r[0].length):-1}function Jy(t,n,e){var r=Uy.exec(n.slice(e,e+1));return r?(t.q=3*r[0]-3,e+r[0].length):-1}function tv(t,n,e){var r=Uy.exec(n.slice(e,e+2));return r?(t.m=r[0]-1,e+r[0].length):-1}function nv(t,n,e){var r=Uy.exec(n.slice(e,e+2));return r?(t.d=+r[0],e+r[0].length):-1}function ev(t,n,e){var r=Uy.exec(n.slice(e,e+3));return r?(t.m=0,t.d=+r[0],e+r[0].length):-1}function rv(t,n,e){var r=Uy.exec(n.slice(e,e+2));return r?(t.H=+r[0],e+r[0].length):-1}function iv(t,n,e){var r=Uy.exec(n.slice(e,e+2));return r?(t.M=+r[0],e+r[0].length):-1}function ov(t,n,e){var r=Uy.exec(n.slice(e,e+2));return r?(t.S=+r[0],e+r[0].length):-1}function av(t,n,e){var r=Uy.exec(n.slice(e,e+3));return r?(t.L=+r[0],e+r[0].length):-1}function uv(t,n,e){var r=Uy.exec(n.slice(e,e+6));return r?(t.L=Math.floor(r[0]/1e3),e+r[0].length):-1}function cv(t,n,e){var r=Iy.exec(n.slice(e,e+1));return r?e+r[0].length:-1}function fv(t,n,e){var r=Uy.exec(n.slice(e));return r?(t.Q=+r[0],e+r[0].length):-1}function sv(t,n,e){var r=Uy.exec(n.slice(e));return r?(t.s=+r[0],e+r[0].length):-1}function lv(t,n){return Yy(t.getDate(),n,2)}function hv(t,n){return Yy(t.getHours(),n,2)}function dv(t,n){return Yy(t.getHours()%12||12,n,2)}function pv(t,n){return Yy(1+kg.count(Wg(t),t),n,3)}function gv(t,n){return Yy(t.getMilliseconds(),n,3)}function yv(t,n){return gv(t,n)+"000"}function vv(t,n){return Yy(t.getMonth()+1,n,2)}function _v(t,n){return Yy(t.getMinutes(),n,2)}function bv(t,n){return Yy(t.getSeconds(),n,2)}function mv(t){var n=t.getDay();return 0===n?7:n}function xv(t,n){return Yy(Pg.count(Wg(t)-1,t),n,2)}function wv(t){var n=t.getDay();return n>=4||0===n?Fg(t):Fg.ceil(t)}function Mv(t,n){return t=wv(t),Yy(Fg.count(Wg(t),t)+(4===Wg(t).getDay()),n,2)}function Av(t){return t.getDay()}function Tv(t,n){return Yy(zg.count(Wg(t)-1,t),n,2)}function Sv(t,n){return Yy(t.getFullYear()%100,n,2)}function Ev(t,n){return Yy((t=wv(t)).getFullYear()%100,n,2)}function kv(t,n){return Yy(t.getFullYear()%1e4,n,4)}function Nv(t,n){var e=t.getDay();return Yy((t=e>=4||0===e?Fg(t):Fg.ceil(t)).getFullYear()%1e4,n,4)}function Cv(t){var n=t.getTimezoneOffset();return(n>0?"-":(n*=-1,"+"))+Yy(n/60|0,"0",2)+Yy(n%60,"0",2)}function Pv(t,n){return Yy(t.getUTCDate(),n,2)}function zv(t,n){return Yy(t.getUTCHours(),n,2)}function Dv(t,n){return Yy(t.getUTCHours()%12||12,n,2)}function Rv(t,n){return Yy(1+iy.count(Ty(t),t),n,3)}function Fv(t,n){return Yy(t.getUTCMilliseconds(),n,3)}function qv(t,n){return Fv(t,n)+"000"}function Ov(t,n){return Yy(t.getUTCMonth()+1,n,2)}function Uv(t,n){return Yy(t.getUTCMinutes(),n,2)}function Iv(t,n){return Yy(t.getUTCSeconds(),n,2)}function Bv(t){var n=t.getUTCDay();return 0===n?7:n}function Yv(t,n){return Yy(uy.count(Ty(t)-1,t),n,2)}function Lv(t){var n=t.getUTCDay();return n>=4||0===n?ly(t):ly.ceil(t)}function jv(t,n){return t=Lv(t),Yy(ly.count(Ty(t),t)+(4===Ty(t).getUTCDay()),n,2)}function Hv(t){return t.getUTCDay()}function Xv(t,n){return Yy(cy.count(Ty(t)-1,t),n,2)}function Gv(t,n){return Yy(t.getUTCFullYear()%100,n,2)}function Vv(t,n){return Yy((t=Lv(t)).getUTCFullYear()%100,n,2)}function $v(t,n){return Yy(t.getUTCFullYear()%1e4,n,4)}function Wv(t,n){var e=t.getUTCDay();return Yy((t=e>=4||0===e?ly(t):ly.ceil(t)).getUTCFullYear()%1e4,n,4)}function Zv(){return"+0000"}function Kv(){return"%"}function Qv(t){return+t}function Jv(t){return Math.floor(+t/1e3)}function t_(n){return qy=Fy(n),t.timeFormat=qy.format,t.timeParse=qy.parse,t.utcFormat=qy.utcFormat,t.utcParse=qy.utcParse,qy}t.timeFormat=void 0,t.timeParse=void 0,t.utcFormat=void 0,t.utcParse=void 0,t_({dateTime:"%x, %X",date:"%-m/%-d/%Y",time:"%-I:%M:%S %p",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});var n_="%Y-%m-%dT%H:%M:%S.%LZ";var e_=Date.prototype.toISOString?function(t){return t.toISOString()}:t.utcFormat(n_),r_=e_;var i_=+new Date("2000-01-01T00:00:00.000Z")?function(t){var n=new Date(t);return isNaN(n)?null:n}:t.utcParse(n_),o_=i_;function a_(t){return new Date(t)}function u_(t){return t instanceof Date?+t:+new Date(+t)}function c_(t,n,e,r,i,o,a,u,c,f){var s=Up(),l=s.invert,h=s.domain,d=f(".%L"),p=f(":%S"),g=f("%I:%M"),y=f("%I %p"),v=f("%a %d"),_=f("%b %d"),b=f("%B"),m=f("%Y");function x(t){return(c(t)<t?d:u(t)<t?p:a(t)<t?g:o(t)<t?y:r(t)<t?i(t)<t?v:_:e(t)<t?b:m)(t)}return s.invert=function(t){return new Date(l(t))},s.domain=function(t){return arguments.length?h(Array.from(t,u_)):h().map(a_)},s.ticks=function(n){var e=h();return t(e[0],e[e.length-1],null==n?10:n)},s.tickFormat=function(t,n){return null==n?x:f(n)},s.nice=function(t){var e=h();return t&&"function"==typeof t.range||(t=n(e[0],e[e.length-1],null==t?10:t)),t?h(Yp(e,t)):s},s.copy=function(){return qp(s,c_(t,n,e,r,i,o,a,u,c,f))},s}function f_(){var t,n,e,r,i,o=0,a=1,u=zp,c=!1;function f(n){return null==n||isNaN(n=+n)?i:u(0===e?.5:(n=(r(n)-t)*e,c?Math.max(0,Math.min(1,n)):n))}function s(t){return function(n){var e,r;return arguments.length?([e,r]=n,u=t(e,r),f):[u(0),u(1)]}}return f.domain=function(i){return arguments.length?([o,a]=i,t=r(o=+o),n=r(a=+a),e=t===n?0:1/(n-t),f):[o,a]},f.clamp=function(t){return arguments.length?(c=!!t,f):c},f.interpolator=function(t){return arguments.length?(u=t,f):u},f.range=s(Cr),f.rangeRound=s(Pr),f.unknown=function(t){return arguments.length?(i=t,f):i},function(i){return r=i,t=i(o),n=i(a),e=t===n?0:1/(n-t),f}}function s_(t,n){return n.domain(t.domain()).interpolator(t.interpolator()).clamp(t.clamp()).unknown(t.unknown())}function l_(){var t=ng(f_());return t.copy=function(){return s_(t,l_()).exponent(t.exponent())},Tp.apply(t,arguments)}function h_(){var t,n,e,r,i,o,a,u=0,c=.5,f=1,s=1,l=zp,h=!1;function d(t){return isNaN(t=+t)?a:(t=.5+((t=+o(t))-n)*(s*t<s*n?r:i),l(h?Math.max(0,Math.min(1,t)):t))}function p(t){return function(n){var e,r,i;return arguments.length?([e,r,i]=n,l=Zr(t,[e,r,i]),d):[l(0),l(.5),l(1)]}}return d.domain=function(a){return arguments.length?([u,c,f]=a,t=o(u=+u),n=o(c=+c),e=o(f=+f),r=t===n?0:.5/(n-t),i=n===e?0:.5/(e-n),s=n<t?-1:1,d):[u,c,f]},d.clamp=function(t){return arguments.length?(h=!!t,d):h},d.interpolator=function(t){return arguments.length?(l=t,d):l},d.range=p(Cr),d.rangeRound=p(Pr),d.unknown=function(t){return arguments.length?(a=t,d):a},function(a){return o=a,t=a(u),n=a(c),e=a(f),r=t===n?0:.5/(n-t),i=n===e?0:.5/(e-n),s=n<t?-1:1,d}}function d_(){var t=ng(h_());return t.copy=function(){return s_(t,d_()).exponent(t.exponent())},Tp.apply(t,arguments)}function p_(t){for(var n=t.length/6|0,e=new Array(n),r=0;r<n;)e[r]="#"+t.slice(6*r,6*++r);return e}var g_=p_("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"),y_=p_("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"),v_=p_("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"),__=p_("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"),b_=p_("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2"),m_=p_("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc"),x_=p_("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999"),w_=p_("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"),M_=p_("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"),A_=p_("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab"),T_=t=>br(t[t.length-1]),S_=new Array(3).concat("d8b365f5f5f55ab4ac","a6611adfc27d80cdc1018571","a6611adfc27df5f5f580cdc1018571","8c510ad8b365f6e8c3c7eae55ab4ac01665e","8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e","8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e","8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e","5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30","5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30").map(p_),E_=T_(S_),k_=new Array(3).concat("af8dc3f7f7f77fbf7b","7b3294c2a5cfa6dba0008837","7b3294c2a5cff7f7f7a6dba0008837","762a83af8dc3e7d4e8d9f0d37fbf7b1b7837","762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837","762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837","762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837","40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b","40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b").map(p_),N_=T_(k_),C_=new Array(3).concat("e9a3c9f7f7f7a1d76a","d01c8bf1b6dab8e1864dac26","d01c8bf1b6daf7f7f7b8e1864dac26","c51b7de9a3c9fde0efe6f5d0a1d76a4d9221","c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221","c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221","c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221","8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419","8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419").map(p_),P_=T_(C_),z_=new Array(3).concat("998ec3f7f7f7f1a340","5e3c99b2abd2fdb863e66101","5e3c99b2abd2f7f7f7fdb863e66101","542788998ec3d8daebfee0b6f1a340b35806","542788998ec3d8daebf7f7f7fee0b6f1a340b35806","5427888073acb2abd2d8daebfee0b6fdb863e08214b35806","5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806","2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08","2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08").map(p_),D_=T_(z_),R_=new Array(3).concat("ef8a62f7f7f767a9cf","ca0020f4a58292c5de0571b0","ca0020f4a582f7f7f792c5de0571b0","b2182bef8a62fddbc7d1e5f067a9cf2166ac","b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac","b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac","b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac","67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061","67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061").map(p_),F_=T_(R_),q_=new Array(3).concat("ef8a62ffffff999999","ca0020f4a582bababa404040","ca0020f4a582ffffffbababa404040","b2182bef8a62fddbc7e0e0e09999994d4d4d","b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d","b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d","b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d","67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a","67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a").map(p_),O_=T_(q_),U_=new Array(3).concat("fc8d59ffffbf91bfdb","d7191cfdae61abd9e92c7bb6","d7191cfdae61ffffbfabd9e92c7bb6","d73027fc8d59fee090e0f3f891bfdb4575b4","d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4","d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4","d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4","a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695","a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695").map(p_),I_=T_(U_),B_=new Array(3).concat("fc8d59ffffbf91cf60","d7191cfdae61a6d96a1a9641","d7191cfdae61ffffbfa6d96a1a9641","d73027fc8d59fee08bd9ef8b91cf601a9850","d73027fc8d59fee08bffffbfd9ef8b91cf601a9850","d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850","d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850","a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837","a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837").map(p_),Y_=T_(B_),L_=new Array(3).concat("fc8d59ffffbf99d594","d7191cfdae61abdda42b83ba","d7191cfdae61ffffbfabdda42b83ba","d53e4ffc8d59fee08be6f59899d5943288bd","d53e4ffc8d59fee08bffffbfe6f59899d5943288bd","d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd","d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd","9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2","9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2").map(p_),j_=T_(L_),H_=new Array(3).concat("e5f5f999d8c92ca25f","edf8fbb2e2e266c2a4238b45","edf8fbb2e2e266c2a42ca25f006d2c","edf8fbccece699d8c966c2a42ca25f006d2c","edf8fbccece699d8c966c2a441ae76238b45005824","f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824","f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b").map(p_),X_=T_(H_),G_=new Array(3).concat("e0ecf49ebcda8856a7","edf8fbb3cde38c96c688419d","edf8fbb3cde38c96c68856a7810f7c","edf8fbbfd3e69ebcda8c96c68856a7810f7c","edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b","f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b","f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b").map(p_),V_=T_(G_),$_=new Array(3).concat("e0f3dba8ddb543a2ca","f0f9e8bae4bc7bccc42b8cbe","f0f9e8bae4bc7bccc443a2ca0868ac","f0f9e8ccebc5a8ddb57bccc443a2ca0868ac","f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e","f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e","f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081").map(p_),W_=T_($_),Z_=new Array(3).concat("fee8c8fdbb84e34a33","fef0d9fdcc8afc8d59d7301f","fef0d9fdcc8afc8d59e34a33b30000","fef0d9fdd49efdbb84fc8d59e34a33b30000","fef0d9fdd49efdbb84fc8d59ef6548d7301f990000","fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000","fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000").map(p_),K_=T_(Z_),Q_=new Array(3).concat("ece2f0a6bddb1c9099","f6eff7bdc9e167a9cf02818a","f6eff7bdc9e167a9cf1c9099016c59","f6eff7d0d1e6a6bddb67a9cf1c9099016c59","f6eff7d0d1e6a6bddb67a9cf3690c002818a016450","fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450","fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636").map(p_),J_=T_(Q_),tb=new Array(3).concat("ece7f2a6bddb2b8cbe","f1eef6bdc9e174a9cf0570b0","f1eef6bdc9e174a9cf2b8cbe045a8d","f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d","f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b","fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b","fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858").map(p_),nb=T_(tb),eb=new Array(3).concat("e7e1efc994c7dd1c77","f1eef6d7b5d8df65b0ce1256","f1eef6d7b5d8df65b0dd1c77980043","f1eef6d4b9dac994c7df65b0dd1c77980043","f1eef6d4b9dac994c7df65b0e7298ace125691003f","f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f","f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f").map(p_),rb=T_(eb),ib=new Array(3).concat("fde0ddfa9fb5c51b8a","feebe2fbb4b9f768a1ae017e","feebe2fbb4b9f768a1c51b8a7a0177","feebe2fcc5c0fa9fb5f768a1c51b8a7a0177","feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177","fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177","fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a").map(p_),ob=T_(ib),ab=new Array(3).concat("edf8b17fcdbb2c7fb8","ffffcca1dab441b6c4225ea8","ffffcca1dab441b6c42c7fb8253494","ffffccc7e9b47fcdbb41b6c42c7fb8253494","ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84","ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84","ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58").map(p_),ub=T_(ab),cb=new Array(3).concat("f7fcb9addd8e31a354","ffffccc2e69978c679238443","ffffccc2e69978c67931a354006837","ffffccd9f0a3addd8e78c67931a354006837","ffffccd9f0a3addd8e78c67941ab5d238443005a32","ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32","ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529").map(p_),fb=T_(cb),sb=new Array(3).concat("fff7bcfec44fd95f0e","ffffd4fed98efe9929cc4c02","ffffd4fed98efe9929d95f0e993404","ffffd4fee391fec44ffe9929d95f0e993404","ffffd4fee391fec44ffe9929ec7014cc4c028c2d04","ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04","ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506").map(p_),lb=T_(sb),hb=new Array(3).concat("ffeda0feb24cf03b20","ffffb2fecc5cfd8d3ce31a1c","ffffb2fecc5cfd8d3cf03b20bd0026","ffffb2fed976feb24cfd8d3cf03b20bd0026","ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026","ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026","ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026").map(p_),db=T_(hb),pb=new Array(3).concat("deebf79ecae13182bd","eff3ffbdd7e76baed62171b5","eff3ffbdd7e76baed63182bd08519c","eff3ffc6dbef9ecae16baed63182bd08519c","eff3ffc6dbef9ecae16baed64292c62171b5084594","f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594","f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b").map(p_),gb=T_(pb),yb=new Array(3).concat("e5f5e0a1d99b31a354","edf8e9bae4b374c476238b45","edf8e9bae4b374c47631a354006d2c","edf8e9c7e9c0a1d99b74c47631a354006d2c","edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32","f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32","f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b").map(p_),vb=T_(yb),_b=new Array(3).concat("f0f0f0bdbdbd636363","f7f7f7cccccc969696525252","f7f7f7cccccc969696636363252525","f7f7f7d9d9d9bdbdbd969696636363252525","f7f7f7d9d9d9bdbdbd969696737373525252252525","fffffff0f0f0d9d9d9bdbdbd969696737373525252252525","fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000").map(p_),bb=T_(_b),mb=new Array(3).concat("efedf5bcbddc756bb1","f2f0f7cbc9e29e9ac86a51a3","f2f0f7cbc9e29e9ac8756bb154278f","f2f0f7dadaebbcbddc9e9ac8756bb154278f","f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486","fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486","fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d").map(p_),xb=T_(mb),wb=new Array(3).concat("fee0d2fc9272de2d26","fee5d9fcae91fb6a4acb181d","fee5d9fcae91fb6a4ade2d26a50f15","fee5d9fcbba1fc9272fb6a4ade2d26a50f15","fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d","fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d","fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d").map(p_),Mb=T_(wb),Ab=new Array(3).concat("fee6cefdae6be6550d","feeddefdbe85fd8d3cd94701","feeddefdbe85fd8d3ce6550da63603","feeddefdd0a2fdae6bfd8d3ce6550da63603","feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04","fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04","fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704").map(p_),Tb=T_(Ab);var Sb=Wr(ur(300,.5,0),ur(-240,.5,1)),Eb=Wr(ur(-100,.75,.35),ur(80,1.5,.8)),kb=Wr(ur(260,.75,.35),ur(80,1.5,.8)),Nb=ur();var Cb=Ae(),Pb=Math.PI/3,zb=2*Math.PI/3;function Db(t){var n=t.length;return function(e){return t[Math.max(0,Math.min(n-1,Math.floor(e*n)))]}}var Rb=Db(p_("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")),Fb=Db(p_("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf")),qb=Db(p_("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4")),Ob=Db(p_("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));function Ub(t){return function(){return t}}const Ib=Math.abs,Bb=Math.atan2,Yb=Math.cos,Lb=Math.max,jb=Math.min,Hb=Math.sin,Xb=Math.sqrt,Gb=1e-12,Vb=Math.PI,$b=Vb/2,Wb=2*Vb;function Zb(t){return t>1?0:t<-1?Vb:Math.acos(t)}function Kb(t){return t>=1?$b:t<=-1?-$b:Math.asin(t)}function Qb(t){return t.innerRadius}function Jb(t){return t.outerRadius}function tm(t){return t.startAngle}function nm(t){return t.endAngle}function em(t){return t&&t.padAngle}function rm(t,n,e,r,i,o,a,u){var c=e-t,f=r-n,s=a-i,l=u-o,h=l*c-s*f;if(!(h*h<Gb))return[t+(h=(s*(n-o)-l*(t-i))/h)*c,n+h*f]}function im(t,n,e,r,i,o,a){var u=t-e,c=n-r,f=(a?o:-o)/Xb(u*u+c*c),s=f*c,l=-f*u,h=t+s,d=n+l,p=e+s,g=r+l,y=(h+p)/2,v=(d+g)/2,_=p-h,b=g-d,m=_*_+b*b,x=i-o,w=h*g-p*d,M=(b<0?-1:1)*Xb(Lb(0,x*x*m-w*w)),A=(w*b-_*M)/m,T=(-w*_-b*M)/m,S=(w*b+_*M)/m,E=(-w*_+b*M)/m,k=A-y,N=T-v,C=S-y,P=E-v;return k*k+N*N>C*C+P*P&&(A=S,T=E),{cx:A,cy:T,x01:-s,y01:-l,x11:A*(i/x-1),y11:T*(i/x-1)}}var om=Array.prototype.slice;function am(t){return"object"==typeof t&&"length"in t?t:Array.from(t)}function um(t){this._context=t}function cm(t){return new um(t)}function fm(t){return t[0]}function sm(t){return t[1]}function lm(t,n){var e=Ub(!0),r=null,i=cm,o=null;function a(a){var u,c,f,s=(a=am(a)).length,l=!1;for(null==r&&(o=i(f=ya())),u=0;u<=s;++u)!(u<s&&e(c=a[u],u,a))===l&&((l=!l)?o.lineStart():o.lineEnd()),l&&o.point(+t(c,u,a),+n(c,u,a));if(f)return o=null,f+""||null}return t="function"==typeof t?t:void 0===t?fm:Ub(t),n="function"==typeof n?n:void 0===n?sm:Ub(n),a.x=function(n){return arguments.length?(t="function"==typeof n?n:Ub(+n),a):t},a.y=function(t){return arguments.length?(n="function"==typeof t?t:Ub(+t),a):n},a.defined=function(t){return arguments.length?(e="function"==typeof t?t:Ub(!!t),a):e},a.curve=function(t){return arguments.length?(i=t,null!=r&&(o=i(r)),a):i},a.context=function(t){return arguments.length?(null==t?r=o=null:o=i(r=t),a):r},a}function hm(t,n,e){var r=null,i=Ub(!0),o=null,a=cm,u=null;function c(c){var f,s,l,h,d,p=(c=am(c)).length,g=!1,y=new Array(p),v=new Array(p);for(null==o&&(u=a(d=ya())),f=0;f<=p;++f){if(!(f<p&&i(h=c[f],f,c))===g)if(g=!g)s=f,u.areaStart(),u.lineStart();else{for(u.lineEnd(),u.lineStart(),l=f-1;l>=s;--l)u.point(y[l],v[l]);u.lineEnd(),u.areaEnd()}g&&(y[f]=+t(h,f,c),v[f]=+n(h,f,c),u.point(r?+r(h,f,c):y[f],e?+e(h,f,c):v[f]))}if(d)return u=null,d+""||null}function f(){return lm().defined(i).curve(a).context(o)}return t="function"==typeof t?t:void 0===t?fm:Ub(+t),n="function"==typeof n?n:Ub(void 0===n?0:+n),e="function"==typeof e?e:void 0===e?sm:Ub(+e),c.x=function(n){return arguments.length?(t="function"==typeof n?n:Ub(+n),r=null,c):t},c.x0=function(n){return arguments.length?(t="function"==typeof n?n:Ub(+n),c):t},c.x1=function(t){return arguments.length?(r=null==t?null:"function"==typeof t?t:Ub(+t),c):r},c.y=function(t){return arguments.length?(n="function"==typeof t?t:Ub(+t),e=null,c):n},c.y0=function(t){return arguments.length?(n="function"==typeof t?t:Ub(+t),c):n},c.y1=function(t){return arguments.length?(e=null==t?null:"function"==typeof t?t:Ub(+t),c):e},c.lineX0=c.lineY0=function(){return f().x(t).y(n)},c.lineY1=function(){return f().x(t).y(e)},c.lineX1=function(){return f().x(r).y(n)},c.defined=function(t){return arguments.length?(i="function"==typeof t?t:Ub(!!t),c):i},c.curve=function(t){return arguments.length?(a=t,null!=o&&(u=a(o)),c):a},c.context=function(t){return arguments.length?(null==t?o=u=null:u=a(o=t),c):o},c}function dm(t,n){return n<t?-1:n>t?1:n>=t?0:NaN}function pm(t){return t}um.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;default:this._context.lineTo(t,n)}}};var gm=vm(cm);function ym(t){this._curve=t}function vm(t){function n(n){return new ym(t(n))}return n._curve=t,n}function _m(t){var n=t.curve;return t.angle=t.x,delete t.x,t.radius=t.y,delete t.y,t.curve=function(t){return arguments.length?n(vm(t)):n()._curve},t}function bm(){return _m(lm().curve(gm))}function mm(){var t=hm().curve(gm),n=t.curve,e=t.lineX0,r=t.lineX1,i=t.lineY0,o=t.lineY1;return t.angle=t.x,delete t.x,t.startAngle=t.x0,delete t.x0,t.endAngle=t.x1,delete t.x1,t.radius=t.y,delete t.y,t.innerRadius=t.y0,delete t.y0,t.outerRadius=t.y1,delete t.y1,t.lineStartAngle=function(){return _m(e())},delete t.lineX0,t.lineEndAngle=function(){return _m(r())},delete t.lineX1,t.lineInnerRadius=function(){return _m(i())},delete t.lineY0,t.lineOuterRadius=function(){return _m(o())},delete t.lineY1,t.curve=function(t){return arguments.length?n(vm(t)):n()._curve},t}function xm(t,n){return[(n=+n)*Math.cos(t-=Math.PI/2),n*Math.sin(t)]}ym.prototype={areaStart:function(){this._curve.areaStart()},areaEnd:function(){this._curve.areaEnd()},lineStart:function(){this._curve.lineStart()},lineEnd:function(){this._curve.lineEnd()},point:function(t,n){this._curve.point(n*Math.sin(t),n*-Math.cos(t))}};class wm{constructor(t,n){this._context=t,this._x=n}areaStart(){this._line=0}areaEnd(){this._line=NaN}lineStart(){this._point=0}lineEnd(){(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line}point(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;default:this._x?this._context.bezierCurveTo(this._x0=(this._x0+t)/2,this._y0,this._x0,n,t,n):this._context.bezierCurveTo(this._x0,this._y0=(this._y0+n)/2,t,this._y0,t,n)}this._x0=t,this._y0=n}}class Mm{constructor(t){this._context=t}lineStart(){this._point=0}lineEnd(){}point(t,n){if(t=+t,n=+n,0==this._point++)this._x0=t,this._y0=n;else{const e=xm(this._x0,this._y0),r=xm(this._x0,this._y0=(this._y0+n)/2),i=xm(t,this._y0),o=xm(t,n);this._context.moveTo(...e),this._context.bezierCurveTo(...r,...i,...o)}}}function Am(t){return new wm(t,!0)}function Tm(t){return new wm(t,!1)}function Sm(t){return new Mm(t)}function Em(t){return t.source}function km(t){return t.target}function Nm(t){let n=Em,e=km,r=fm,i=sm,o=null,a=null;function u(){let u;const c=om.call(arguments),f=n.apply(this,c),s=e.apply(this,c);if(null==o&&(a=t(u=ya())),a.lineStart(),c[0]=f,a.point(+r.apply(this,c),+i.apply(this,c)),c[0]=s,a.point(+r.apply(this,c),+i.apply(this,c)),a.lineEnd(),u)return a=null,u+""||null}return u.source=function(t){return arguments.length?(n=t,u):n},u.target=function(t){return arguments.length?(e=t,u):e},u.x=function(t){return arguments.length?(r="function"==typeof t?t:Ub(+t),u):r},u.y=function(t){return arguments.length?(i="function"==typeof t?t:Ub(+t),u):i},u.context=function(n){return arguments.length?(null==n?o=a=null:a=t(o=n),u):o},u}const Cm=Xb(3);var Pm={draw(t,n){const e=.59436*Xb(n+jb(n/28,.75)),r=e/2,i=r*Cm;t.moveTo(0,e),t.lineTo(0,-e),t.moveTo(-i,-r),t.lineTo(i,r),t.moveTo(-i,r),t.lineTo(i,-r)}},zm={draw(t,n){const e=Xb(n/Vb);t.moveTo(e,0),t.arc(0,0,e,0,Wb)}},Dm={draw(t,n){const e=Xb(n/5)/2;t.moveTo(-3*e,-e),t.lineTo(-e,-e),t.lineTo(-e,-3*e),t.lineTo(e,-3*e),t.lineTo(e,-e),t.lineTo(3*e,-e),t.lineTo(3*e,e),t.lineTo(e,e),t.lineTo(e,3*e),t.lineTo(-e,3*e),t.lineTo(-e,e),t.lineTo(-3*e,e),t.closePath()}};const Rm=Xb(1/3),Fm=2*Rm;var qm={draw(t,n){const e=Xb(n/Fm),r=e*Rm;t.moveTo(0,-e),t.lineTo(r,0),t.lineTo(0,e),t.lineTo(-r,0),t.closePath()}},Om={draw(t,n){const e=.62625*Xb(n);t.moveTo(0,-e),t.lineTo(e,0),t.lineTo(0,e),t.lineTo(-e,0),t.closePath()}},Um={draw(t,n){const e=.87559*Xb(n-jb(n/7,2));t.moveTo(-e,0),t.lineTo(e,0),t.moveTo(0,e),t.lineTo(0,-e)}},Im={draw(t,n){const e=Xb(n),r=-e/2;t.rect(r,r,e,e)}},Bm={draw(t,n){const e=.4431*Xb(n);t.moveTo(e,e),t.lineTo(e,-e),t.lineTo(-e,-e),t.lineTo(-e,e),t.closePath()}};const Ym=Hb(Vb/10)/Hb(7*Vb/10),Lm=Hb(Wb/10)*Ym,jm=-Yb(Wb/10)*Ym;var Hm={draw(t,n){const e=Xb(.8908130915292852*n),r=Lm*e,i=jm*e;t.moveTo(0,-e),t.lineTo(r,i);for(let n=1;n<5;++n){const o=Wb*n/5,a=Yb(o),u=Hb(o);t.lineTo(u*e,-a*e),t.lineTo(a*r-u*i,u*r+a*i)}t.closePath()}};const Xm=Xb(3);var Gm={draw(t,n){const e=-Xb(n/(3*Xm));t.moveTo(0,2*e),t.lineTo(-Xm*e,-e),t.lineTo(Xm*e,-e),t.closePath()}};const Vm=Xb(3);var $m={draw(t,n){const e=.6824*Xb(n),r=e/2,i=e*Vm/2;t.moveTo(0,-e),t.lineTo(i,r),t.lineTo(-i,r),t.closePath()}};const Wm=-.5,Zm=Xb(3)/2,Km=1/Xb(12),Qm=3*(Km/2+1);var Jm={draw(t,n){const e=Xb(n/Qm),r=e/2,i=e*Km,o=r,a=e*Km+e,u=-o,c=a;t.moveTo(r,i),t.lineTo(o,a),t.lineTo(u,c),t.lineTo(Wm*r-Zm*i,Zm*r+Wm*i),t.lineTo(Wm*o-Zm*a,Zm*o+Wm*a),t.lineTo(Wm*u-Zm*c,Zm*u+Wm*c),t.lineTo(Wm*r+Zm*i,Wm*i-Zm*r),t.lineTo(Wm*o+Zm*a,Wm*a-Zm*o),t.lineTo(Wm*u+Zm*c,Wm*c-Zm*u),t.closePath()}},tx={draw(t,n){const e=.6189*Xb(n-jb(n/6,1.7));t.moveTo(-e,-e),t.lineTo(e,e),t.moveTo(-e,e),t.lineTo(e,-e)}};const nx=[zm,Dm,qm,Im,Hm,Gm,Jm],ex=[zm,Um,tx,$m,Pm,Bm,Om];function rx(){}function ix(t,n,e){t._context.bezierCurveTo((2*t._x0+t._x1)/3,(2*t._y0+t._y1)/3,(t._x0+2*t._x1)/3,(t._y0+2*t._y1)/3,(t._x0+4*t._x1+n)/6,(t._y0+4*t._y1+e)/6)}function ox(t){this._context=t}function ax(t){this._context=t}function ux(t){this._context=t}function cx(t,n){this._basis=new ox(t),this._beta=n}ox.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=NaN,this._point=0},lineEnd:function(){switch(this._point){case 3:ix(this,this._x1,this._y1);case 2:this._context.lineTo(this._x1,this._y1)}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;break;case 2:this._point=3,this._context.lineTo((5*this._x0+this._x1)/6,(5*this._y0+this._y1)/6);default:ix(this,t,n)}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=n}},ax.prototype={areaStart:rx,areaEnd:rx,lineStart:function(){this._x0=this._x1=this._x2=this._x3=this._x4=this._y0=this._y1=this._y2=this._y3=this._y4=NaN,this._point=0},lineEnd:function(){switch(this._point){case 1:this._context.moveTo(this._x2,this._y2),this._context.closePath();break;case 2:this._context.moveTo((this._x2+2*this._x3)/3,(this._y2+2*this._y3)/3),this._context.lineTo((this._x3+2*this._x2)/3,(this._y3+2*this._y2)/3),this._context.closePath();break;case 3:this.point(this._x2,this._y2),this.point(this._x3,this._y3),this.point(this._x4,this._y4)}},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._x2=t,this._y2=n;break;case 1:this._point=2,this._x3=t,this._y3=n;break;case 2:this._point=3,this._x4=t,this._y4=n,this._context.moveTo((this._x0+4*this._x1+t)/6,(this._y0+4*this._y1+n)/6);break;default:ix(this,t,n)}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=n}},ux.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=NaN,this._point=0},lineEnd:function(){(this._line||0!==this._line&&3===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3;var e=(this._x0+4*this._x1+t)/6,r=(this._y0+4*this._y1+n)/6;this._line?this._context.lineTo(e,r):this._context.moveTo(e,r);break;case 3:this._point=4;default:ix(this,t,n)}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=n}},cx.prototype={lineStart:function(){this._x=[],this._y=[],this._basis.lineStart()},lineEnd:function(){var t=this._x,n=this._y,e=t.length-1;if(e>0)for(var r,i=t[0],o=n[0],a=t[e]-i,u=n[e]-o,c=-1;++c<=e;)r=c/e,this._basis.point(this._beta*t[c]+(1-this._beta)*(i+r*a),this._beta*n[c]+(1-this._beta)*(o+r*u));this._x=this._y=null,this._basis.lineEnd()},point:function(t,n){this._x.push(+t),this._y.push(+n)}};var fx=function t(n){function e(t){return 1===n?new ox(t):new cx(t,n)}return e.beta=function(n){return t(+n)},e}(.85);function sx(t,n,e){t._context.bezierCurveTo(t._x1+t._k*(t._x2-t._x0),t._y1+t._k*(t._y2-t._y0),t._x2+t._k*(t._x1-n),t._y2+t._k*(t._y1-e),t._x2,t._y2)}function lx(t,n){this._context=t,this._k=(1-n)/6}lx.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x2,this._y2);break;case 3:sx(this,this._x1,this._y1)}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2,this._x1=t,this._y1=n;break;case 2:this._point=3;default:sx(this,t,n)}this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=n}};var hx=function t(n){function e(t){return new lx(t,n)}return e.tension=function(n){return t(+n)},e}(0);function dx(t,n){this._context=t,this._k=(1-n)/6}dx.prototype={areaStart:rx,areaEnd:rx,lineStart:function(){this._x0=this._x1=this._x2=this._x3=this._x4=this._x5=this._y0=this._y1=this._y2=this._y3=this._y4=this._y5=NaN,this._point=0},lineEnd:function(){switch(this._point){case 1:this._context.moveTo(this._x3,this._y3),this._context.closePath();break;case 2:this._context.lineTo(this._x3,this._y3),this._context.closePath();break;case 3:this.point(this._x3,this._y3),this.point(this._x4,this._y4),this.point(this._x5,this._y5)}},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._x3=t,this._y3=n;break;case 1:this._point=2,this._context.moveTo(this._x4=t,this._y4=n);break;case 2:this._point=3,this._x5=t,this._y5=n;break;default:sx(this,t,n)}this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=n}};var px=function t(n){function e(t){return new dx(t,n)}return e.tension=function(n){return t(+n)},e}(0);function gx(t,n){this._context=t,this._k=(1-n)/6}gx.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._point=0},lineEnd:function(){(this._line||0!==this._line&&3===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3,this._line?this._context.lineTo(this._x2,this._y2):this._context.moveTo(this._x2,this._y2);break;case 3:this._point=4;default:sx(this,t,n)}this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=n}};var yx=function t(n){function e(t){return new gx(t,n)}return e.tension=function(n){return t(+n)},e}(0);function vx(t,n,e){var r=t._x1,i=t._y1,o=t._x2,a=t._y2;if(t._l01_a>Gb){var u=2*t._l01_2a+3*t._l01_a*t._l12_a+t._l12_2a,c=3*t._l01_a*(t._l01_a+t._l12_a);r=(r*u-t._x0*t._l12_2a+t._x2*t._l01_2a)/c,i=(i*u-t._y0*t._l12_2a+t._y2*t._l01_2a)/c}if(t._l23_a>Gb){var f=2*t._l23_2a+3*t._l23_a*t._l12_a+t._l12_2a,s=3*t._l23_a*(t._l23_a+t._l12_a);o=(o*f+t._x1*t._l23_2a-n*t._l12_2a)/s,a=(a*f+t._y1*t._l23_2a-e*t._l12_2a)/s}t._context.bezierCurveTo(r,i,o,a,t._x2,t._y2)}function _x(t,n){this._context=t,this._alpha=n}_x.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x2,this._y2);break;case 3:this.point(this._x2,this._y2)}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){if(t=+t,n=+n,this._point){var e=this._x2-t,r=this._y2-n;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(e*e+r*r,this._alpha))}switch(this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;break;case 2:this._point=3;default:vx(this,t,n)}this._l01_a=this._l12_a,this._l12_a=this._l23_a,this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a,this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=n}};var bx=function t(n){function e(t){return n?new _x(t,n):new lx(t,0)}return e.alpha=function(n){return t(+n)},e}(.5);function mx(t,n){this._context=t,this._alpha=n}mx.prototype={areaStart:rx,areaEnd:rx,lineStart:function(){this._x0=this._x1=this._x2=this._x3=this._x4=this._x5=this._y0=this._y1=this._y2=this._y3=this._y4=this._y5=NaN,this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){switch(this._point){case 1:this._context.moveTo(this._x3,this._y3),this._context.closePath();break;case 2:this._context.lineTo(this._x3,this._y3),this._context.closePath();break;case 3:this.point(this._x3,this._y3),this.point(this._x4,this._y4),this.point(this._x5,this._y5)}},point:function(t,n){if(t=+t,n=+n,this._point){var e=this._x2-t,r=this._y2-n;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(e*e+r*r,this._alpha))}switch(this._point){case 0:this._point=1,this._x3=t,this._y3=n;break;case 1:this._point=2,this._context.moveTo(this._x4=t,this._y4=n);break;case 2:this._point=3,this._x5=t,this._y5=n;break;default:vx(this,t,n)}this._l01_a=this._l12_a,this._l12_a=this._l23_a,this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a,this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=n}};var xx=function t(n){function e(t){return n?new mx(t,n):new dx(t,0)}return e.alpha=function(n){return t(+n)},e}(.5);function wx(t,n){this._context=t,this._alpha=n}wx.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){(this._line||0!==this._line&&3===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){if(t=+t,n=+n,this._point){var e=this._x2-t,r=this._y2-n;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(e*e+r*r,this._alpha))}switch(this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3,this._line?this._context.lineTo(this._x2,this._y2):this._context.moveTo(this._x2,this._y2);break;case 3:this._point=4;default:vx(this,t,n)}this._l01_a=this._l12_a,this._l12_a=this._l23_a,this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a,this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=n}};var Mx=function t(n){function e(t){return n?new wx(t,n):new gx(t,0)}return e.alpha=function(n){return t(+n)},e}(.5);function Ax(t){this._context=t}function Tx(t){return t<0?-1:1}function Sx(t,n,e){var r=t._x1-t._x0,i=n-t._x1,o=(t._y1-t._y0)/(r||i<0&&-0),a=(e-t._y1)/(i||r<0&&-0),u=(o*i+a*r)/(r+i);return(Tx(o)+Tx(a))*Math.min(Math.abs(o),Math.abs(a),.5*Math.abs(u))||0}function Ex(t,n){var e=t._x1-t._x0;return e?(3*(t._y1-t._y0)/e-n)/2:n}function kx(t,n,e){var r=t._x0,i=t._y0,o=t._x1,a=t._y1,u=(o-r)/3;t._context.bezierCurveTo(r+u,i+u*n,o-u,a-u*e,o,a)}function Nx(t){this._context=t}function Cx(t){this._context=new Px(t)}function Px(t){this._context=t}function zx(t){this._context=t}function Dx(t){var n,e,r=t.length-1,i=new Array(r),o=new Array(r),a=new Array(r);for(i[0]=0,o[0]=2,a[0]=t[0]+2*t[1],n=1;n<r-1;++n)i[n]=1,o[n]=4,a[n]=4*t[n]+2*t[n+1];for(i[r-1]=2,o[r-1]=7,a[r-1]=8*t[r-1]+t[r],n=1;n<r;++n)e=i[n]/o[n-1],o[n]-=e,a[n]-=e*a[n-1];for(i[r-1]=a[r-1]/o[r-1],n=r-2;n>=0;--n)i[n]=(a[n]-i[n+1])/o[n];for(o[r-1]=(t[r]+i[r-1])/2,n=0;n<r-1;++n)o[n]=2*t[n+1]-i[n+1];return[i,o]}function Rx(t,n){this._context=t,this._t=n}function Fx(t,n){if((i=t.length)>1)for(var e,r,i,o=1,a=t[n[0]],u=a.length;o<i;++o)for(r=a,a=t[n[o]],e=0;e<u;++e)a[e][1]+=a[e][0]=isNaN(r[e][1])?r[e][0]:r[e][1]}function qx(t){for(var n=t.length,e=new Array(n);--n>=0;)e[n]=n;return e}function Ox(t,n){return t[n]}function Ux(t){const n=[];return n.key=t,n}function Ix(t){var n=t.map(Bx);return qx(t).sort((function(t,e){return n[t]-n[e]}))}function Bx(t){for(var n,e=-1,r=0,i=t.length,o=-1/0;++e<i;)(n=+t[e][1])>o&&(o=n,r=e);return r}function Yx(t){var n=t.map(Lx);return qx(t).sort((function(t,e){return n[t]-n[e]}))}function Lx(t){for(var n,e=0,r=-1,i=t.length;++r<i;)(n=+t[r][1])&&(e+=n);return e}Ax.prototype={areaStart:rx,areaEnd:rx,lineStart:function(){this._point=0},lineEnd:function(){this._point&&this._context.closePath()},point:function(t,n){t=+t,n=+n,this._point?this._context.lineTo(t,n):(this._point=1,this._context.moveTo(t,n))}},Nx.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=this._t0=NaN,this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x1,this._y1);break;case 3:kx(this,this._t0,Ex(this,this._t0))}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,n){var e=NaN;if(n=+n,(t=+t)!==this._x1||n!==this._y1){switch(this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;break;case 2:this._point=3,kx(this,Ex(this,e=Sx(this,t,n)),e);break;default:kx(this,this._t0,e=Sx(this,t,n))}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=n,this._t0=e}}},(Cx.prototype=Object.create(Nx.prototype)).point=function(t,n){Nx.prototype.point.call(this,n,t)},Px.prototype={moveTo:function(t,n){this._context.moveTo(n,t)},closePath:function(){this._context.closePath()},lineTo:function(t,n){this._context.lineTo(n,t)},bezierCurveTo:function(t,n,e,r,i,o){this._context.bezierCurveTo(n,t,r,e,o,i)}},zx.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x=[],this._y=[]},lineEnd:function(){var t=this._x,n=this._y,e=t.length;if(e)if(this._line?this._context.lineTo(t[0],n[0]):this._context.moveTo(t[0],n[0]),2===e)this._context.lineTo(t[1],n[1]);else for(var r=Dx(t),i=Dx(n),o=0,a=1;a<e;++o,++a)this._context.bezierCurveTo(r[0][o],i[0][o],r[1][o],i[1][o],t[a],n[a]);(this._line||0!==this._line&&1===e)&&this._context.closePath(),this._line=1-this._line,this._x=this._y=null},point:function(t,n){this._x.push(+t),this._y.push(+n)}},Rx.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x=this._y=NaN,this._point=0},lineEnd:function(){0<this._t&&this._t<1&&2===this._point&&this._context.lineTo(this._x,this._y),(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line>=0&&(this._t=1-this._t,this._line=1-this._line)},point:function(t,n){switch(t=+t,n=+n,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,n):this._context.moveTo(t,n);break;case 1:this._point=2;default:if(this._t<=0)this._context.lineTo(this._x,n),this._context.lineTo(t,n);else{var e=this._x*(1-this._t)+t*this._t;this._context.lineTo(e,this._y),this._context.lineTo(e,n)}}this._x=t,this._y=n}};var jx=t=>()=>t;function Hx(t,{sourceEvent:n,target:e,transform:r,dispatch:i}){Object.defineProperties(this,{type:{value:t,enumerable:!0,configurable:!0},sourceEvent:{value:n,enumerable:!0,configurable:!0},target:{value:e,enumerable:!0,configurable:!0},transform:{value:r,enumerable:!0,configurable:!0},_:{value:i}})}function Xx(t,n,e){this.k=t,this.x=n,this.y=e}Xx.prototype={constructor:Xx,scale:function(t){return 1===t?this:new Xx(this.k*t,this.x,this.y)},translate:function(t,n){return 0===t&0===n?this:new Xx(this.k,this.x+this.k*t,this.y+this.k*n)},apply:function(t){return[t[0]*this.k+this.x,t[1]*this.k+this.y]},applyX:function(t){return t*this.k+this.x},applyY:function(t){return t*this.k+this.y},invert:function(t){return[(t[0]-this.x)/this.k,(t[1]-this.y)/this.k]},invertX:function(t){return(t-this.x)/this.k},invertY:function(t){return(t-this.y)/this.k},rescaleX:function(t){return t.copy().domain(t.range().map(this.invertX,this).map(t.invert,t))},rescaleY:function(t){return t.copy().domain(t.range().map(this.invertY,this).map(t.invert,t))},toString:function(){return"translate("+this.x+","+this.y+") scale("+this.k+")"}};var Gx=new Xx(1,0,0);function Vx(t){for(;!t.__zoom;)if(!(t=t.parentNode))return Gx;return t.__zoom}function $x(t){t.stopImmediatePropagation()}function Wx(t){t.preventDefault(),t.stopImmediatePropagation()}function Zx(t){return!(t.ctrlKey&&"wheel"!==t.type||t.button)}function Kx(){var t=this;return t instanceof SVGElement?(t=t.ownerSVGElement||t).hasAttribute("viewBox")?[[(t=t.viewBox.baseVal).x,t.y],[t.x+t.width,t.y+t.height]]:[[0,0],[t.width.baseVal.value,t.height.baseVal.value]]:[[0,0],[t.clientWidth,t.clientHeight]]}function Qx(){return this.__zoom||Gx}function Jx(t){return-t.deltaY*(1===t.deltaMode?.05:t.deltaMode?1:.002)*(t.ctrlKey?10:1)}function tw(){return navigator.maxTouchPoints||"ontouchstart"in this}function nw(t,n,e){var r=t.invertX(n[0][0])-e[0][0],i=t.invertX(n[1][0])-e[1][0],o=t.invertY(n[0][1])-e[0][1],a=t.invertY(n[1][1])-e[1][1];return t.translate(i>r?(r+i)/2:Math.min(0,r)||Math.max(0,i),a>o?(o+a)/2:Math.min(0,o)||Math.max(0,a))}Vx.prototype=Xx.prototype,t.Adder=y,t.Delaunay=gu,t.FormatSpecifier=xc,t.InternMap=InternMap,t.InternSet=InternSet,t.Node=pd,t.Voronoi=fu,t.ZoomTransform=Xx,t.active=function(t,n){var e,r,i=t.__transition;if(i)for(r in n=null==n?null:n+"",i)if((e=i[r]).state>1&&e.name===n)return new Zi([[t]],To,n,+r);return null},t.arc=function(){var t=Qb,n=Jb,e=Ub(0),r=null,i=tm,o=nm,a=em,u=null;function c(){var c,f,s=+t.apply(this,arguments),l=+n.apply(this,arguments),h=i.apply(this,arguments)-$b,d=o.apply(this,arguments)-$b,p=Ib(d-h),g=d>h;if(u||(u=c=ya()),l<s&&(f=l,l=s,s=f),l>Gb)if(p>Wb-Gb)u.moveTo(l*Yb(h),l*Hb(h)),u.arc(0,0,l,h,d,!g),s>Gb&&(u.moveTo(s*Yb(d),s*Hb(d)),u.arc(0,0,s,d,h,g));else{var y,v,_=h,b=d,m=h,x=d,w=p,M=p,A=a.apply(this,arguments)/2,T=A>Gb&&(r?+r.apply(this,arguments):Xb(s*s+l*l)),S=jb(Ib(l-s)/2,+e.apply(this,arguments)),E=S,k=S;if(T>Gb){var N=Kb(T/s*Hb(A)),C=Kb(T/l*Hb(A));(w-=2*N)>Gb?(m+=N*=g?1:-1,x-=N):(w=0,m=x=(h+d)/2),(M-=2*C)>Gb?(_+=C*=g?1:-1,b-=C):(M=0,_=b=(h+d)/2)}var P=l*Yb(_),z=l*Hb(_),D=s*Yb(x),R=s*Hb(x);if(S>Gb){var F,q=l*Yb(b),O=l*Hb(b),U=s*Yb(m),I=s*Hb(m);if(p<Vb&&(F=rm(P,z,U,I,q,O,D,R))){var B=P-F[0],Y=z-F[1],L=q-F[0],j=O-F[1],H=1/Hb(Zb((B*L+Y*j)/(Xb(B*B+Y*Y)*Xb(L*L+j*j)))/2),X=Xb(F[0]*F[0]+F[1]*F[1]);E=jb(S,(s-X)/(H-1)),k=jb(S,(l-X)/(H+1))}}M>Gb?k>Gb?(y=im(U,I,P,z,l,k,g),v=im(q,O,D,R,l,k,g),u.moveTo(y.cx+y.x01,y.cy+y.y01),k<S?u.arc(y.cx,y.cy,k,Bb(y.y01,y.x01),Bb(v.y01,v.x01),!g):(u.arc(y.cx,y.cy,k,Bb(y.y01,y.x01),Bb(y.y11,y.x11),!g),u.arc(0,0,l,Bb(y.cy+y.y11,y.cx+y.x11),Bb(v.cy+v.y11,v.cx+v.x11),!g),u.arc(v.cx,v.cy,k,Bb(v.y11,v.x11),Bb(v.y01,v.x01),!g))):(u.moveTo(P,z),u.arc(0,0,l,_,b,!g)):u.moveTo(P,z),s>Gb&&w>Gb?E>Gb?(y=im(D,R,q,O,s,-E,g),v=im(P,z,U,I,s,-E,g),u.lineTo(y.cx+y.x01,y.cy+y.y01),E<S?u.arc(y.cx,y.cy,E,Bb(y.y01,y.x01),Bb(v.y01,v.x01),!g):(u.arc(y.cx,y.cy,E,Bb(y.y01,y.x01),Bb(y.y11,y.x11),!g),u.arc(0,0,s,Bb(y.cy+y.y11,y.cx+y.x11),Bb(v.cy+v.y11,v.cx+v.x11),g),u.arc(v.cx,v.cy,E,Bb(v.y11,v.x11),Bb(v.y01,v.x01),!g))):u.arc(0,0,s,x,m,g):u.lineTo(D,R)}else u.moveTo(0,0);if(u.closePath(),c)return u=null,c+""||null}return c.centroid=function(){var e=(+t.apply(this,arguments)+ +n.apply(this,arguments))/2,r=(+i.apply(this,arguments)+ +o.apply(this,arguments))/2-Vb/2;return[Yb(r)*e,Hb(r)*e]},c.innerRadius=function(n){return arguments.length?(t="function"==typeof n?n:Ub(+n),c):t},c.outerRadius=function(t){return arguments.length?(n="function"==typeof t?t:Ub(+t),c):n},c.cornerRadius=function(t){return arguments.length?(e="function"==typeof t?t:Ub(+t),c):e},c.padRadius=function(t){return arguments.length?(r=null==t?null:"function"==typeof t?t:Ub(+t),c):r},c.startAngle=function(t){return arguments.length?(i="function"==typeof t?t:Ub(+t),c):i},c.endAngle=function(t){return arguments.length?(o="function"==typeof t?t:Ub(+t),c):o},c.padAngle=function(t){return arguments.length?(a="function"==typeof t?t:Ub(+t),c):a},c.context=function(t){return arguments.length?(u=null==t?null:t,c):u},c},t.area=hm,t.areaRadial=mm,t.ascending=n,t.autoType=function(t){for(var n in t){var e,r,i=t[n].trim();if(i)if("true"===i)i=!0;else if("false"===i)i=!1;else if("NaN"===i)i=NaN;else if(isNaN(e=+i)){if(!(r=i.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)))continue;Iu&&r[4]&&!r[7]&&(i=i.replace(/-/g,"/").replace(/T/," ")),i=new Date(i)}else i=e;else i=null;t[n]=i}return t},t.axisBottom=function(t){return yt(3,t)},t.axisLeft=function(t){return yt(4,t)},t.axisRight=function(t){return yt(2,t)},t.axisTop=function(t){return yt(1,t)},t.bin=j,t.bisect=c,t.bisectCenter=u,t.bisectLeft=a,t.bisectRight=o,t.bisector=e,t.blob=function(t,n){return fetch(t,n).then(Bu)},t.brush=function(){return Jo(Yo)},t.brushSelection=function(t){var n=t.__brush;return n?n.dim.output(n.selection):null},t.brushX=function(){return Jo(Io)},t.brushY=function(){return Jo(Bo)},t.buffer=function(t,n){return fetch(t,n).then(Yu)},t.chord=function(){return sa(!1,!1)},t.chordDirected=function(){return sa(!0,!1)},t.chordTranspose=function(){return sa(!1,!0)},t.cluster=function(){var t=od,n=1,e=1,r=!1;function i(i){var o,a=0;i.eachAfter((function(n){var e=n.children;e?(n.x=function(t){return t.reduce(ad,0)/t.length}(e),n.y=function(t){return 1+t.reduce(ud,0)}(e)):(n.x=o?a+=t(n,o):0,n.y=0,o=n)}));var u=function(t){for(var n;n=t.children;)t=n[0];return t}(i),c=function(t){for(var n;n=t.children;)t=n[n.length-1];return t}(i),f=u.x-t(u,c)/2,s=c.x+t(c,u)/2;return i.eachAfter(r?function(t){t.x=(t.x-i.x)*n,t.y=(i.y-t.y)*e}:function(t){t.x=(t.x-f)/(s-f)*n,t.y=(1-(i.y?t.y/i.y:1))*e})}return i.separation=function(n){return arguments.length?(t=n,i):t},i.size=function(t){return arguments.length?(r=!1,n=+t[0],e=+t[1],i):r?null:[n,e]},i.nodeSize=function(t){return arguments.length?(r=!0,n=+t[0],e=+t[1],i):r?[n,e]:null},i},t.color=me,t.contourDensity=function(){var t=Ua,n=Ia,e=Ba,r=960,i=500,o=20,a=2,u=3*o,c=r+2*u>>a,f=i+2*u>>a,s=Na(20);function l(r){var i=new Float32Array(c*f),l=new Float32Array(c*f),d=Math.pow(2,-a);r.forEach((function(r,o,a){var s=(t(r,o,a)+u)*d,l=(n(r,o,a)+u)*d,h=+e(r,o,a);if(s>=0&&s<c&&l>=0&&l<f){var p=Math.floor(s),g=Math.floor(l),y=s-p-.5,v=l-g-.5;i[p+g*c]+=(1-y)*(1-v)*h,i[p+1+g*c]+=y*(1-v)*h,i[p+1+(g+1)*c]+=y*v*h,i[p+(g+1)*c]+=(1-y)*v*h}})),qa({width:c,height:f,data:i},{width:c,height:f,data:l},o>>a),Oa({width:c,height:f,data:l},{width:c,height:f,data:i},o>>a),qa({width:c,height:f,data:i},{width:c,height:f,data:l},o>>a),Oa({width:c,height:f,data:l},{width:c,height:f,data:i},o>>a),qa({width:c,height:f,data:i},{width:c,height:f,data:l},o>>a),Oa({width:c,height:f,data:l},{width:c,height:f,data:i},o>>a);var p=s(i);if(!Array.isArray(p)){var g=H(i);p=B(0,g,p),(p=tt(0,Math.floor(g/p)*p,p)).shift()}return Fa().thresholds(p).size([c,f])(i).map(h)}function h(t){return t.value*=Math.pow(2,-2*a),t.coordinates.forEach(d),t}function d(t){t.forEach(p)}function p(t){t.forEach(g)}function g(t){t[0]=t[0]*Math.pow(2,a)-u,t[1]=t[1]*Math.pow(2,a)-u}function y(){return c=r+2*(u=3*o)>>a,f=i+2*u>>a,l}return l.x=function(n){return arguments.length?(t="function"==typeof n?n:Na(+n),l):t},l.y=function(t){return arguments.length?(n="function"==typeof t?t:Na(+t),l):n},l.weight=function(t){return arguments.length?(e="function"==typeof t?t:Na(+t),l):e},l.size=function(t){if(!arguments.length)return[r,i];var n=+t[0],e=+t[1];if(!(n>=0&&e>=0))throw new Error("invalid size");return r=n,i=e,y()},l.cellSize=function(t){if(!arguments.length)return 1<<a;if(!((t=+t)>=1))throw new Error("invalid cell size");return a=Math.floor(Math.log(t)/Math.LN2),y()},l.thresholds=function(t){return arguments.length?(s="function"==typeof t?t:Array.isArray(t)?Na(Ea.call(t)):Na(t),l):s},l.bandwidth=function(t){if(!arguments.length)return Math.sqrt(o*(o+1));if(!((t=+t)>=0))throw new Error("invalid bandwidth");return o=Math.round((Math.sqrt(4*t*t+1)-1)/2),y()},l},t.contours=Fa,t.count=f,t.create=function(t){return Un(kt(t).call(document.documentElement))},t.creator=kt,t.cross=function(...t){const n="function"==typeof t[t.length-1]&&function(t){return n=>t(...n)}(t.pop()),e=(t=t.map(h)).map(s),r=t.length-1,i=new Array(r+1).fill(0),o=[];if(r<0||e.some(l))return o;for(;;){o.push(i.map(((n,e)=>t[e][n])));let a=r;for(;++i[a]===e[a];){if(0===a)return n?o.map(n):o;i[a--]=0}}},t.csv=Xu,t.csvFormat=Su,t.csvFormatBody=Eu,t.csvFormatRow=Nu,t.csvFormatRows=ku,t.csvFormatValue=Cu,t.csvParse=Au,t.csvParseRows=Tu,t.cubehelix=ur,t.cumsum=function(t,n){var e=0,r=0;return Float64Array.from(t,void 0===n?t=>e+=+t||0:i=>e+=+n(i,r++,t)||0)},t.curveBasis=function(t){return new ox(t)},t.curveBasisClosed=function(t){return new ax(t)},t.curveBasisOpen=function(t){return new ux(t)},t.curveBumpX=Am,t.curveBumpY=Tm,t.curveBundle=fx,t.curveCardinal=hx,t.curveCardinalClosed=px,t.curveCardinalOpen=yx,t.curveCatmullRom=bx,t.curveCatmullRomClosed=xx,t.curveCatmullRomOpen=Mx,t.curveLinear=cm,t.curveLinearClosed=function(t){return new Ax(t)},t.curveMonotoneX=function(t){return new Nx(t)},t.curveMonotoneY=function(t){return new Cx(t)},t.curveNatural=function(t){return new zx(t)},t.curveStep=function(t){return new Rx(t,.5)},t.curveStepAfter=function(t){return new Rx(t,1)},t.curveStepBefore=function(t){return new Rx(t,0)},t.descending=function(t,n){return null==t||null==n?NaN:n<t?-1:n>t?1:n>=t?0:NaN},t.deviation=p,t.difference=function(t,...n){t=new InternSet(t);for(const e of n)for(const n of e)t.delete(n);return t},t.disjoint=function(t,n){const e=n[Symbol.iterator](),r=new InternSet;for(const n of t){if(r.has(n))return!1;let t,i;for(;({value:t,done:i}=e.next())&&!i;){if(Object.is(n,t))return!1;r.add(t)}}return!0},t.dispatch=_t,t.drag=function(){var t,n,e,r,i=Qn,o=Jn,a=te,u=ne,c={},f=_t("start","drag","end"),s=0,l=0;function h(t){t.on("mousedown.drag",d).filter(u).on("touchstart.drag",y).on("touchmove.drag",v,Hn).on("touchend.drag touchcancel.drag",_).style("touch-action","none").style("-webkit-tap-highlight-color","rgba(0,0,0,0)")}function d(a,u){if(!r&&i.call(this,a,u)){var c=b(this,o.call(this,a,u),a,u,"mouse");c&&(Un(a.view).on("mousemove.drag",p,Xn).on("mouseup.drag",g,Xn),$n(a.view),Gn(a),e=!1,t=a.clientX,n=a.clientY,c("start",a))}}function p(r){if(Vn(r),!e){var i=r.clientX-t,o=r.clientY-n;e=i*i+o*o>l}c.mouse("drag",r)}function g(t){Un(t.view).on("mousemove.drag mouseup.drag",null),Wn(t.view,e),Vn(t),c.mouse("end",t)}function y(t,n){if(i.call(this,t,n)){var e,r,a=t.changedTouches,u=o.call(this,t,n),c=a.length;for(e=0;e<c;++e)(r=b(this,u,t,n,a[e].identifier,a[e]))&&(Gn(t),r("start",t,a[e]))}}function v(t){var n,e,r=t.changedTouches,i=r.length;for(n=0;n<i;++n)(e=c[r[n].identifier])&&(Vn(t),e("drag",t,r[n]))}function _(t){var n,e,i=t.changedTouches,o=i.length;for(r&&clearTimeout(r),r=setTimeout((function(){r=null}),500),n=0;n<o;++n)(e=c[i[n].identifier])&&(Gn(t),e("end",t,i[n]))}function b(t,n,e,r,i,o){var u,l,d,p=f.copy(),g=jn(o||e,n);if(null!=(d=a.call(t,new Kn("beforestart",{sourceEvent:e,target:h,identifier:i,active:s,x:g[0],y:g[1],dx:0,dy:0,dispatch:p}),r)))return u=d.x-g[0]||0,l=d.y-g[1]||0,function e(o,a,f){var y,v=g;switch(o){case"start":c[i]=e,y=s++;break;case"end":delete c[i],--s;case"drag":g=jn(f||a,n),y=s}p.call(o,t,new Kn(o,{sourceEvent:a,subject:d,target:h,identifier:i,active:y,x:g[0]+u,y:g[1]+l,dx:g[0]-v[0],dy:g[1]-v[1],dispatch:p}),r)}}return h.filter=function(t){return arguments.length?(i="function"==typeof t?t:Zn(!!t),h):i},h.container=function(t){return arguments.length?(o="function"==typeof t?t:Zn(t),h):o},h.subject=function(t){return arguments.length?(a="function"==typeof t?t:Zn(t),h):a},h.touchable=function(t){return arguments.length?(u="function"==typeof t?t:Zn(!!t),h):u},h.on=function(){var t=f.on.apply(f,arguments);return t===f?h:t},h.clickDistance=function(t){return arguments.length?(l=(t=+t)*t,h):Math.sqrt(l)},h},t.dragDisable=$n,t.dragEnable=Wn,t.dsv=function(t,n,e,r){3===arguments.length&&"function"==typeof e&&(r=e,e=void 0);var i=wu(t);return ju(n,e).then((function(t){return i.parse(t,r)}))},t.dsvFormat=wu,t.easeBack=_o,t.easeBackIn=yo,t.easeBackInOut=_o,t.easeBackOut=vo,t.easeBounce=po,t.easeBounceIn=function(t){return 1-po(1-t)},t.easeBounceInOut=function(t){return((t*=2)<=1?1-po(1-t):po(t-1)+1)/2},t.easeBounceOut=po,t.easeCircle=so,t.easeCircleIn=function(t){return 1-Math.sqrt(1-t*t)},t.easeCircleInOut=so,t.easeCircleOut=function(t){return Math.sqrt(1- --t*t)},t.easeCubic=no,t.easeCubicIn=function(t){return t*t*t},t.easeCubicInOut=no,t.easeCubicOut=function(t){return--t*t*t+1},t.easeElastic=xo,t.easeElasticIn=mo,t.easeElasticInOut=wo,t.easeElasticOut=xo,t.easeExp=fo,t.easeExpIn=function(t){return co(1-+t)},t.easeExpInOut=fo,t.easeExpOut=function(t){return 1-co(t)},t.easeLinear=t=>+t,t.easePoly=io,t.easePolyIn=eo,t.easePolyInOut=io,t.easePolyOut=ro,t.easeQuad=to,t.easeQuadIn=function(t){return t*t},t.easeQuadInOut=to,t.easeQuadOut=function(t){return t*(2-t)},t.easeSin=uo,t.easeSinIn=function(t){return 1==+t?1:1-Math.cos(t*ao)},t.easeSinInOut=uo,t.easeSinOut=function(t){return Math.sin(t*ao)},t.every=function(t,n){if("function"!=typeof n)throw new TypeError("test is not a function");let e=-1;for(const r of t)if(!n(r,++e,t))return!1;return!0},t.extent=g,t.fcumsum=function(t,n){const e=new y;let r=-1;return Float64Array.from(t,void 0===n?t=>e.add(+t||0):i=>e.add(+n(i,++r,t)||0))},t.filter=function(t,n){if("function"!=typeof n)throw new TypeError("test is not a function");const e=[];let r=-1;for(const i of t)n(i,++r,t)&&e.push(i);return e},t.flatGroup=function(t,...n){return A(M(t,...n),n)},t.flatRollup=function(t,n,...e){return A(S(t,n,...e),e)},t.forceCenter=function(t,n){var e,r=1;function i(){var i,o,a=e.length,u=0,c=0;for(i=0;i<a;++i)u+=(o=e[i]).x,c+=o.y;for(u=(u/a-t)*r,c=(c/a-n)*r,i=0;i<a;++i)(o=e[i]).x-=u,o.y-=c}return null==t&&(t=0),null==n&&(n=0),i.initialize=function(t){e=t},i.x=function(n){return arguments.length?(t=+n,i):t},i.y=function(t){return arguments.length?(n=+t,i):n},i.strength=function(t){return arguments.length?(r=+t,i):r},i},t.forceCollide=function(t){var n,e,r,i=1,o=1;function a(){for(var t,a,c,f,s,l,h,d=n.length,p=0;p<o;++p)for(a=ec(n,cc,fc).visitAfter(u),t=0;t<d;++t)c=n[t],l=e[c.index],h=l*l,f=c.x+c.vx,s=c.y+c.vy,a.visit(g);function g(t,n,e,o,a){var u=t.data,d=t.r,p=l+d;if(!u)return n>f+p||o<f-p||e>s+p||a<s-p;if(u.index>c.index){var g=f-u.x-u.vx,y=s-u.y-u.vy,v=g*g+y*y;v<p*p&&(0===g&&(v+=(g=uc(r))*g),0===y&&(v+=(y=uc(r))*y),v=(p-(v=Math.sqrt(v)))/v*i,c.vx+=(g*=v)*(p=(d*=d)/(h+d)),c.vy+=(y*=v)*p,u.vx-=g*(p=1-p),u.vy-=y*p)}}}function u(t){if(t.data)return t.r=e[t.data.index];for(var n=t.r=0;n<4;++n)t[n]&&t[n].r>t.r&&(t.r=t[n].r)}function c(){if(n){var r,i,o=n.length;for(e=new Array(o),r=0;r<o;++r)i=n[r],e[i.index]=+t(i,r,n)}}return"function"!=typeof t&&(t=ac(null==t?1:+t)),a.initialize=function(t,e){n=t,r=e,c()},a.iterations=function(t){return arguments.length?(o=+t,a):o},a.strength=function(t){return arguments.length?(i=+t,a):i},a.radius=function(n){return arguments.length?(t="function"==typeof n?n:ac(+n),c(),a):t},a},t.forceLink=function(t){var n,e,r,i,o,a,u=sc,c=function(t){return 1/Math.min(i[t.source.index],i[t.target.index])},f=ac(30),s=1;function l(r){for(var i=0,u=t.length;i<s;++i)for(var c,f,l,h,d,p,g,y=0;y<u;++y)f=(c=t[y]).source,h=(l=c.target).x+l.vx-f.x-f.vx||uc(a),d=l.y+l.vy-f.y-f.vy||uc(a),h*=p=((p=Math.sqrt(h*h+d*d))-e[y])/p*r*n[y],d*=p,l.vx-=h*(g=o[y]),l.vy-=d*g,f.vx+=h*(g=1-g),f.vy+=d*g}function h(){if(r){var a,c,f=r.length,s=t.length,l=new Map(r.map(((t,n)=>[u(t,n,r),t])));for(a=0,i=new Array(f);a<s;++a)(c=t[a]).index=a,"object"!=typeof c.source&&(c.source=lc(l,c.source)),"object"!=typeof c.target&&(c.target=lc(l,c.target)),i[c.source.index]=(i[c.source.index]||0)+1,i[c.target.index]=(i[c.target.index]||0)+1;for(a=0,o=new Array(s);a<s;++a)c=t[a],o[a]=i[c.source.index]/(i[c.source.index]+i[c.target.index]);n=new Array(s),d(),e=new Array(s),p()}}function d(){if(r)for(var e=0,i=t.length;e<i;++e)n[e]=+c(t[e],e,t)}function p(){if(r)for(var n=0,i=t.length;n<i;++n)e[n]=+f(t[n],n,t)}return null==t&&(t=[]),l.initialize=function(t,n){r=t,a=n,h()},l.links=function(n){return arguments.length?(t=n,h(),l):t},l.id=function(t){return arguments.length?(u=t,l):u},l.iterations=function(t){return arguments.length?(s=+t,l):s},l.strength=function(t){return arguments.length?(c="function"==typeof t?t:ac(+t),d(),l):c},l.distance=function(t){return arguments.length?(f="function"==typeof t?t:ac(+t),p(),l):f},l},t.forceManyBody=function(){var t,n,e,r,i,o=ac(-30),a=1,u=1/0,c=.81;function f(e){var i,o=t.length,a=ec(t,dc,pc).visitAfter(l);for(r=e,i=0;i<o;++i)n=t[i],a.visit(h)}function s(){if(t){var n,e,r=t.length;for(i=new Array(r),n=0;n<r;++n)e=t[n],i[e.index]=+o(e,n,t)}}function l(t){var n,e,r,o,a,u=0,c=0;if(t.length){for(r=o=a=0;a<4;++a)(n=t[a])&&(e=Math.abs(n.value))&&(u+=n.value,c+=e,r+=e*n.x,o+=e*n.y);t.x=r/c,t.y=o/c}else{(n=t).x=n.data.x,n.y=n.data.y;do{u+=i[n.data.index]}while(n=n.next)}t.value=u}function h(t,o,f,s){if(!t.value)return!0;var l=t.x-n.x,h=t.y-n.y,d=s-o,p=l*l+h*h;if(d*d/c<p)return p<u&&(0===l&&(p+=(l=uc(e))*l),0===h&&(p+=(h=uc(e))*h),p<a&&(p=Math.sqrt(a*p)),n.vx+=l*t.value*r/p,n.vy+=h*t.value*r/p),!0;if(!(t.length||p>=u)){(t.data!==n||t.next)&&(0===l&&(p+=(l=uc(e))*l),0===h&&(p+=(h=uc(e))*h),p<a&&(p=Math.sqrt(a*p)));do{t.data!==n&&(d=i[t.data.index]*r/p,n.vx+=l*d,n.vy+=h*d)}while(t=t.next)}}return f.initialize=function(n,r){t=n,e=r,s()},f.strength=function(t){return arguments.length?(o="function"==typeof t?t:ac(+t),s(),f):o},f.distanceMin=function(t){return arguments.length?(a=t*t,f):Math.sqrt(a)},f.distanceMax=function(t){return arguments.length?(u=t*t,f):Math.sqrt(u)},f.theta=function(t){return arguments.length?(c=t*t,f):Math.sqrt(c)},f},t.forceRadial=function(t,n,e){var r,i,o,a=ac(.1);function u(t){for(var a=0,u=r.length;a<u;++a){var c=r[a],f=c.x-n||1e-6,s=c.y-e||1e-6,l=Math.sqrt(f*f+s*s),h=(o[a]-l)*i[a]*t/l;c.vx+=f*h,c.vy+=s*h}}function c(){if(r){var n,e=r.length;for(i=new Array(e),o=new Array(e),n=0;n<e;++n)o[n]=+t(r[n],n,r),i[n]=isNaN(o[n])?0:+a(r[n],n,r)}}return"function"!=typeof t&&(t=ac(+t)),null==n&&(n=0),null==e&&(e=0),u.initialize=function(t){r=t,c()},u.strength=function(t){return arguments.length?(a="function"==typeof t?t:ac(+t),c(),u):a},u.radius=function(n){return arguments.length?(t="function"==typeof n?n:ac(+n),c(),u):t},u.x=function(t){return arguments.length?(n=+t,u):n},u.y=function(t){return arguments.length?(e=+t,u):e},u},t.forceSimulation=function(t){var n,e=1,r=.001,i=1-Math.pow(r,1/300),o=0,a=.6,u=new Map,c=si(l),f=_t("tick","end"),s=function(){let t=1;return()=>(t=(1664525*t+1013904223)%hc)/hc}();function l(){h(),f.call("tick",n),e<r&&(c.stop(),f.call("end",n))}function h(r){var c,f,s=t.length;void 0===r&&(r=1);for(var l=0;l<r;++l)for(e+=(o-e)*i,u.forEach((function(t){t(e)})),c=0;c<s;++c)null==(f=t[c]).fx?f.x+=f.vx*=a:(f.x=f.fx,f.vx=0),null==f.fy?f.y+=f.vy*=a:(f.y=f.fy,f.vy=0);return n}function d(){for(var n,e=0,r=t.length;e<r;++e){if((n=t[e]).index=e,null!=n.fx&&(n.x=n.fx),null!=n.fy&&(n.y=n.fy),isNaN(n.x)||isNaN(n.y)){var i=10*Math.sqrt(.5+e),o=e*gc;n.x=i*Math.cos(o),n.y=i*Math.sin(o)}(isNaN(n.vx)||isNaN(n.vy))&&(n.vx=n.vy=0)}}function p(n){return n.initialize&&n.initialize(t,s),n}return null==t&&(t=[]),d(),n={tick:h,restart:function(){return c.restart(l),n},stop:function(){return c.stop(),n},nodes:function(e){return arguments.length?(t=e,d(),u.forEach(p),n):t},alpha:function(t){return arguments.length?(e=+t,n):e},alphaMin:function(t){return arguments.length?(r=+t,n):r},alphaDecay:function(t){return arguments.length?(i=+t,n):+i},alphaTarget:function(t){return arguments.length?(o=+t,n):o},velocityDecay:function(t){return arguments.length?(a=1-t,n):1-a},randomSource:function(t){return arguments.length?(s=t,u.forEach(p),n):s},force:function(t,e){return arguments.length>1?(null==e?u.delete(t):u.set(t,p(e)),n):u.get(t)},find:function(n,e,r){var i,o,a,u,c,f=0,s=t.length;for(null==r?r=1/0:r*=r,f=0;f<s;++f)(a=(i=n-(u=t[f]).x)*i+(o=e-u.y)*o)<r&&(c=u,r=a);return c},on:function(t,e){return arguments.length>1?(f.on(t,e),n):f.on(t)}}},t.forceX=function(t){var n,e,r,i=ac(.1);function o(t){for(var i,o=0,a=n.length;o<a;++o)(i=n[o]).vx+=(r[o]-i.x)*e[o]*t}function a(){if(n){var o,a=n.length;for(e=new Array(a),r=new Array(a),o=0;o<a;++o)e[o]=isNaN(r[o]=+t(n[o],o,n))?0:+i(n[o],o,n)}}return"function"!=typeof t&&(t=ac(null==t?0:+t)),o.initialize=function(t){n=t,a()},o.strength=function(t){return arguments.length?(i="function"==typeof t?t:ac(+t),a(),o):i},o.x=function(n){return arguments.length?(t="function"==typeof n?n:ac(+n),a(),o):t},o},t.forceY=function(t){var n,e,r,i=ac(.1);function o(t){for(var i,o=0,a=n.length;o<a;++o)(i=n[o]).vy+=(r[o]-i.y)*e[o]*t}function a(){if(n){var o,a=n.length;for(e=new Array(a),r=new Array(a),o=0;o<a;++o)e[o]=isNaN(r[o]=+t(n[o],o,n))?0:+i(n[o],o,n)}}return"function"!=typeof t&&(t=ac(null==t?0:+t)),o.initialize=function(t){n=t,a()},o.strength=function(t){return arguments.length?(i="function"==typeof t?t:ac(+t),a(),o):i},o.y=function(n){return arguments.length?(t="function"==typeof n?n:ac(+n),a(),o):t},o},t.formatDefaultLocale=Nc,t.formatLocale=kc,t.formatSpecifier=mc,t.fsum=function(t,n){const e=new y;if(void 0===n)for(let n of t)(n=+n)&&e.add(n);else{let r=-1;for(let i of t)(i=+n(i,++r,t))&&e.add(i)}return+e},t.geoAlbers=Oh,t.geoAlbersUsa=function(){var t,n,e,r,i,o,a=Oh(),u=qh().rotate([154,0]).center([-2,58.5]).parallels([55,65]),c=qh().rotate([157,0]).center([-3,19.9]).parallels([8,18]),f={point:function(t,n){o=[t,n]}};function s(t){var n=t[0],a=t[1];return o=null,e.point(n,a),o||(r.point(n,a),o)||(i.point(n,a),o)}function l(){return t=n=null,s}return s.invert=function(t){var n=a.scale(),e=a.translate(),r=(t[0]-e[0])/n,i=(t[1]-e[1])/n;return(i>=.12&&i<.234&&r>=-.425&&r<-.214?u:i>=.166&&i<.234&&r>=-.214&&r<-.115?c:a).invert(t)},s.stream=function(e){return t&&n===e?t:(r=[a.stream(n=e),u.stream(e),c.stream(e)],i=r.length,t={point:function(t,n){for(var e=-1;++e<i;)r[e].point(t,n)},sphere:function(){for(var t=-1;++t<i;)r[t].sphere()},lineStart:function(){for(var t=-1;++t<i;)r[t].lineStart()},lineEnd:function(){for(var t=-1;++t<i;)r[t].lineEnd()},polygonStart:function(){for(var t=-1;++t<i;)r[t].polygonStart()},polygonEnd:function(){for(var t=-1;++t<i;)r[t].polygonEnd()}});var r,i},s.precision=function(t){return arguments.length?(a.precision(t),u.precision(t),c.precision(t),l()):a.precision()},s.scale=function(t){return arguments.length?(a.scale(t),u.scale(.35*t),c.scale(t),s.translate(a.translate())):a.scale()},s.translate=function(t){if(!arguments.length)return a.translate();var n=a.scale(),o=+t[0],s=+t[1];return e=a.translate(t).clipExtent([[o-.455*n,s-.238*n],[o+.455*n,s+.238*n]]).stream(f),r=u.translate([o-.307*n,s+.201*n]).clipExtent([[o-.425*n+Dc,s+.12*n+Dc],[o-.214*n-Dc,s+.234*n-Dc]]).stream(f),i=c.translate([o-.205*n,s+.212*n]).clipExtent([[o-.214*n+Dc,s+.166*n+Dc],[o-.115*n-Dc,s+.234*n-Dc]]).stream(f),l()},s.fitExtent=function(t,n){return Ah(s,t,n)},s.fitSize=function(t,n){return Th(s,t,n)},s.fitWidth=function(t,n){return Sh(s,t,n)},s.fitHeight=function(t,n){return Eh(s,t,n)},s.scale(1070)},t.geoArea=function(t){return kf=new y,sf(t,Nf),2*kf},t.geoAzimuthalEqualArea=function(){return zh(Bh).scale(124.75).clipAngle(179.999)},t.geoAzimuthalEqualAreaRaw=Bh,t.geoAzimuthalEquidistant=function(){return zh(Yh).scale(79.4188).clipAngle(179.999)},t.geoAzimuthalEquidistantRaw=Yh,t.geoBounds=function(t){var n,e,r,i,o,a,u;if(bf=_f=-(yf=vf=1/0),Tf=[],sf(t,rs),e=Tf.length){for(Tf.sort(hs),n=1,o=[r=Tf[0]];n<e;++n)ds(r,(i=Tf[n])[0])||ds(r,i[1])?(ls(r[0],i[1])>ls(r[0],r[1])&&(r[1]=i[1]),ls(i[0],r[1])>ls(r[0],r[1])&&(r[0]=i[0])):o.push(r=i);for(a=-1/0,n=0,r=o[e=o.length-1];n<=e;r=i,++n)i=o[n],(u=ls(r[1],i[0]))>a&&(a=u,yf=i[0],_f=r[1])}return Tf=Sf=null,yf===1/0||vf===1/0?[[NaN,NaN],[NaN,NaN]]:[[yf,vf],[_f,bf]]},t.geoCentroid=function(t){Yf=Lf=jf=Hf=Xf=Gf=Vf=$f=0,Wf=new y,Zf=new y,Kf=new y,sf(t,ps);var n=+Wf,e=+Zf,r=+Kf,i=Vc(n,e,r);return i<Rc&&(n=Gf,e=Vf,r=$f,Lf<Dc&&(n=jf,e=Hf,r=Xf),(i=Vc(n,e,r))<Rc)?[NaN,NaN]:[jc(e,n)*Ic,nf(r/i)*Ic]},t.geoCircle=function(){var t,n,e=Ts([0,0]),r=Ts(90),i=Ts(6),o={point:function(e,r){t.push(e=n(e,r)),e[0]*=Ic,e[1]*=Ic}};function a(){var a=e.apply(this,arguments),u=r.apply(this,arguments)*Bc,c=i.apply(this,arguments)*Bc;return t=[],n=ks(-a[0]*Bc,-a[1]*Bc,0).invert,Ds(o,u,c,1),a={type:"Polygon",coordinates:[t]},t=n=null,a}return a.center=function(t){return arguments.length?(e="function"==typeof t?t:Ts([+t[0],+t[1]]),a):e},a.radius=function(t){return arguments.length?(r="function"==typeof t?t:Ts(+t),a):r},a.precision=function(t){return arguments.length?(i="function"==typeof t?t:Ts(+t),a):i},a},t.geoClipAntimeridian=Xs,t.geoClipCircle=Gs,t.geoClipExtent=function(){var t,n,e,r=0,i=0,o=960,a=500;return e={stream:function(e){return t&&n===e?t:t=Js(r,i,o,a)(n=e)},extent:function(u){return arguments.length?(r=+u[0][0],i=+u[0][1],o=+u[1][0],a=+u[1][1],t=n=null,e):[[r,i],[o,a]]}}},t.geoClipRectangle=Js,t.geoConicConformal=function(){return Rh(Xh).scale(109.5).parallels([30,30])},t.geoConicConformalRaw=Xh,t.geoConicEqualArea=qh,t.geoConicEqualAreaRaw=Fh,t.geoConicEquidistant=function(){return Rh(Vh).scale(131.154).center([0,13.9389])},t.geoConicEquidistantRaw=Vh,t.geoContains=function(t,n){return(t&&cl.hasOwnProperty(t.type)?cl[t.type]:sl)(t,n)},t.geoDistance=ul,t.geoEqualEarth=function(){return zh(Jh).scale(177.158)},t.geoEqualEarthRaw=Jh,t.geoEquirectangular=function(){return zh(Gh).scale(152.63)},t.geoEquirectangularRaw=Gh,t.geoGnomonic=function(){return zh(td).scale(144.049).clipAngle(60)},t.geoGnomonicRaw=td,t.geoGraticule=_l,t.geoGraticule10=function(){return _l()()},t.geoIdentity=function(){var t,n,e,r,i,o,a,u=1,c=0,f=0,s=1,l=1,h=0,d=null,p=1,g=1,y=xh({point:function(t,n){var e=b([t,n]);this.stream.point(e[0],e[1])}}),v=Ml;function _(){return p=u*s,g=u*l,o=a=null,b}function b(e){var r=e[0]*p,i=e[1]*g;if(h){var o=i*t-r*n;r=r*t+i*n,i=o}return[r+c,i+f]}return b.invert=function(e){var r=e[0]-c,i=e[1]-f;if(h){var o=i*t+r*n;r=r*t-i*n,i=o}return[r/p,i/g]},b.stream=function(t){return o&&a===t?o:o=y(v(a=t))},b.postclip=function(t){return arguments.length?(v=t,d=e=r=i=null,_()):v},b.clipExtent=function(t){return arguments.length?(v=null==t?(d=e=r=i=null,Ml):Js(d=+t[0][0],e=+t[0][1],r=+t[1][0],i=+t[1][1]),_()):null==d?null:[[d,e],[r,i]]},b.scale=function(t){return arguments.length?(u=+t,_()):u},b.translate=function(t){return arguments.length?(c=+t[0],f=+t[1],_()):[c,f]},b.angle=function(e){return arguments.length?(n=Zc(h=e%360*Bc),t=Hc(h),_()):h*Ic},b.reflectX=function(t){return arguments.length?(s=t?-1:1,_()):s<0},b.reflectY=function(t){return arguments.length?(l=t?-1:1,_()):l<0},b.fitExtent=function(t,n){return Ah(b,t,n)},b.fitSize=function(t,n){return Th(b,t,n)},b.fitWidth=function(t,n){return Sh(b,t,n)},b.fitHeight=function(t,n){return Eh(b,t,n)},b},t.geoInterpolate=function(t,n){var e=t[0]*Bc,r=t[1]*Bc,i=n[0]*Bc,o=n[1]*Bc,a=Hc(r),u=Zc(r),c=Hc(o),f=Zc(o),s=a*Hc(e),l=a*Zc(e),h=c*Hc(i),d=c*Zc(i),p=2*nf(Qc(ef(o-r)+a*c*ef(i-e))),g=Zc(p),y=p?function(t){var n=Zc(t*=p)/g,e=Zc(p-t)/g,r=e*s+n*h,i=e*l+n*d,o=e*u+n*f;return[jc(i,r)*Ic,jc(o,Qc(r*r+i*i))*Ic]}:function(){return[e*Ic,r*Ic]};return y.distance=p,y},t.geoLength=il,t.geoMercator=function(){return jh(Lh).scale(961/Uc)},t.geoMercatorRaw=Lh,t.geoNaturalEarth1=function(){return zh(nd).scale(175.295)},t.geoNaturalEarth1Raw=nd,t.geoOrthographic=function(){return zh(ed).scale(249.5).clipAngle(90.000001)},t.geoOrthographicRaw=ed,t.geoPath=function(t,n){var e,r,i=4.5;function o(t){return t&&("function"==typeof i&&r.pointRadius(+i.apply(this,arguments)),sf(t,e(r))),r.result()}return o.area=function(t){return sf(t,e(Pl)),Pl.result()},o.measure=function(t){return sf(t,e(_h)),_h.result()},o.bounds=function(t){return sf(t,e(Yl)),Yl.result()},o.centroid=function(t){return sf(t,e(uh)),uh.result()},o.projection=function(n){return arguments.length?(e=null==n?(t=null,Ml):(t=n).stream,o):t},o.context=function(t){return arguments.length?(r=null==t?(n=null,new bh):new ch(n=t),"function"!=typeof i&&r.pointRadius(i),o):n},o.pointRadius=function(t){return arguments.length?(i="function"==typeof t?t:(r.pointRadius(+t),+t),o):i},o.projection(t).context(n)},t.geoProjection=zh,t.geoProjectionMutator=Dh,t.geoRotation=zs,t.geoStereographic=function(){return zh(rd).scale(250).clipAngle(142)},t.geoStereographicRaw=rd,t.geoStream=sf,t.geoTransform=function(t){return{stream:xh(t)}},t.geoTransverseMercator=function(){var t=jh(id),n=t.center,e=t.rotate;return t.center=function(t){return arguments.length?n([-t[1],t[0]]):[(t=n())[1],-t[0]]},t.rotate=function(t){return arguments.length?e([t[0],t[1],t.length>2?t[2]+90:90]):[(t=e())[0],t[1],t[2]-90]},e([0,0,90]).scale(159.155)},t.geoTransverseMercatorRaw=id,t.gray=function(t,n){return new je(t,0,0,null==n?1:n)},t.greatest=function(t,e=n){let r,i=!1;if(1===e.length){let o;for(const a of t){const t=e(a);(i?n(t,o)>0:0===n(t,t))&&(r=a,o=t,i=!0)}}else for(const n of t)(i?e(n,r)>0:0===e(n,n))&&(r=n,i=!0);return r},t.greatestIndex=function(t,e=n){if(1===e.length)return Z(t,e);let r,i=-1,o=-1;for(const n of t)++o,(i<0?0===e(n,n):e(n,r)>0)&&(r=n,i=o);return i},t.group=w,t.groupSort=function(t,e,r){return(2!==e.length?C(T(t,e,r),(([t,e],[r,i])=>n(e,i)||n(t,r))):C(w(t,r),(([t,r],[i,o])=>e(r,o)||n(t,i)))).map((([t])=>t))},t.groups=M,t.hcl=We,t.hierarchy=fd,t.histogram=j,t.hsl=Pe,t.html=Zu,t.image=function(t,n){return new Promise((function(e,r){var i=new Image;for(var o in n)i[o]=n[o];i.onerror=r,i.onload=function(){e(i)},i.src=t}))},t.index=function(t,...n){return k(t,x,E,n)},t.indexes=function(t,...n){return k(t,Array.from,E,n)},t.interpolate=Cr,t.interpolateArray=function(t,n){return(wr(n)?xr:Mr)(t,n)},t.interpolateBasis=sr,t.interpolateBasisClosed=lr,t.interpolateBlues=gb,t.interpolateBrBG=E_,t.interpolateBuGn=X_,t.interpolateBuPu=V_,t.interpolateCividis=function(t){return t=Math.max(0,Math.min(1,t)),"rgb("+Math.max(0,Math.min(255,Math.round(-4.54-t*(35.34-t*(2381.73-t*(6402.7-t*(7024.72-2710.57*t)))))))+", "+Math.max(0,Math.min(255,Math.round(32.49+t*(170.73+t*(52.82-t*(131.46-t*(176.58-67.37*t)))))))+", "+Math.max(0,Math.min(255,Math.round(81.24+t*(442.36-t*(2482.43-t*(6167.24-t*(6614.94-2475.67*t)))))))+")"},t.interpolateCool=kb,t.interpolateCubehelix=$r,t.interpolateCubehelixDefault=Sb,t.interpolateCubehelixLong=Wr,t.interpolateDate=Ar,t.interpolateDiscrete=function(t){var n=t.length;return function(e){return t[Math.max(0,Math.min(n-1,Math.floor(e*n)))]}},t.interpolateGnBu=W_,t.interpolateGreens=vb,t.interpolateGreys=bb,t.interpolateHcl=Xr,t.interpolateHclLong=Gr,t.interpolateHsl=Lr,t.interpolateHslLong=jr,t.interpolateHue=function(t,n){var e=pr(+t,+n);return function(t){var n=e(t);return n-360*Math.floor(n/360)}},t.interpolateInferno=qb,t.interpolateLab=function(t,n){var e=yr((t=Le(t)).l,(n=Le(n)).l),r=yr(t.a,n.a),i=yr(t.b,n.b),o=yr(t.opacity,n.opacity);return function(n){return t.l=e(n),t.a=r(n),t.b=i(n),t.opacity=o(n),t+""}},t.interpolateMagma=Fb,t.interpolateNumber=Tr,t.interpolateNumberArray=xr,t.interpolateObject=Sr,t.interpolateOrRd=K_,t.interpolateOranges=Tb,t.interpolatePRGn=N_,t.interpolatePiYG=P_,t.interpolatePlasma=Ob,t.interpolatePuBu=nb,t.interpolatePuBuGn=J_,t.interpolatePuOr=D_,t.interpolatePuRd=rb,t.interpolatePurples=xb,t.interpolateRainbow=function(t){(t<0||t>1)&&(t-=Math.floor(t));var n=Math.abs(t-.5);return Nb.h=360*t-100,Nb.s=1.5-1.5*n,Nb.l=.8-.9*n,Nb+""},t.interpolateRdBu=F_,t.interpolateRdGy=O_,t.interpolateRdPu=ob,t.interpolateRdYlBu=I_,t.interpolateRdYlGn=Y_,t.interpolateReds=Mb,t.interpolateRgb=vr,t.interpolateRgbBasis=br,t.interpolateRgbBasisClosed=mr,t.interpolateRound=Pr,t.interpolateSinebow=function(t){var n;return t=(.5-t)*Math.PI,Cb.r=255*(n=Math.sin(t))*n,Cb.g=255*(n=Math.sin(t+Pb))*n,Cb.b=255*(n=Math.sin(t+zb))*n,Cb+""},t.interpolateSpectral=j_,t.interpolateString=Nr,t.interpolateTransformCss=Or,t.interpolateTransformSvg=Ur,t.interpolateTurbo=function(t){return t=Math.max(0,Math.min(1,t)),"rgb("+Math.max(0,Math.min(255,Math.round(34.61+t*(1172.33-t*(10793.56-t*(33300.12-t*(38394.49-14825.05*t)))))))+", "+Math.max(0,Math.min(255,Math.round(23.31+t*(557.33+t*(1225.33-t*(3574.96-t*(1073.77+707.56*t)))))))+", "+Math.max(0,Math.min(255,Math.round(27.2+t*(3211.1-t*(15327.97-t*(27814-t*(22569.18-6838.66*t)))))))+")"},t.interpolateViridis=Rb,t.interpolateWarm=Eb,t.interpolateYlGn=fb,t.interpolateYlGnBu=ub,t.interpolateYlOrBr=lb,t.interpolateYlOrRd=db,t.interpolateZoom=Br,t.interrupt=wi,t.intersection=function(t,...n){t=new InternSet(t),n=n.map(at);t:for(const e of t)for(const r of n)if(!r.has(e)){t.delete(e);continue t}return t},t.interval=function(t,n,e){var r=new fi,i=n;return null==n?(r.restart(t,n,e),r):(r._restart=r.restart,r.restart=function(t,n,e){n=+n,e=null==e?ui():+e,r._restart((function o(a){a+=i,r._restart(o,i+=n,e),t(a)}),n,e)},r.restart(t,n,e),r)},t.isoFormat=r_,t.isoParse=o_,t.json=function(t,n){return fetch(t,n).then(Vu)},t.lab=Le,t.lch=function(t,n,e,r){return 1===arguments.length?$e(t):new Ze(e,n,t,null==r?1:r)},t.least=function(t,e=n){let r,i=!1;if(1===e.length){let o;for(const a of t){const t=e(a);(i?n(t,o)<0:0===n(t,t))&&(r=a,o=t,i=!0)}}else for(const n of t)(i?e(n,r)<0:0===e(n,n))&&(r=n,i=!0);return r},t.leastIndex=nt,t.line=lm,t.lineRadial=bm,t.link=Nm,t.linkHorizontal=function(){return Nm(Am)},t.linkRadial=function(){const t=Nm(Sm);return t.angle=t.x,delete t.x,t.radius=t.y,delete t.y,t},t.linkVertical=function(){return Nm(Tm)},t.local=Bn,t.map=function(t,n){if("function"!=typeof t[Symbol.iterator])throw new TypeError("values is not iterable");if("function"!=typeof n)throw new TypeError("mapper is not a function");return Array.from(t,((e,r)=>n(e,r,t)))},t.matcher=Rt,t.max=H,t.maxIndex=Z,t.mean=function(t,n){let e=0,r=0;if(void 0===n)for(let n of t)null!=n&&(n=+n)>=n&&(++e,r+=n);else{let i=-1;for(let o of t)null!=(o=n(o,++i,t))&&(o=+o)>=o&&(++e,r+=o)}if(e)return r/e},t.median=function(t,n){return $(t,.5,n)},t.merge=K,t.min=X,t.minIndex=Q,t.mode=function(t,n){const e=new InternMap;if(void 0===n)for(let n of t)null!=n&&n>=n&&e.set(n,(e.get(n)||0)+1);else{let r=-1;for(let i of t)null!=(i=n(i,++r,t))&&i>=i&&e.set(i,(e.get(i)||0)+1)}let r,i=0;for(const[t,n]of e)n>i&&(i=n,r=t);return r},t.namespace=Tt,t.namespaces=At,t.nice=Y,t.now=ui,t.pack=function(){var t=null,n=1,e=1,r=Cd;function i(i){return i.x=n/2,i.y=e/2,t?i.eachBefore(Dd(t)).eachAfter(Rd(r,.5)).eachBefore(Fd(1)):i.eachBefore(Dd(zd)).eachAfter(Rd(Cd,1)).eachAfter(Rd(r,i.r/Math.min(n,e))).eachBefore(Fd(Math.min(n,e)/(2*i.r))),i}return i.radius=function(n){return arguments.length?(t=kd(n),i):t},i.size=function(t){return arguments.length?(n=+t[0],e=+t[1],i):[n,e]},i.padding=function(t){return arguments.length?(r="function"==typeof t?t:Pd(+t),i):r},i},t.packEnclose=gd,t.packSiblings=function(t){return Ed(t),t},t.pairs=function(t,n=J){const e=[];let r,i=!1;for(const o of t)i&&e.push(n(r,o)),r=o,i=!0;return e},t.partition=function(){var t=1,n=1,e=0,r=!1;function i(i){var o=i.height+1;return i.x0=i.y0=e,i.x1=t,i.y1=n/o,i.eachBefore(function(t,n){return function(r){r.children&&Od(r,r.x0,t*(r.depth+1)/n,r.x1,t*(r.depth+2)/n);var i=r.x0,o=r.y0,a=r.x1-e,u=r.y1-e;a<i&&(i=a=(i+a)/2),u<o&&(o=u=(o+u)/2),r.x0=i,r.y0=o,r.x1=a,r.y1=u}}(n,o)),r&&i.eachBefore(qd),i}return i.round=function(t){return arguments.length?(r=!!t,i):r},i.size=function(e){return arguments.length?(t=+e[0],n=+e[1],i):[t,n]},i.padding=function(t){return arguments.length?(e=+t,i):e},i},t.path=ya,t.permute=N,t.pie=function(){var t=pm,n=dm,e=null,r=Ub(0),i=Ub(Wb),o=Ub(0);function a(a){var u,c,f,s,l,h=(a=am(a)).length,d=0,p=new Array(h),g=new Array(h),y=+r.apply(this,arguments),v=Math.min(Wb,Math.max(-Wb,i.apply(this,arguments)-y)),_=Math.min(Math.abs(v)/h,o.apply(this,arguments)),b=_*(v<0?-1:1);for(u=0;u<h;++u)(l=g[p[u]=u]=+t(a[u],u,a))>0&&(d+=l);for(null!=n?p.sort((function(t,e){return n(g[t],g[e])})):null!=e&&p.sort((function(t,n){return e(a[t],a[n])})),u=0,f=d?(v-h*b)/d:0;u<h;++u,y=s)c=p[u],s=y+((l=g[c])>0?l*f:0)+b,g[c]={data:a[c],index:u,value:l,startAngle:y,endAngle:s,padAngle:_};return g}return a.value=function(n){return arguments.length?(t="function"==typeof n?n:Ub(+n),a):t},a.sortValues=function(t){return arguments.length?(n=t,e=null,a):n},a.sort=function(t){return arguments.length?(e=t,n=null,a):e},a.startAngle=function(t){return arguments.length?(r="function"==typeof t?t:Ub(+t),a):r},a.endAngle=function(t){return arguments.length?(i="function"==typeof t?t:Ub(+t),a):i},a.padAngle=function(t){return arguments.length?(o="function"==typeof t?t:Ub(+t),a):o},a},t.piecewise=Zr,t.pointRadial=xm,t.pointer=jn,t.pointers=function(t,n){return t.target&&(t=Ln(t),void 0===n&&(n=t.currentTarget),t=t.touches||[t]),Array.from(t,(t=>jn(t,n)))},t.polygonArea=function(t){for(var n,e=-1,r=t.length,i=t[r-1],o=0;++e<r;)n=i,i=t[e],o+=n[1]*i[0]-n[0]*i[1];return o/2},t.polygonCentroid=function(t){for(var n,e,r=-1,i=t.length,o=0,a=0,u=t[i-1],c=0;++r<i;)n=u,u=t[r],c+=e=n[0]*u[1]-u[0]*n[1],o+=(n[0]+u[0])*e,a+=(n[1]+u[1])*e;return[o/(c*=3),a/c]},t.polygonContains=function(t,n){for(var e,r,i=t.length,o=t[i-1],a=n[0],u=n[1],c=o[0],f=o[1],s=!1,l=0;l<i;++l)e=(o=t[l])[0],(r=o[1])>u!=f>u&&a<(c-e)*(u-r)/(f-r)+e&&(s=!s),c=e,f=r;return s},t.polygonHull=function(t){if((e=t.length)<3)return null;var n,e,r=new Array(e),i=new Array(e);for(n=0;n<e;++n)r[n]=[+t[n][0],+t[n][1],n];for(r.sort(rp),n=0;n<e;++n)i[n]=[r[n][0],-r[n][1]];var o=ip(r),a=ip(i),u=a[0]===o[0],c=a[a.length-1]===o[o.length-1],f=[];for(n=o.length-1;n>=0;--n)f.push(t[r[o[n]][2]]);for(n=+u;n<a.length-c;++n)f.push(t[r[a[n]][2]]);return f},t.polygonLength=function(t){for(var n,e,r=-1,i=t.length,o=t[i-1],a=o[0],u=o[1],c=0;++r<i;)n=a,e=u,n-=a=(o=t[r])[0],e-=u=o[1],c+=Math.hypot(n,e);return c},t.precisionFixed=Cc,t.precisionPrefix=Pc,t.precisionRound=zc,t.quadtree=ec,t.quantile=$,t.quantileSorted=W,t.quantize=function(t,n){for(var e=new Array(n),r=0;r<n;++r)e[r]=t(r/(n-1));return e},t.quickselect=G,t.radialArea=mm,t.radialLine=bm,t.randomBates=lp,t.randomBernoulli=pp,t.randomBeta=vp,t.randomBinomial=_p,t.randomCauchy=mp,t.randomExponential=hp,t.randomGamma=yp,t.randomGeometric=gp,t.randomInt=up,t.randomIrwinHall=sp,t.randomLcg=function(t=Math.random()){let n=0|(0<=t&&t<1?t/Mp:Math.abs(t));return()=>(n=1664525*n+1013904223|0,Mp*(n>>>0))},t.randomLogNormal=fp,t.randomLogistic=xp,t.randomNormal=cp,t.randomPareto=dp,t.randomPoisson=wp,t.randomUniform=ap,t.randomWeibull=bp,t.range=tt,t.rank=function(t,e=n){if("function"!=typeof t[Symbol.iterator])throw new TypeError("values is not iterable");let r=Array.from(t);const i=new Float64Array(r.length);2!==e.length&&(r=r.map(e),e=n);const o=(t,n)=>e(r[t],r[n]);let a,u;return Uint32Array.from(r,((t,n)=>n)).sort(e===n?(t,n)=>z(r[t],r[n]):P(o)).forEach(((t,n)=>{const e=o(t,void 0===a?t:a);e>=0?((void 0===a||e>0)&&(a=t,u=n),i[t]=u):i[t]=NaN})),i},t.reduce=function(t,n,e){if("function"!=typeof n)throw new TypeError("reducer is not a function");const r=t[Symbol.iterator]();let i,o,a=-1;if(arguments.length<3){if(({done:i,value:e}=r.next()),i)return;++a}for(;({done:i,value:o}=r.next()),!i;)e=n(e,o,++a,t);return e},t.reverse=function(t){if("function"!=typeof t[Symbol.iterator])throw new TypeError("values is not iterable");return Array.from(t).reverse()},t.rgb=Ae,t.ribbon=function(){return Sa()},t.ribbonArrow=function(){return Sa(Ta)},t.rollup=T,t.rollups=S,t.scaleBand=kp,t.scaleDiverging=function t(){var n=Bp(h_()(zp));return n.copy=function(){return s_(n,t())},Tp.apply(n,arguments)},t.scaleDivergingLog=function t(){var n=$p(h_()).domain([.1,1,10]);return n.copy=function(){return s_(n,t()).base(n.base())},Tp.apply(n,arguments)},t.scaleDivergingPow=d_,t.scaleDivergingSqrt=function(){return d_.apply(null,arguments).exponent(.5)},t.scaleDivergingSymlog=function t(){var n=Kp(h_());return n.copy=function(){return s_(n,t()).constant(n.constant())},Tp.apply(n,arguments)},t.scaleIdentity=function t(n){var e;function r(t){return null==t||isNaN(t=+t)?e:t}return r.invert=r,r.domain=r.range=function(t){return arguments.length?(n=Array.from(t,Cp),r):n.slice()},r.unknown=function(t){return arguments.length?(e=t,r):e},r.copy=function(){return t(n).unknown(e)},n=arguments.length?Array.from(n,Cp):[0,1],Bp(r)},t.scaleImplicit=Sp,t.scaleLinear=function t(){var n=Up();return n.copy=function(){return qp(n,t())},Ap.apply(n,arguments),Bp(n)},t.scaleLog=function t(){const n=$p(Op()).domain([1,10]);return n.copy=()=>qp(n,t()).base(n.base()),Ap.apply(n,arguments),n},t.scaleOrdinal=Ep,t.scalePoint=function(){return Np(kp.apply(null,arguments).paddingInner(1))},t.scalePow=eg,t.scaleQuantile=function t(){var e,r=[],i=[],o=[];function a(){var t=0,n=Math.max(1,i.length);for(o=new Array(n-1);++t<n;)o[t-1]=W(r,t/n);return u}function u(t){return null==t||isNaN(t=+t)?e:i[c(o,t)]}return u.invertExtent=function(t){var n=i.indexOf(t);return n<0?[NaN,NaN]:[n>0?o[n-1]:r[0],n<o.length?o[n]:r[r.length-1]]},u.domain=function(t){if(!arguments.length)return r.slice();r=[];for(let n of t)null==n||isNaN(n=+n)||r.push(n);return r.sort(n),a()},u.range=function(t){return arguments.length?(i=Array.from(t),a()):i.slice()},u.unknown=function(t){return arguments.length?(e=t,u):e},u.quantiles=function(){return o.slice()},u.copy=function(){return t().domain(r).range(i).unknown(e)},Ap.apply(u,arguments)},t.scaleQuantize=function t(){var n,e=0,r=1,i=1,o=[.5],a=[0,1];function u(t){return null!=t&&t<=t?a[c(o,t,0,i)]:n}function f(){var t=-1;for(o=new Array(i);++t<i;)o[t]=((t+1)*r-(t-i)*e)/(i+1);return u}return u.domain=function(t){return arguments.length?([e,r]=t,e=+e,r=+r,f()):[e,r]},u.range=function(t){return arguments.length?(i=(a=Array.from(t)).length-1,f()):a.slice()},u.invertExtent=function(t){var n=a.indexOf(t);return n<0?[NaN,NaN]:n<1?[e,o[0]]:n>=i?[o[i-1],r]:[o[n-1],o[n]]},u.unknown=function(t){return arguments.length?(n=t,u):u},u.thresholds=function(){return o.slice()},u.copy=function(){return t().domain([e,r]).range(a).unknown(n)},Ap.apply(Bp(u),arguments)},t.scaleRadial=function t(){var n,e=Up(),r=[0,1],i=!1;function o(t){var r=ig(e(t));return isNaN(r)?n:i?Math.round(r):r}return o.invert=function(t){return e.invert(rg(t))},o.domain=function(t){return arguments.length?(e.domain(t),o):e.domain()},o.range=function(t){return arguments.length?(e.range((r=Array.from(t,Cp)).map(rg)),o):r.slice()},o.rangeRound=function(t){return o.range(t).round(!0)},o.round=function(t){return arguments.length?(i=!!t,o):i},o.clamp=function(t){return arguments.length?(e.clamp(t),o):e.clamp()},o.unknown=function(t){return arguments.length?(n=t,o):n},o.copy=function(){return t(e.domain(),r).round(i).clamp(e.clamp()).unknown(n)},Ap.apply(o,arguments),Bp(o)},t.scaleSequential=function t(){var n=Bp(f_()(zp));return n.copy=function(){return s_(n,t())},Tp.apply(n,arguments)},t.scaleSequentialLog=function t(){var n=$p(f_()).domain([1,10]);return n.copy=function(){return s_(n,t()).base(n.base())},Tp.apply(n,arguments)},t.scaleSequentialPow=l_,t.scaleSequentialQuantile=function t(){var e=[],r=zp;function i(t){if(null!=t&&!isNaN(t=+t))return r((c(e,t,1)-1)/(e.length-1))}return i.domain=function(t){if(!arguments.length)return e.slice();e=[];for(let n of t)null==n||isNaN(n=+n)||e.push(n);return e.sort(n),i},i.interpolator=function(t){return arguments.length?(r=t,i):r},i.range=function(){return e.map(((t,n)=>r(n/(e.length-1))))},i.quantiles=function(t){return Array.from({length:t+1},((n,r)=>$(e,r/t)))},i.copy=function(){return t(r).domain(e)},Tp.apply(i,arguments)},t.scaleSequentialSqrt=function(){return l_.apply(null,arguments).exponent(.5)},t.scaleSequentialSymlog=function t(){var n=Kp(f_());return n.copy=function(){return s_(n,t()).constant(n.constant())},Tp.apply(n,arguments)},t.scaleSqrt=function(){return eg.apply(null,arguments).exponent(.5)},t.scaleSymlog=function t(){var n=Kp(Op());return n.copy=function(){return qp(n,t()).constant(n.constant())},Ap.apply(n,arguments)},t.scaleThreshold=function t(){var n,e=[.5],r=[0,1],i=1;function o(t){return null!=t&&t<=t?r[c(e,t,0,i)]:n}return o.domain=function(t){return arguments.length?(e=Array.from(t),i=Math.min(e.length,r.length-1),o):e.slice()},o.range=function(t){return arguments.length?(r=Array.from(t),i=Math.min(e.length,r.length-1),o):r.slice()},o.invertExtent=function(t){var n=r.indexOf(t);return[e[n-1],e[n]]},o.unknown=function(t){return arguments.length?(n=t,o):n},o.copy=function(){return t().domain(e).range(r).unknown(n)},Ap.apply(o,arguments)},t.scaleTime=function(){return Ap.apply(c_(Cy,Py,Wg,Gg,Pg,kg,Tg,wg,bg,t.timeFormat).domain([new Date(2e3,0,1),new Date(2e3,0,2)]),arguments)},t.scaleUtc=function(){return Ap.apply(c_(ky,Ny,Ty,wy,uy,iy,ny,Qg,bg,t.utcFormat).domain([Date.UTC(2e3,0,1),Date.UTC(2e3,0,2)]),arguments)},t.scan=function(t,n){const e=nt(t,n);return e<0?void 0:e},t.schemeAccent=y_,t.schemeBlues=pb,t.schemeBrBG=S_,t.schemeBuGn=H_,t.schemeBuPu=G_,t.schemeCategory10=g_,t.schemeDark2=v_,t.schemeGnBu=$_,t.schemeGreens=yb,t.schemeGreys=_b,t.schemeOrRd=Z_,t.schemeOranges=Ab,t.schemePRGn=k_,t.schemePaired=__,t.schemePastel1=b_,t.schemePastel2=m_,t.schemePiYG=C_,t.schemePuBu=tb,t.schemePuBuGn=Q_,t.schemePuOr=z_,t.schemePuRd=eb,t.schemePurples=mb,t.schemeRdBu=R_,t.schemeRdGy=q_,t.schemeRdPu=ib,t.schemeRdYlBu=U_,t.schemeRdYlGn=B_,t.schemeReds=wb,t.schemeSet1=x_,t.schemeSet2=w_,t.schemeSet3=M_,t.schemeSpectral=L_,t.schemeTableau10=A_,t.schemeYlGn=cb,t.schemeYlGnBu=ab,t.schemeYlOrBr=sb,t.schemeYlOrRd=hb,t.select=Un,t.selectAll=function(t){return"string"==typeof t?new qn([document.querySelectorAll(t)],[document.documentElement]):new qn([Pt(t)],Fn)},t.selection=On,t.selector=Ct,t.selectorAll=Dt,t.shuffle=et,t.shuffler=rt,t.some=function(t,n){if("function"!=typeof n)throw new TypeError("test is not a function");let e=-1;for(const r of t)if(n(r,++e,t))return!0;return!1},t.sort=C,t.stack=function(){var t=Ub([]),n=qx,e=Fx,r=Ox;function i(i){var o,a,u=Array.from(t.apply(this,arguments),Ux),c=u.length,f=-1;for(const t of i)for(o=0,++f;o<c;++o)(u[o][f]=[0,+r(t,u[o].key,f,i)]).data=t;for(o=0,a=am(n(u));o<c;++o)u[a[o]].index=o;return e(u,a),u}return i.keys=function(n){return arguments.length?(t="function"==typeof n?n:Ub(Array.from(n)),i):t},i.value=function(t){return arguments.length?(r="function"==typeof t?t:Ub(+t),i):r},i.order=function(t){return arguments.length?(n=null==t?qx:"function"==typeof t?t:Ub(Array.from(t)),i):n},i.offset=function(t){return arguments.length?(e=null==t?Fx:t,i):e},i},t.stackOffsetDiverging=function(t,n){if((u=t.length)>0)for(var e,r,i,o,a,u,c=0,f=t[n[0]].length;c<f;++c)for(o=a=0,e=0;e<u;++e)(i=(r=t[n[e]][c])[1]-r[0])>0?(r[0]=o,r[1]=o+=i):i<0?(r[1]=a,r[0]=a+=i):(r[0]=0,r[1]=i)},t.stackOffsetExpand=function(t,n){if((r=t.length)>0){for(var e,r,i,o=0,a=t[0].length;o<a;++o){for(i=e=0;e<r;++e)i+=t[e][o][1]||0;if(i)for(e=0;e<r;++e)t[e][o][1]/=i}Fx(t,n)}},t.stackOffsetNone=Fx,t.stackOffsetSilhouette=function(t,n){if((e=t.length)>0){for(var e,r=0,i=t[n[0]],o=i.length;r<o;++r){for(var a=0,u=0;a<e;++a)u+=t[a][r][1]||0;i[r][1]+=i[r][0]=-u/2}Fx(t,n)}},t.stackOffsetWiggle=function(t,n){if((i=t.length)>0&&(r=(e=t[n[0]]).length)>0){for(var e,r,i,o=0,a=1;a<r;++a){for(var u=0,c=0,f=0;u<i;++u){for(var s=t[n[u]],l=s[a][1]||0,h=(l-(s[a-1][1]||0))/2,d=0;d<u;++d){var p=t[n[d]];h+=(p[a][1]||0)-(p[a-1][1]||0)}c+=l,f+=h*l}e[a-1][1]+=e[a-1][0]=o,c&&(o-=f/c)}e[a-1][1]+=e[a-1][0]=o,Fx(t,n)}},t.stackOrderAppearance=Ix,t.stackOrderAscending=Yx,t.stackOrderDescending=function(t){return Yx(t).reverse()},t.stackOrderInsideOut=function(t){var n,e,r=t.length,i=t.map(Lx),o=Ix(t),a=0,u=0,c=[],f=[];for(n=0;n<r;++n)e=o[n],a<u?(a+=i[e],c.push(e)):(u+=i[e],f.push(e));return f.reverse().concat(c)},t.stackOrderNone=qx,t.stackOrderReverse=function(t){return qx(t).reverse()},t.stratify=function(){var t,n=Yd,e=Ld;function r(r){var i,o,a,u,c,f,s,l,h=Array.from(r),d=n,p=e,g=new Map;if(null!=t){const n=h.map(((n,e)=>function(t){let n=(t=`${t}`).length;Hd(t,n-1)&&!Hd(t,n-2)&&(t=t.slice(0,-1));return"/"===t[0]?t:`/${t}`}(t(n,e,r)))),e=n.map(jd),i=new Set(n).add("");for(const t of e)i.has(t)||(i.add(t),n.push(t),e.push(jd(t)),h.push(Bd));d=(t,e)=>n[e],p=(t,n)=>e[n]}for(a=0,i=h.length;a<i;++a)o=h[a],f=h[a]=new pd(o),null!=(s=d(o,a,r))&&(s+="")&&(l=f.id=s,g.set(l,g.has(l)?Id:f)),null!=(s=p(o,a,r))&&(s+="")&&(f.parent=s);for(a=0;a<i;++a)if(s=(f=h[a]).parent){if(!(c=g.get(s)))throw new Error("missing: "+s);if(c===Id)throw new Error("ambiguous: "+s);c.children?c.children.push(f):c.children=[f],f.parent=c}else{if(u)throw new Error("multiple roots");u=f}if(!u)throw new Error("no root");if(null!=t){for(;u.data===Bd&&1===u.children.length;)u=u.children[0],--i;for(let t=h.length-1;t>=0&&(f=h[t],f.data===Bd);--t)f.data=null}if(u.parent=Ud,u.eachBefore((function(t){t.depth=t.parent.depth+1,--i})).eachBefore(dd),u.parent=null,i>0)throw new Error("cycle");return u}return r.id=function(t){return arguments.length?(n=kd(t),r):n},r.parentId=function(t){return arguments.length?(e=kd(t),r):e},r.path=function(n){return arguments.length?(t=kd(n),r):t},r},t.style=on,t.subset=function(t,n){return ut(n,t)},t.sum=function(t,n){let e=0;if(void 0===n)for(let n of t)(n=+n)&&(e+=n);else{let r=-1;for(let i of t)(i=+n(i,++r,t))&&(e+=i)}return e},t.superset=ut,t.svg=Ku,t.symbol=function(t,n){let e=null;function r(){let r;if(e||(e=r=ya()),t.apply(this,arguments).draw(e,+n.apply(this,arguments)),r)return e=null,r+""||null}return t="function"==typeof t?t:Ub(t||zm),n="function"==typeof n?n:Ub(void 0===n?64:+n),r.type=function(n){return arguments.length?(t="function"==typeof n?n:Ub(n),r):t},r.size=function(t){return arguments.length?(n="function"==typeof t?t:Ub(+t),r):n},r.context=function(t){return arguments.length?(e=null==t?null:t,r):e},r},t.symbolAsterisk=Pm,t.symbolCircle=zm,t.symbolCross=Dm,t.symbolDiamond=qm,t.symbolDiamond2=Om,t.symbolPlus=Um,t.symbolSquare=Im,t.symbolSquare2=Bm,t.symbolStar=Hm,t.symbolTriangle=Gm,t.symbolTriangle2=$m,t.symbolWye=Jm,t.symbolX=tx,t.symbols=nx,t.symbolsFill=nx,t.symbolsStroke=ex,t.text=ju,t.thresholdFreedmanDiaconis=function(t,n,e){return Math.ceil((e-n)/(2*($(t,.75)-$(t,.25))*Math.pow(f(t),-1/3)))},t.thresholdScott=function(t,n,e){return Math.ceil((e-n)/(3.5*p(t)*Math.pow(f(t),-1/3)))},t.thresholdSturges=L,t.tickFormat=Ip,t.tickIncrement=I,t.tickStep=B,t.ticks=U,t.timeDay=kg,t.timeDays=Ng,t.timeFormatDefaultLocale=t_,t.timeFormatLocale=Fy,t.timeFriday=qg,t.timeFridays=jg,t.timeHour=Tg,t.timeHours=Sg,t.timeInterval=ug,t.timeMillisecond=fg,t.timeMilliseconds=sg,t.timeMinute=wg,t.timeMinutes=Mg,t.timeMonday=zg,t.timeMondays=Ig,t.timeMonth=Gg,t.timeMonths=Vg,t.timeSaturday=Og,t.timeSaturdays=Hg,t.timeSecond=bg,t.timeSeconds=mg,t.timeSunday=Pg,t.timeSundays=Ug,t.timeThursday=Fg,t.timeThursdays=Lg,t.timeTickInterval=Py,t.timeTicks=Cy,t.timeTuesday=Dg,t.timeTuesdays=Bg,t.timeWednesday=Rg,t.timeWednesdays=Yg,t.timeWeek=Pg,t.timeWeeks=Ug,t.timeYear=Wg,t.timeYears=Zg,t.timeout=gi,t.timer=si,t.timerFlush=li,t.transition=Ki,t.transpose=it,t.tree=function(){var t=Xd,n=1,e=1,r=null;function i(i){var c=function(t){for(var n,e,r,i,o,a=new Zd(t,0),u=[a];n=u.pop();)if(r=n._.children)for(n.children=new Array(o=r.length),i=o-1;i>=0;--i)u.push(e=n.children[i]=new Zd(r[i],i)),e.parent=n;return(a.parent=new Zd(null,0)).children=[a],a}(i);if(c.eachAfter(o),c.parent.m=-c.z,c.eachBefore(a),r)i.eachBefore(u);else{var f=i,s=i,l=i;i.eachBefore((function(t){t.x<f.x&&(f=t),t.x>s.x&&(s=t),t.depth>l.depth&&(l=t)}));var h=f===s?1:t(f,s)/2,d=h-f.x,p=n/(s.x+h+d),g=e/(l.depth||1);i.eachBefore((function(t){t.x=(t.x+d)*p,t.y=t.depth*g}))}return i}function o(n){var e=n.children,r=n.parent.children,i=n.i?r[n.i-1]:null;if(e){!function(t){for(var n,e=0,r=0,i=t.children,o=i.length;--o>=0;)(n=i[o]).z+=e,n.m+=e,e+=n.s+(r+=n.c)}(n);var o=(e[0].z+e[e.length-1].z)/2;i?(n.z=i.z+t(n._,i._),n.m=n.z-o):n.z=o}else i&&(n.z=i.z+t(n._,i._));n.parent.A=function(n,e,r){if(e){for(var i,o=n,a=n,u=e,c=o.parent.children[0],f=o.m,s=a.m,l=u.m,h=c.m;u=Vd(u),o=Gd(o),u&&o;)c=Gd(c),(a=Vd(a)).a=n,(i=u.z+l-o.z-f+t(u._,o._))>0&&($d(Wd(u,n,r),n,i),f+=i,s+=i),l+=u.m,f+=o.m,h+=c.m,s+=a.m;u&&!Vd(a)&&(a.t=u,a.m+=l-s),o&&!Gd(c)&&(c.t=o,c.m+=f-h,r=n)}return r}(n,i,n.parent.A||r[0])}function a(t){t._.x=t.z+t.parent.m,t.m+=t.parent.m}function u(t){t.x*=n,t.y=t.depth*e}return i.separation=function(n){return arguments.length?(t=n,i):t},i.size=function(t){return arguments.length?(r=!1,n=+t[0],e=+t[1],i):r?null:[n,e]},i.nodeSize=function(t){return arguments.length?(r=!0,n=+t[0],e=+t[1],i):r?[n,e]:null},i},t.treemap=function(){var t=tp,n=!1,e=1,r=1,i=[0],o=Cd,a=Cd,u=Cd,c=Cd,f=Cd;function s(t){return t.x0=t.y0=0,t.x1=e,t.y1=r,t.eachBefore(l),i=[0],n&&t.eachBefore(qd),t}function l(n){var e=i[n.depth],r=n.x0+e,s=n.y0+e,l=n.x1-e,h=n.y1-e;l<r&&(r=l=(r+l)/2),h<s&&(s=h=(s+h)/2),n.x0=r,n.y0=s,n.x1=l,n.y1=h,n.children&&(e=i[n.depth+1]=o(n)/2,r+=f(n)-e,s+=a(n)-e,(l-=u(n)-e)<r&&(r=l=(r+l)/2),(h-=c(n)-e)<s&&(s=h=(s+h)/2),t(n,r,s,l,h))}return s.round=function(t){return arguments.length?(n=!!t,s):n},s.size=function(t){return arguments.length?(e=+t[0],r=+t[1],s):[e,r]},s.tile=function(n){return arguments.length?(t=Nd(n),s):t},s.padding=function(t){return arguments.length?s.paddingInner(t).paddingOuter(t):s.paddingInner()},s.paddingInner=function(t){return arguments.length?(o="function"==typeof t?t:Pd(+t),s):o},s.paddingOuter=function(t){return arguments.length?s.paddingTop(t).paddingRight(t).paddingBottom(t).paddingLeft(t):s.paddingTop()},s.paddingTop=function(t){return arguments.length?(a="function"==typeof t?t:Pd(+t),s):a},s.paddingRight=function(t){return arguments.length?(u="function"==typeof t?t:Pd(+t),s):u},s.paddingBottom=function(t){return arguments.length?(c="function"==typeof t?t:Pd(+t),s):c},s.paddingLeft=function(t){return arguments.length?(f="function"==typeof t?t:Pd(+t),s):f},s},t.treemapBinary=function(t,n,e,r,i){var o,a,u=t.children,c=u.length,f=new Array(c+1);for(f[0]=a=o=0;o<c;++o)f[o+1]=a+=u[o].value;!function t(n,e,r,i,o,a,c){if(n>=e-1){var s=u[n];return s.x0=i,s.y0=o,s.x1=a,void(s.y1=c)}var l=f[n],h=r/2+l,d=n+1,p=e-1;for(;d<p;){var g=d+p>>>1;f[g]<h?d=g+1:p=g}h-f[d-1]<f[d]-h&&n+1<d&&--d;var y=f[d]-l,v=r-y;if(a-i>c-o){var _=r?(i*v+a*y)/r:a;t(n,d,y,i,o,_,c),t(d,e,v,_,o,a,c)}else{var b=r?(o*v+c*y)/r:c;t(n,d,y,i,o,a,b),t(d,e,v,i,b,a,c)}}(0,c,t.value,n,e,r,i)},t.treemapDice=Od,t.treemapResquarify=np,t.treemapSlice=Kd,t.treemapSliceDice=function(t,n,e,r,i){(1&t.depth?Kd:Od)(t,n,e,r,i)},t.treemapSquarify=tp,t.tsv=Gu,t.tsvFormat=Ru,t.tsvFormatBody=Fu,t.tsvFormatRow=Ou,t.tsvFormatRows=qu,t.tsvFormatValue=Uu,t.tsvParse=zu,t.tsvParseRows=Du,t.union=function(...t){const n=new InternSet;for(const e of t)for(const t of e)n.add(t);return n},t.utcDay=iy,t.utcDays=oy,t.utcFriday=hy,t.utcFridays=by,t.utcHour=ny,t.utcHours=ey,t.utcMillisecond=fg,t.utcMilliseconds=sg,t.utcMinute=Qg,t.utcMinutes=Jg,t.utcMonday=cy,t.utcMondays=gy,t.utcMonth=wy,t.utcMonths=My,t.utcSaturday=dy,t.utcSaturdays=my,t.utcSecond=bg,t.utcSeconds=mg,t.utcSunday=uy,t.utcSundays=py,t.utcThursday=ly,t.utcThursdays=_y,t.utcTickInterval=Ny,t.utcTicks=ky,t.utcTuesday=fy,t.utcTuesdays=yy,t.utcWednesday=sy,t.utcWednesdays=vy,t.utcWeek=uy,t.utcWeeks=py,t.utcYear=Ty,t.utcYears=Sy,t.variance=d,t.version="7.3.0",t.window=tn,t.xml=Wu,t.zip=function(){return it(arguments)},t.zoom=function(){var t,n,e,r=Zx,i=Kx,o=nw,a=Jx,u=tw,c=[0,1/0],f=[[-1/0,-1/0],[1/0,1/0]],s=250,l=Br,h=_t("start","zoom","end"),d=500,p=0,g=10;function y(t){t.property("__zoom",Qx).on("wheel.zoom",M,{passive:!1}).on("mousedown.zoom",A).on("dblclick.zoom",T).filter(u).on("touchstart.zoom",S).on("touchmove.zoom",E).on("touchend.zoom touchcancel.zoom",k).style("-webkit-tap-highlight-color","rgba(0,0,0,0)")}function v(t,n){return(n=Math.max(c[0],Math.min(c[1],n)))===t.k?t:new Xx(n,t.x,t.y)}function _(t,n,e){var r=n[0]-e[0]*t.k,i=n[1]-e[1]*t.k;return r===t.x&&i===t.y?t:new Xx(t.k,r,i)}function b(t){return[(+t[0][0]+ +t[1][0])/2,(+t[0][1]+ +t[1][1])/2]}function m(t,n,e,r){t.on("start.zoom",(function(){x(this,arguments).event(r).start()})).on("interrupt.zoom end.zoom",(function(){x(this,arguments).event(r).end()})).tween("zoom",(function(){var t=this,o=arguments,a=x(t,o).event(r),u=i.apply(t,o),c=null==e?b(u):"function"==typeof e?e.apply(t,o):e,f=Math.max(u[1][0]-u[0][0],u[1][1]-u[0][1]),s=t.__zoom,h="function"==typeof n?n.apply(t,o):n,d=l(s.invert(c).concat(f/s.k),h.invert(c).concat(f/h.k));return function(t){if(1===t)t=h;else{var n=d(t),e=f/n[2];t=new Xx(e,c[0]-n[0]*e,c[1]-n[1]*e)}a.zoom(null,t)}}))}function x(t,n,e){return!e&&t.__zooming||new w(t,n)}function w(t,n){this.that=t,this.args=n,this.active=0,this.sourceEvent=null,this.extent=i.apply(t,n),this.taps=0}function M(t,...n){if(r.apply(this,arguments)){var e=x(this,n).event(t),i=this.__zoom,u=Math.max(c[0],Math.min(c[1],i.k*Math.pow(2,a.apply(this,arguments)))),s=jn(t);if(e.wheel)e.mouse[0][0]===s[0]&&e.mouse[0][1]===s[1]||(e.mouse[1]=i.invert(e.mouse[0]=s)),clearTimeout(e.wheel);else{if(i.k===u)return;e.mouse=[s,i.invert(s)],wi(this),e.start()}Wx(t),e.wheel=setTimeout(l,150),e.zoom("mouse",o(_(v(i,u),e.mouse[0],e.mouse[1]),e.extent,f))}function l(){e.wheel=null,e.end()}}function A(t,...n){if(!e&&r.apply(this,arguments)){var i=t.currentTarget,a=x(this,n,!0).event(t),u=Un(t.view).on("mousemove.zoom",h,!0).on("mouseup.zoom",d,!0),c=jn(t,i),s=t.clientX,l=t.clientY;$n(t.view),$x(t),a.mouse=[c,this.__zoom.invert(c)],wi(this),a.start()}function h(t){if(Wx(t),!a.moved){var n=t.clientX-s,e=t.clientY-l;a.moved=n*n+e*e>p}a.event(t).zoom("mouse",o(_(a.that.__zoom,a.mouse[0]=jn(t,i),a.mouse[1]),a.extent,f))}function d(t){u.on("mousemove.zoom mouseup.zoom",null),Wn(t.view,a.moved),Wx(t),a.event(t).end()}}function T(t,...n){if(r.apply(this,arguments)){var e=this.__zoom,a=jn(t.changedTouches?t.changedTouches[0]:t,this),u=e.invert(a),c=e.k*(t.shiftKey?.5:2),l=o(_(v(e,c),a,u),i.apply(this,n),f);Wx(t),s>0?Un(this).transition().duration(s).call(m,l,a,t):Un(this).call(y.transform,l,a,t)}}function S(e,...i){if(r.apply(this,arguments)){var o,a,u,c,f=e.touches,s=f.length,l=x(this,i,e.changedTouches.length===s).event(e);for($x(e),a=0;a<s;++a)c=[c=jn(u=f[a],this),this.__zoom.invert(c),u.identifier],l.touch0?l.touch1||l.touch0[2]===c[2]||(l.touch1=c,l.taps=0):(l.touch0=c,o=!0,l.taps=1+!!t);t&&(t=clearTimeout(t)),o&&(l.taps<2&&(n=c[0],t=setTimeout((function(){t=null}),d)),wi(this),l.start())}}function E(t,...n){if(this.__zooming){var e,r,i,a,u=x(this,n).event(t),c=t.changedTouches,s=c.length;for(Wx(t),e=0;e<s;++e)i=jn(r=c[e],this),u.touch0&&u.touch0[2]===r.identifier?u.touch0[0]=i:u.touch1&&u.touch1[2]===r.identifier&&(u.touch1[0]=i);if(r=u.that.__zoom,u.touch1){var l=u.touch0[0],h=u.touch0[1],d=u.touch1[0],p=u.touch1[1],g=(g=d[0]-l[0])*g+(g=d[1]-l[1])*g,y=(y=p[0]-h[0])*y+(y=p[1]-h[1])*y;r=v(r,Math.sqrt(g/y)),i=[(l[0]+d[0])/2,(l[1]+d[1])/2],a=[(h[0]+p[0])/2,(h[1]+p[1])/2]}else{if(!u.touch0)return;i=u.touch0[0],a=u.touch0[1]}u.zoom("touch",o(_(r,i,a),u.extent,f))}}function k(t,...r){if(this.__zooming){var i,o,a=x(this,r).event(t),u=t.changedTouches,c=u.length;for($x(t),e&&clearTimeout(e),e=setTimeout((function(){e=null}),d),i=0;i<c;++i)o=u[i],a.touch0&&a.touch0[2]===o.identifier?delete a.touch0:a.touch1&&a.touch1[2]===o.identifier&&delete a.touch1;if(a.touch1&&!a.touch0&&(a.touch0=a.touch1,delete a.touch1),a.touch0)a.touch0[1]=this.__zoom.invert(a.touch0[0]);else if(a.end(),2===a.taps&&(o=jn(o,this),Math.hypot(n[0]-o[0],n[1]-o[1])<g)){var f=Un(this).on("dblclick.zoom");f&&f.apply(this,arguments)}}}return y.transform=function(t,n,e,r){var i=t.selection?t.selection():t;i.property("__zoom",Qx),t!==i?m(t,n,e,r):i.interrupt().each((function(){x(this,arguments).event(r).start().zoom(null,"function"==typeof n?n.apply(this,arguments):n).end()}))},y.scaleBy=function(t,n,e,r){y.scaleTo(t,(function(){var t=this.__zoom.k,e="function"==typeof n?n.apply(this,arguments):n;return t*e}),e,r)},y.scaleTo=function(t,n,e,r){y.transform(t,(function(){var t=i.apply(this,arguments),r=this.__zoom,a=null==e?b(t):"function"==typeof e?e.apply(this,arguments):e,u=r.invert(a),c="function"==typeof n?n.apply(this,arguments):n;return o(_(v(r,c),a,u),t,f)}),e,r)},y.translateBy=function(t,n,e,r){y.transform(t,(function(){return o(this.__zoom.translate("function"==typeof n?n.apply(this,arguments):n,"function"==typeof e?e.apply(this,arguments):e),i.apply(this,arguments),f)}),null,r)},y.translateTo=function(t,n,e,r,a){y.transform(t,(function(){var t=i.apply(this,arguments),a=this.__zoom,u=null==r?b(t):"function"==typeof r?r.apply(this,arguments):r;return o(Gx.translate(u[0],u[1]).scale(a.k).translate("function"==typeof n?-n.apply(this,arguments):-n,"function"==typeof e?-e.apply(this,arguments):-e),t,f)}),r,a)},w.prototype={event:function(t){return t&&(this.sourceEvent=t),this},start:function(){return 1==++this.active&&(this.that.__zooming=this,this.emit("start")),this},zoom:function(t,n){return this.mouse&&"mouse"!==t&&(this.mouse[1]=n.invert(this.mouse[0])),this.touch0&&"touch"!==t&&(this.touch0[1]=n.invert(this.touch0[0])),this.touch1&&"touch"!==t&&(this.touch1[1]=n.invert(this.touch1[0])),this.that.__zoom=n,this.emit("zoom"),this},end:function(){return 0==--this.active&&(delete this.that.__zooming,this.emit("end")),this},emit:function(t){var n=Un(this.that).datum();h.call(t,this.that,new Hx(t,{sourceEvent:this.sourceEvent,target:y,type:t,transform:this.that.__zoom,dispatch:h}),n)}},y.wheelDelta=function(t){return arguments.length?(a="function"==typeof t?t:jx(+t),y):a},y.filter=function(t){return arguments.length?(r="function"==typeof t?t:jx(!!t),y):r},y.touchable=function(t){return arguments.length?(u="function"==typeof t?t:jx(!!t),y):u},y.extent=function(t){return arguments.length?(i="function"==typeof t?t:jx([[+t[0][0],+t[0][1]],[+t[1][0],+t[1][1]]]),y):i},y.scaleExtent=function(t){return arguments.length?(c[0]=+t[0],c[1]=+t[1],y):[c[0],c[1]]},y.translateExtent=function(t){return arguments.length?(f[0][0]=+t[0][0],f[1][0]=+t[1][0],f[0][1]=+t[0][1],f[1][1]=+t[1][1],y):[[f[0][0],f[0][1]],[f[1][0],f[1][1]]]},y.constrain=function(t){return arguments.length?(o=t,y):o},y.duration=function(t){return arguments.length?(s=+t,y):s},y.interpolate=function(t){return arguments.length?(l=t,y):l},y.on=function(){var t=h.on.apply(h,arguments);return t===h?y:t},y.clickDistance=function(t){return arguments.length?(p=(t=+t)*t,y):Math.sqrt(p)},y.tapDistance=function(t){return arguments.length?(g=+t,y):g},y},t.zoomIdentity=Gx,t.zoomTransform=Vx,Object.defineProperty(t,"__esModule",{value:!0})}));

</script>
<script type="text/javascript">
/**
 * Simple, lightweight, usable local autocomplete library for modern browsers
 * Because there weren’t enough autocomplete scripts in the world? Because I’m completely insane and have NIH syndrome? Probably both. :P
 * @author Lea Verou http://leaverou.github.io/awesomplete
 * MIT license
 */

(function () {

var _ = function (input, o) {
	var me = this;

	// Setup

	this.isOpened = false;

	this.input = $(input);
	this.input.setAttribute("autocomplete", "off");
	this.input.setAttribute("aria-autocomplete", "list");

	o = o || {};

	configure(this, {
		minChars: 2,
		maxItems: 10,
		autoFirst: false,
		data: _.DATA,
		filter: _.FILTER_CONTAINS,
		sort: _.SORT_BYLENGTH,
		item: _.ITEM,
		replace: _.REPLACE
	}, o);

	this.index = -1;

	// Create necessary elements

	this.container = $.create("div", {
		className: "awesomplete",
		around: input
	});

	this.ul = $.create("ul", {
		hidden: "hidden",
		inside: this.container
	});

	this.status = $.create("span", {
		className: "visually-hidden",
		role: "status",
		"aria-live": "assertive",
		"aria-relevant": "additions",
		inside: this.container
	});

	// Bind events

	$.bind(this.input, {
		"input": this.evaluate.bind(this),
		"blur": this.close.bind(this, { reason: "blur" }),
		"keydown": function(evt) {
			var c = evt.keyCode;

			// If the dropdown `ul` is in view, then act on keydown for the following keys:
			// Enter / Esc / Up / Down
			if(me.opened) {
				if (c === 13 && me.selected) { // Enter
					evt.preventDefault();
					me.select();
				}
				else if (c === 27) { // Esc
					me.close({ reason: "esc" });
				}
				else if (c === 38 || c === 40) { // Down/Up arrow
					evt.preventDefault();
					me[c === 38? "previous" : "next"]();
				}
			}
		}
	});

	$.bind(this.input.form, {"submit": this.close.bind(this, { reason: "submit" })});

	$.bind(this.ul, {"mousedown": function(evt) {
		var li = evt.target;

		if (li !== this) {

			while (li && !/li/i.test(li.nodeName)) {
				li = li.parentNode;
			}

			if (li && evt.button === 0) {  // Only select on left click
				evt.preventDefault();
				me.select(li, evt.target);
			}
		}
	}});

	if (this.input.hasAttribute("list")) {
		this.list = "#" + this.input.getAttribute("list");
		this.input.removeAttribute("list");
	}
	else {
		this.list = this.input.getAttribute("data-list") || o.list || [];
	}

	_.all.push(this);
};

_.prototype = {
	set list(list) {
		if (Array.isArray(list)) {
			this._list = list;
		}
		else if (typeof list === "string" && list.indexOf(",") > -1) {
				this._list = list.split(/\s*,\s*/);
		}
		else { // Element or CSS selector
			list = $(list);

			if (list && list.children) {
				var items = [];
				slice.apply(list.children).forEach(function (el) {
					if (!el.disabled) {
						var text = el.textContent.trim();
						var value = el.value || text;
						var label = el.label || text;
						if (value !== "") {
							items.push({ label: label, value: value });
						}
					}
				});
				this._list = items;
			}
		}

		if (document.activeElement === this.input) {
			this.evaluate();
		}
	},

	get selected() {
		return this.index > -1;
	},

	get opened() {
		return this.isOpened;
	},

	close: function (o) {
		if (!this.opened) {
			return;
		}

		this.ul.setAttribute("hidden", "");
		this.isOpened = false;
		this.index = -1;

		$.fire(this.input, "awesomplete-close", o || {});
	},

	open: function () {
		this.ul.removeAttribute("hidden");
		this.isOpened = true;

		if (this.autoFirst && this.index === -1) {
			this.goto(0);
		}

		$.fire(this.input, "awesomplete-open");
	},

	next: function () {
		var count = this.ul.children.length;
		this.goto(this.index < count - 1 ? this.index + 1 : (count ? 0 : -1) );
	},

	previous: function () {
		var count = this.ul.children.length;
		var pos = this.index - 1;

		this.goto(this.selected && pos !== -1 ? pos : count - 1);
	},

	// Should not be used, highlights specific item without any checks!
	goto: function (i) {
		var lis = this.ul.children;

		if (this.selected) {
			lis[this.index].setAttribute("aria-selected", "false");
		}

		this.index = i;

		if (i > -1 && lis.length > 0) {
			lis[i].setAttribute("aria-selected", "true");
			this.status.textContent = lis[i].textContent;

			$.fire(this.input, "awesomplete-highlight", {
				text: this.suggestions[this.index]
			});
		}
	},

	select: function (selected, origin) {
		if (selected) {
			this.index = $.siblingIndex(selected);
		} else {
			selected = this.ul.children[this.index];
		}

		if (selected) {
			var suggestion = this.suggestions[this.index];

			var allowed = $.fire(this.input, "awesomplete-select", {
				text: suggestion,
				origin: origin || selected
			});

			if (allowed) {
				this.replace(suggestion);
				this.close({ reason: "select" });
				$.fire(this.input, "awesomplete-selectcomplete", {
					text: suggestion
				});
			}
		}
	},

	evaluate: function() {
		var me = this;
		var value = this.input.value;

		if (value.length >= this.minChars && this._list.length > 0) {
			this.index = -1;
			// Populate list with options that match
			this.ul.innerHTML = "";

			this.suggestions = this._list
				.map(function(item) {
					return new Suggestion(me.data(item, value));
				})
				.filter(function(item) {
					return me.filter(item, value);
				})
				.sort(this.sort)
				.slice(0, this.maxItems);

			this.suggestions.forEach(function(text) {
					me.ul.appendChild(me.item(text, value));
				});

			if (this.ul.children.length === 0) {
				this.close({ reason: "nomatches" });
			} else {
				this.open();
			}
		}
		else {
			this.close({ reason: "nomatches" });
		}
	}
};

// Static methods/properties

_.all = [];

_.FILTER_CONTAINS = function (text, input) {
	return RegExp($.regExpEscape(input.trim()), "i").test(text);
};

_.FILTER_STARTSWITH = function (text, input) {
	return RegExp("^" + $.regExpEscape(input.trim()), "i").test(text);
};

_.SORT_BYLENGTH = function (a, b) {
	if (a.length !== b.length) {
		return a.length - b.length;
	}

	return a < b? -1 : 1;
};

_.ITEM = function (text, input) {
	var html = input === '' ? text : text.replace(RegExp($.regExpEscape(input.trim()), "gi"), "<mark>$&</mark>");
	return $.create("li", {
		innerHTML: html,
		"aria-selected": "false"
	});
};

_.REPLACE = function (text) {
	this.input.value = text.value;
};

_.DATA = function (item/*, input*/) { return item; };

// Private functions

function Suggestion(data) {
	var o = Array.isArray(data)
	  ? { label: data[0], value: data[1] }
	  : typeof data === "object" && "label" in data && "value" in data ? data : { label: data, value: data };

	this.label = o.label || o.value;
	this.value = o.value;
}
Object.defineProperty(Suggestion.prototype = Object.create(String.prototype), "length", {
	get: function() { return this.label.length; }
});
Suggestion.prototype.toString = Suggestion.prototype.valueOf = function () {
	return "" + this.label;
};

function configure(instance, properties, o) {
	for (var i in properties) {
		var initial = properties[i],
		    attrValue = instance.input.getAttribute("data-" + i.toLowerCase());

		if (typeof initial === "number") {
			instance[i] = parseInt(attrValue);
		}
		else if (initial === false) { // Boolean options must be false by default anyway
			instance[i] = attrValue !== null;
		}
		else if (initial instanceof Function) {
			instance[i] = null;
		}
		else {
			instance[i] = attrValue;
		}

		if (!instance[i] && instance[i] !== 0) {
			instance[i] = (i in o)? o[i] : initial;
		}
	}
}

// Helpers

var slice = Array.prototype.slice;

function $(expr, con) {
	return typeof expr === "string"? (con || document).querySelector(expr) : expr || null;
}

function $$(expr, con) {
	return slice.call((con || document).querySelectorAll(expr));
}

$.create = function(tag, o) {
	var element = document.createElement(tag);

	for (var i in o) {
		var val = o[i];

		if (i === "inside") {
			$(val).appendChild(element);
		}
		else if (i === "around") {
			var ref = $(val);
			ref.parentNode.insertBefore(element, ref);
			element.appendChild(ref);
		}
		else if (i in element) {
			element[i] = val;
		}
		else {
			element.setAttribute(i, val);
		}
	}

	return element;
};

$.bind = function(element, o) {
	if (element) {
		for (var event in o) {
			var callback = o[event];

			event.split(/\s+/).forEach(function (event) {
				element.addEventListener(event, callback);
			});
		}
	}
};

$.fire = function(target, type, properties) {
	var evt = document.createEvent("HTMLEvents");

	evt.initEvent(type, true, true );

	for (var j in properties) {
		evt[j] = properties[j];
	}

	return target.dispatchEvent(evt);
};

$.regExpEscape = function (s) {
	return s.replace(/[-\\^$*+?.()|[\]{}]/g, "\\$&");
};

$.siblingIndex = function (el) {
	/* eslint-disable no-cond-assign */
	for (var i = 0; el = el.previousElementSibling; i++);
	return i;
};

// Initialization

function init() {
	$$("input.awesomplete").forEach(function (input) {
		new _(input);
	});
}

// Are we in a browser? Check for Document constructor
if (typeof Document !== "undefined") {
	// DOM already loaded?
	if (document.readyState !== "loading") {
		init();
	}
	else {
		// Wait for it
		document.addEventListener("DOMContentLoaded", init);
	}
}

_.$ = $;
_.$$ = $$;

// Make sure to export Awesomplete on self when in a browser
if (typeof self !== "undefined") {
	self.Awesomplete = _;
}

// Expose Awesomplete as a CJS module
if (typeof module === "object" && module.exports) {
	module.exports = _;
}

return _;

}());

</script>
<script type="text/javascript">
/**
* vkBeautify - javascript plugin to pretty-print or minify text in XML, JSON, CSS and SQL formats.
*
* Version - 0.99.00.beta
* Copyright (c) 2012 Vadim Kiryukhin
* vkiryukhin @ gmail.com
* http://www.eslinstructor.net/vkbeautify/
*
* MIT license:
*   http://www.opensource.org/licenses/mit-license.php
*
*   Pretty print
*
*        vkbeautify.xml(text [,indent_pattern]);
*
*
*        @text - String; text to beatufy;
*        @indent_pattern - Integer | String;
*                Integer:  number of white spaces;
*                String:   character string to visualize indentation ( can also be a set of white spaces )
*/

(function() {

    function createShiftArr(step) {

        var space = '    ';

        if ( isNaN(parseInt(step)) ) {  // argument is string
            space = step;
        } else { // argument is integer
            switch(step) {
                case 1: space = ' '; break;
                case 2: space = '  '; break;
                case 3: space = '   '; break;
                case 4: space = '    '; break;
                case 5: space = '     '; break;
                case 6: space = '      '; break;
                case 7: space = '       '; break;
                case 8: space = '        '; break;
                case 9: space = '         '; break;
                case 10: space = '          '; break;
                case 11: space = '           '; break;
                case 12: space = '            '; break;
            }
        }

        var shift = ['\n']; // array of shifts
        for(ix=0;ix<100;ix++){
            shift.push(shift[ix]+space);
        }
        return shift;
    }

    function vkbeautify(){
        this.step = '\t'; // 4 spaces
        this.shift = createShiftArr(this.step);
    };

    vkbeautify.prototype.xml = function(text,step) {

        var ar = text.replace(/>\s{0,}</g,"><")
                        .replace(/</g,"~::~<")
                        .replace(/\s*xmlns\:/g,"~::~xmlns:")
                        .replace(/\s*xmlns\=/g,"~::~xmlns=")
                        .split('~::~'),
            len = ar.length,
            inComment = false,
            deep = 0,
            str = '',
            ix = 0,
            shift = step ? createShiftArr(step) : this.shift;

            for(ix=0;ix<len;ix++) {
                // start comment or <![CDATA[...]]> or <!DOCTYPE //
                if(ar[ix].search(/<!/) > -1) {
                    str += shift[deep]+ar[ix];
                    inComment = true;
                    // end comment  or <![CDATA[...]]> //
                    if(ar[ix].search(/-->/) > -1 || ar[ix].search(/\]>/) > -1 || ar[ix].search(/!DOCTYPE/) > -1 ) {
                        inComment = false;
                    }
                } else
                // end comment  or <![CDATA[...]]> //
                if(ar[ix].search(/-->/) > -1 || ar[ix].search(/\]>/) > -1) {
                    str += ar[ix];
                    inComment = false;
                } else
                // <elm></elm> //
                if( /^<\w/.exec(ar[ix-1]) && /^<\/\w/.exec(ar[ix]) &&
                    /^<[\w:\-\.\,]+/.exec(ar[ix-1]) == /^<\/[\w:\-\.\,]+/.exec(ar[ix])[0].replace('/','')) {
                    str += ar[ix];
                    if(!inComment) deep--;
                } else
                    // <elm> //
                if(ar[ix].search(/<\w/) > -1 && ar[ix].search(/<\//) == -1 && ar[ix].search(/\/>/) == -1 ) {
                    str = !inComment ? str += shift[deep++]+ar[ix] : str += ar[ix];
                } else
                    // <elm>...</elm> //
                if(ar[ix].search(/<\w/) > -1 && ar[ix].search(/<\//) > -1) {
                    str = !inComment ? str += shift[deep]+ar[ix] : str += ar[ix];
                } else
                // </elm> //
                if(ar[ix].search(/<\//) > -1) {
                    str = !inComment ? str += shift[--deep]+ar[ix] : str += ar[ix];
                } else
                // <elm/> //
                if(ar[ix].search(/\/>/) > -1 ) {
                    str = !inComment ? str += shift[deep]+ar[ix] : str += ar[ix];
                } else
                // <? xml ... ?> //
                if(ar[ix].search(/<\?/) > -1) {
                    str += shift[deep]+ar[ix];
                } else
                // xmlns //
                if( ar[ix].search(/xmlns\:/) > -1  || ar[ix].search(/xmlns\=/) > -1) {
                    str += shift[deep]+ar[ix];
                }

                else {
                    str += ar[ix];
                }
            }

        return  (str[0] == '\n') ? str.slice(1) : str;
    }

    window.vkbeautify = new vkbeautify();

})();
</script>

</head>
<body>
<div id="all-diagram-content" class="non-embedded-diagram" data-openmdao-version='3.26.0'>
    <div id="diagram-content">
        <!-- Toolbar -->
        <div id="toolbarLoc">
            <div class="searchbar-container" id="searchbar-container">
                <button class="search-button" id="searchButtonId" title="Search">
                    <i class="fas icon-search"></i>
                </button>
                <div id='searchbar-and-label' class='searchbar-hidden'>
                    <label id='searchCountId' for='awesompleteId'>0 matches</label>
                    <input type="text" tabindex="-1" size="80" placeholder="Search" id="awesompleteId"
                        class="searchbar" autocomplete="off"/>
                </div>
            </div>
            <div class="toolbar" id="true-toolbar">
                <div class="toolbar-group group-1">
                    <i class="fas icon-home2" id="reset-graph"></i>
                    <i class="fas icon-backward" id="undo-graph"></i>
                    <i class="fas icon-forward" id="redo-graph"></i>
                </div>
                <div class="toolbar-group group-2">
                    <div class="expandable">
                        <i class="fas icon-shrink2" id="collapse-element"></i>
                        <i class="fas icon-caret-right caret"></i>
                        <div class="toolbar-group-expandable" id="collapse-expandable">
                            <i class="fas icon-shrink2" id="collapse-element-2"></i>
                            <i class="fas icon-enlarge2" id="expand-element"></i>
                            <i class="fas icon-shrink" id="collapse-all"></i>
                            <i class="fas icon-enlarge" id="expand-all"></i>
                        </div>
                    </div>
                    <div class="expandable">
                        <i class="fas icon-info-circle" id="info-button"></i>
                        <i class="fas icon-caret-right caret"></i>
                        <div class="toolbar-group-expandable" id="target-expandable">
                            <i class="fas icon-info-circle" id="info-button-2"></i>
                            <i class="fas icon-collapse-target" id="collapse-target"></i>
                            <i class="fas icon-filter-target" id="filter-target"></i>
                        </div>
                    </div>
                </div>
                <div class="toolbar-group group-3">
                    <div class="expandable">
                        <i class="fas icon-hide-connections" id="hide-connections"></i>
                        <i class="fas icon-caret-right caret"></i>
                        <div class="toolbar-group-expandable" id="connections-expandable">
                            <i class="fas icon-hide-connections" id="hide-connections-2"></i>
                            <i class="fas icon-bezier-curve" id="show-all-connections"></i>
                        </div>
                    </div>

                    <div class="expandable">
                        <i class="fas icon-linear-solver solver-button" id="linear-solver-button"></i>
                        <i class="fas icon-caret-right caret"></i>
                        <div class="toolbar-group-expandable" id="solvers-expandable">
                            <i class="fas icon-linear-solver solver-button" id="linear-solver-button-2"></i>
                            <i class="fas icon-nonlinear-solver solver-button" id="non-linear-solver-button"></i>
                            <i class="fas icon-no-solver solver-button" id="no-solver-button"></i>
                        </div>
                    </div>

                    <i class="fas icon-fx-2" id="desvars-button"></i>
                </div>
                <div class="toolbar-group group-4">
                    <div class="expandable">
                        <i class="fas icon-text-height" id="text-slider-button"></i>
                        <i class="fas icon-caret-right caret"></i>
                        <div class="toolbar-group-expandable" id="text-width-expandable">
                            <input type="range" min="8" max="24" value="11" class="slider" id="text-slider" />
                            <p id="font-size-indicator">11 px</p>
                        </div>
                    </div>
                    <div class="expandable">
                        <i class="fas icon-collapse-depth" id="depth-slider-button"></i>
                        <i class="fas icon-caret-right caret"></i>
                        <div class="toolbar-group-expandable" id="model-depth-expandable">
                            <input type="range" min="2" max="10" value="0" class="slider" id="depth-slider" />
                            <p id='depth-slider-label'>10</p>
                        </div>
                    </div>
                    <div class="expandable">
                        <i class="fas icon-model-height" id="model-slider-button"></i>
                        <i class="fas icon-caret-right caret"></i>
                        <div class="toolbar-group-expandable" id="model-height-expandable">
                            <input type="range" min='50' max='200' value='95' class="slider" id="model-slider" />
                            <p id='model-slider-label'>95%</p>
                            <button id='model-slider-fit'>Fit</button>
                        </div>
                    </div>
                    <div class="expandable">
                        <i class="fas icon-save" id="save-load-button"></i>
                        <i class="fas icon-caret-right caret"></i>
                        <div class="toolbar-group-expandable" id="text-width-expandable">
                            <i class="fas icon-savesvg" id="save-button"></i>
                            <i class="fas icon-saveview" id="save-state-button"></i>
                            <i class="fas icon-loadview" id="load-state-button"></i>
                            <input id="state-file-input" type="file" name="name" style="display: none;" />
                        </div>
                    </div>
                </div>
                <div class="toolbar-group group-5">
                    <div class="expandable">
                        <i class="fas icon-question-circle" id="question-button"></i>
                        <i class="fas icon-caret-right caret"></i>
                        <div class="toolbar-group-expandable" id="info-expandable">
                            <i class="fas icon-question-circle" id="question-button-2"></i>
                            <i class="fas icon-key" id="legend-button"></i>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Hide toolbar button -->
            <div class="toolbar-hide-container" id="hide-toolbar">
                <i class="fas icon-chevron-left hide-toolbar-button"></i>
            </div>
        </div>

        <div id="d3_content_div">
            <!-- 2D Matrix Showing All Inputs/Outputs and Functions -->
            <div id="svgDiv">
                <div class="no-show" id="waiting-container">
                    <img id="waiting-icon" src="data:image/png;base64,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" alt="Processing..." />
                </div>
                <svg id="svgId">
                    <style title='svgStyle'></style>
                    <defs>
                        <marker id="arrow" viewBox="0 -5 10 10" refX="5" refY="0" markerWidth="1" markerHeight="1"
                            orient="auto">
                            <path d="M0,-5L10,0L0,5L0,-5" class="arrowHead"></path>
                        </marker>
                        <clipPath id="partitionTreeClip">
                            <rect id="tree-clip-rect" x="0" y="0" width="1200" height="600" />
                        </clipPath>
                        <clipPath id="n2MatrixClip">
                            <rect id="matrix-clip-rect" x="-1" y="-1" width="602" height="602" />
                        </clipPath>
                        <clipPath id="solverTreeClip">
                            <rect id="solver-clip-rect" x="0" y="0" width="1200" height="600" />
                        </clipPath>
                        <g id='matrix-connector-arrow' width='10' height='10'>
                            <path d='M0,3 h2 q5,0 5,5 h1 l-3,2 l-3,-2 h1 q0,-1 -1,-1 h-2 z'></path>
                        </g>
                        <g id='matrix-connector-square' width='10' height='10'>
                            <rect x='2' y='2' width='6' height='6'></rect>
                        </g>
                    </defs>
                    <g id='tree' clip-path='url(#partitionTreeClip)'></g>
                    <g id='highlight-bar'></g>
                    <g id='solver_tree' clip-path='url(#solverTreeClip)'></g>
                    <g id='n2outer'>
                        <g id='n2inner'>
                            <rect id='backgroundRect' class='background'></rect>
                            <g id='n2background' clip-path='url(#n2MatrixClip)'></g>
                            <g id='n2gridlines' clip-path='url(#n2MatrixClip)'></g>
                            <g id='n2elements' clip-path='url(#n2MatrixClip)'></g>
                            <g id='n2variableBoxes' clip-path='url(#n2MatrixClip)'></g>
                            <g id='n2arrows'></g>
                        </g>
                        <g id='n2top' class='offgridLabel'></g>
                        <g id='n2left' class='offgridLabel'></g>
                        <g id='n2right' class='offgridLabel'></g>
                        <g id='n2bottom' class='offgridLabel'></g>
                    </g>
                    <g id='text-width-renderer' class='model_tree_grp'>
                        <text x='-200'></text>
                    </g>
                </svg>
                <div id='n2-resizer-box' class='inactive-resizer-box'>
                    <p id='n2-resizer-handle' class='inactive-resizer-handle'></p>
                </div>
            </div>

            <!-- Legend to show all symbols -->
            <div class="legend" id="legend-div" style="visibility: hidden">
                <div class="sys-var-container">
                    <div class="legend-title-container">
                        <p class="legend-title">Systems &amp;&nbsp;Variables</p>
                    </div>
                    <div id="sys-var-legend"></div>
                </div>
                <div class="n2-symbols-container">
                    <div class="legend-title-container">
                        <p class="legend-title">N2<br />Symbols</p>
                    </div>
                    <div id="symbols-legend">
                        <div class="symbol">
                            <div class="symbol-outer scalar">
                                <div class="symbol-inner"></div>
                            </div>
                            <p>Scalar</p>
                        </div>
                        <div class="symbol">
                            <div class="symbol-outer vector">
                                <div class="symbol-inner"></div>
                            </div>
                            <p>Vector</p>
                        </div>
                        <div class="symbol">
                            <div class="symbol-outer collapsed">
                                <div class="symbol-inner"></div>
                            </div>
                            <p>Collapsed Variables</p>
                        </div>
                    </div>
                </div>
                <div class="linear-solvers-container">
                    <div class="legend-title-container">
                        <p class="legend-title" id="solvers-legend-title">Linear Solvers</p>
                    </div>
                    <div id="solvers-legend"></div>
                </div>
            </div>
        </div>

        <div id="connectionId"></div>

        <div id='n2-windows'>
            <div class='n2-windows-modal-bg window-inactive'></div>
            <!-- Window template for all N2 windows -->
            <div id='window-template' class='window-inactive' style='z-index: 100'>
                <div class='main-window'>
                    <div class='window-contents window-theme-default'>
                        <div class='window-header'>
                            <span class='window-title'>N2 Information</span>
                        </div>
                        <!-- Close button outside of header so it doesn't affect title alignment -->
                        <span class='window-close-button'></span>
                        <div class='window-body'></div>
                        <div class='window-footer'>
                            <span></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Need this off window element to put values that can then be put on the pastebuffer -->
    <textarea id="input-for-pastebuffer"></textarea>

    <div class="tool-tip" style="position: absolute; visibility: hidden;"></div>
    <div id="top" class="offgrid" style="visibility: hidden;"></div>
    <div id="left" class="offgrid" style="visibility: hidden;"></div>
    <div id="right" class="offgrid" style="visibility: hidden;"></div>
    <div id="bottom" class="offgrid" style="visibility: hidden;"></div>

    <div id="logo-container">
        <img id="company-logo" alt="OpenMDAO" src="data:image/png;base64,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" />
    </div>

    <div id="show-error-button-container">
        <button id="show-error-button">
            <i class="fas icon-notification"></i> Show N2 Error
        </button>
    </div>

    <div id="toolbar-help-container" class='window-inactive'>
        <p><b>Left-click</b> on a node in the model hierarchy to navigate to that node.<br>
            <b>Right-click</b> on a node to collapse/expand it.
            <b>Alt-right-click</b> on a node with variables to select which ones to hide.<br>
            Note: Right-click in Firefox displays a browser menu. To disable that,
            visit <b>about:config</b> and set <code>dom.event.contextmenu.enabled</code>
            to <b>true</b>.<br>
            <b>Hover</b> over any cell in the matrix to display its connections
            as arrows. Click that cell to make those arrows persistent.
        </p>
        <h3>Toolbar Help</h3>
        <div class='help-graphic'>
            <img id="toolbar-snapshot" alt="Snapshot of toolbar buttons"
                src="data:image/png;base64,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" />
            <svg id='help-graphic-svg'></svg>
        </div>
    </div>

    <div id="variable-selection-body">
        <table class="header">
            <tr>
                <th class="varname"><span class="sort-up">&#9650;</span><span>Variable Name</span><span class="sort-down">&#9660;</span></th>
                <th class="varvis">Visible</th>
                <th class="scrollbar-spacer"></th>
            </tr>
        </table>
        <div class="table-container">
            <table class="variables">
                <tbody></tbody>
            </table>
        </div>
        <div class="search-container">
            <span class='search-label'>Search</span><input class='variable-selection-search' type='text'>
            <span class='search-clear'>&#x2715;</span><span class='search-perform'>&#x27a4;</span>
        </div>
        <div class="button-container">
            <button class="select-all-variables">Select All</button>
            <button class="select-no-variables">Select None</button>
            <button class="apply-variable-selection">Apply</button>
        </div>
    </div>
</div>

<script type="text/javascript">
    var compressedModel = "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N7Ka1q5hXAl1Jc0Mcb39PkQp4LaQFKIOJo1vI8ttuUgMRvtNY07Tm6pbTGVIAeCXmc4PJql9lGg1ikodqlWzH+jGx6StVuCMIXzzgCNDghz2S7e+TmloEFnXsGhE04T2CGTeZGUSbCXpwU5gxDDZI+BiCuIVENeKsKKa5bngHuhhk4vRcn9BbaaetfTP++9lKetZ//T0u88GOP72GxRypp8pP342wvHCwfDSP/3jkrKPhv5sfvev/gz/4We4qsxf6WMM/O/zn1/gMcbTY3ypVv37r7/59VNUX/yntSPYb96++/jh/ho//PTjL188LXNjZNK++fb799/8+Zsf74b9xy/6u9d40X99jRf99je5aFm2/9FrdpU0V0lzlTRXSXOVNFdJ+2dUSRslvn4A+gHoB6AfgH4A+gHoB6AfgH4A+gHoB6AfgH4A+gHoB6AfgH4A+gHoB6AfgH4A+gHoB6AfgH4A+gHoB+Af5QD8HXVK2t785fXRm8JrZL+F18h+C6+R/Rac/eaWr1u+bvm65euWr1u+vyfL10M/fgD6AegHoB+AfgD6AegHoB+AfgD6AegHoB+AfgD6AegHoB+AfgD6AegHoB+AfgD6AegHoB+AfgD6AfjHOgB/R+y38BrZb/E1st/ia2S/xdfIfovOfnPL1y1ft3zd8nXL1y3f35Pl66EfPwD9APQD0A9APwD9APQD0A9APwD9APQD0A9APwD9APQD0A9APwD9APQD0A9APwD9APQD0A9APwD9APxjHYC/I/ZbfI3st/Qa2W/pNbLf0mtkvyVnv7nl65avW75u+brl65bv78ny9dCPH4B+APoB6AegH4B+APoB6AegH4B+APoB6AegH4B+APoB6AegH4B+APoB6AegH4B+APoB6AegH4B+AP6xDsDfEfst/d7Zb9zYh+9//ObDd4z4P8/80Mefvnvz8cOHH998+O793+/wv7z5Qb/39uPbb8fX//jF/3r35w8fv3r7p/f2Q395owfx7bsfP/795/5dN/2Xv1wM+r+PHutf373/oHtj9LxMXfj9s/3hpz/98Pcffnz3LeCf37/9we7763fvv/nbw4fv33337VdvPzz85afv/swHdRMPH759c/ml//W//7f/+T/+9/W/8d3v/vb9x3c//DCfG49S4Hd6PN989+7txzc/fHj/13cf+e3/coG/uT3x+cnLj/3M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j5wZ2xh9RgUajzyjA41Hzgy3jz6nBY1HnlGDxiNnQTBGn1GExiPPiJ3xyDOia3SbeUYXOjrbP7joz2lD45Fn1KHxyDOyfRRTPaMQjUee0YjGI8+pROOZ53SiXp50P/KMVtSfeEYt6k/c6EV99BnFqD3xsd27U4364DO6UX/i/sjvtaM2+jEa+zih3ilIffD+YtypSH1wv+NpD+/snZbUB89qUh+8Zyd3ilIfPGtKbfABp3vIFO+UpT54z3c/wKQfs/SPy4IHEuQDwuaxaPqAIHso9T4gIj8qWz8glB8J8A8I+8eqwQcUiYdaxwdUlMcKzQfUn1WD0ujPf/WbzcDeN/791/3foayf//PnX734uv03//n+8zf/8vLt519Mh5gh9Pz8C/M6vrfnLGvp53969f6Pn//Lq3dfvPkWj+L7t9++HKN/evEvK+bKP+jfF0Zoa/h/8VLejP3rq5df4Yz0p9Gv3/7xTX/Y/hsf4pu3r/5gXlIuzS+aK/LzP7189Yc/vv/87Yv3r3jB29PvtK4v3s8/e/nVq5dfHqtdnKCff/nty6/6c8vaX/6fF3r9yxevvvr27cvPv3jzWi+8ePV6feR/fql53718a9+89dV88/bNN69ef8lCfv4/9d//Rf/9H/nvP//5zhX74t27l1//01daw/9+8cX0jH7x7gs9/Isbh+vn37x8++UKgvPu239696/v3r/8msEvvtJcBo3zzcvXL16+fdM+/0kLfvkH25jXT8fw5394++bbb9798lf6u379v2jmN2+/fvH6C/PIvvw/3+iz3vVVvv72q680+PrN669evX754u3n7958JToxMJzf/PJn//W///Y///ZX//DzB498vn7qq2/ets1z+rKf3031m9+epvqUefTY2D+2b0Xreffy8xev3v/zy9fLYBsw//uXOtk3b42I3PInIvP5J+4pHX/y6vWr969efLX+6cZXfPHm62/evH75+v04ur5X82Tmkdp+d2yib168ffHVVy+/Wtb2xR9fffX7t7bc/3WcOucl4nz9xbvvfOz86+//VRO9+uLdE1OwgfqxX/6P3/yn/3D853XaP53T/urVl++/ePPyy+9+x0+HzTSf2zyf+1//8jf6r1/xH/7X3+msP3LA/c2Hr33knfvdmvv6zI7dbj1f0jC6Pnx7vvrmjy9+8NYl56Ylv3/5hwUfzJtYfoii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";
</script>

<script type="text/javascript">
/** A faster way to find an object in an array than indexOf.
 * @param {array} arr The array to search.
 * @param {Object} obj The object to search for.
 * @returns The index of the first matching object, or -1 if not found.
 */
function indexFor(arr, obj) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === obj) {
            return i;
        }
    }

    return -1;
}

/** Find the index of an object in the array with the first member
 * that matches the supplied value.
 * @param {any[]} arr The array to search.
 * @param {string} memName The name of the object member.
 * @param {Object} val The value of the object member to match.
 * @returns The index of the first matching object or -1 if not found.
 */
function indexForMember(arr, memName, val) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i].hasOwnProperty(memName) &&
            arr[i][memName] === val) {
            return i;
        }
    }

    return -1;
}

/** Make sure testVar is neither undefined or null.
 * @param {any} testVar The variable to check.
 * @return {Boolean} True if testVar is not undefined and not null.
*/
function exists(testVar) {
    return (testVar !== undefined && testVar !== null);
}

/**
 * Add a method to the Object prototype call propExists(),
 * which is stronger than hasOwnProperty() in that it also checks
 * the property for undefined and null values.
 * @param {string} propName The name of the property to check.
 * @return {Boolean} True if propName exists in the object, and is
 *   not undefined and not null.
 */
Object.defineProperty(Object.prototype, 'propExists', {
    value: function (propName) {
        return (this.hasOwnProperty(propName) &&
            this[propName] !== undefined &&
            this[propName] !== null);
    },
    enumerable: false,
});

/**
 * Since checking for an Array's existance as well as 
 * length > 0 is very common, combine the two.
 */
Array.isPopulatedArray = function (arr) {
    return (Array.isArray(arr) && arr.length > 0);
};

/** Preserve D3 prototypes so transitions can be disabled for complex diagrams */
d3.selection.prototype.originalFuncs = {
    'transition': d3.selection.prototype.transition,
    'duration': d3.selection.prototype.duration,
    'delay': d3.selection.prototype.delay
};
d3.selection.prototype.transitionAllowed = true;

/** Useful dummy function */
function returnThis() { return this; }

/** Log info to the console if debugging is enabled */
function debugInfo() {
    if (DebugFlags.info) console.log(...arguments);
}

/**
 * When class member functions are used with callbacks, 'this' can be redefined if
 * not managed carefully. This function double checks to make sure 'this' refers
 * to the correct class.
 * @param {Object} testThis The 'this' from inside the calling member function.
 * @param {string} className The name of the expected class.
 * @param {string} funcName The name of the calling function, for error reporting.
 * @throws {TypeError} If testThis isn't an instance of className.
 */
function testThis(testThis, className, funcName) {
    let thisClass = testThis.constructor.name;

    if (thisClass != className) {
        throw new TypeError(className + '.' + funcName +
            ": 'this' is an instance of '" + thisClass +
            "'; expected '" + className + "'.");
    }
}

/**
 * UUID generator based on crypto API
 * @returns {String} UUID in a format such as '400042c1-2d83-445b-9e84-104f7befdc68'
 */
function uuidv4() {
    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
    );
}

/**
 * Delete all properties in the object without destroying the actual object.
 * @param {Object} obj The object to operate on.
 */
function wipeObj(obj) {
    for (const prop in obj) {
        if (obj.hasOwnProperty(prop)) delete obj[prop];
    }
}

/**
 * Determine if an HTML DOM element is truly visible.
 * @param {HTMLElement} elem Reference to the element to check.
 * @returns {Boolean} True is the element can be seen.
 */
function visible(elem) {
    return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
}

/**
 * An adaptation of the common "basename()" function.
 * @param {String} filepath The path to get the basename from.
 * @returns {String} The basename of the current URL, minus the .html/.htm extension.
 */
function basename(filepath = window.location.pathname) {
    return String(filepath).replace(/^.*[\/\\](.+)\.html?$/i, "$1");
}

// Constants and default values
const EMBEDDED = (d3.selectAll("#all-diagram-content").classed("embedded"));
const _DEFAULT_DIAGRAM_UNIT = 'px';
const _DEFAULT_DIAGRAM_HEIGHT = window.innerHeight * .95;
const _DEFAULT_FONT_SIZE = 11;
const _DEFAULT_GAP_SIZE = _DEFAULT_FONT_SIZE + 4;

defaultDims = {
    'size': {
        'unit': _DEFAULT_DIAGRAM_UNIT,
        'matrix': {
            // Dimensions of the matrix grid
            'height': _DEFAULT_DIAGRAM_HEIGHT,
            'width': _DEFAULT_DIAGRAM_HEIGHT,
            'margin': _DEFAULT_GAP_SIZE
        },
        'partitionTree': {
            // Dimensions of the tree on the left side of the diagram
            'width': 0,
            'height': _DEFAULT_DIAGRAM_HEIGHT,
        },
        'font': _DEFAULT_FONT_SIZE,
        'minColumnWidth': 2,
        'rightTextMargin': 8,
        'parentNodeWidth': 30,
        'partitionTreeGap': _DEFAULT_GAP_SIZE, // Pixels between model tree and matrix grid
        'svgMargin': 1,
    }
};

Object.freeze(defaultDims);

// TODO: Probably move this into Diagram or other class
const transitionDefaults = {
    'startDelay': 100,
    'duration': 0,
    'durationFast': 1000,
    'durationSlow': 3000,
    'maxNodes': 150
}

const Precollapse = {
    'minimumNodes': 200, // Precollapse nodes in models larger than this
    'threshold': 0, // Only precollapse nodes with more descendants than this
    'grpDepthStart': 3, // Only precollapse group nodes at least this deep
    'cmpDepthStart': 2, // Only precollapse nodes w/variable children at least this deep
    'depthLimit': 6, // Only precollapse nodes with more than this many others at the same depth
    'children': 6, // Only precollapse nodes with more direct children than this
                   // (decreases by 1 w/each depth level)
}

Object.freeze(Precollapse);

const DebugFlags = {
    'timings': false,
    'info': false
}

/**
 * Create a D3 transition that creates animations for selected geometry changes.
 * @param {Number} transitionStartDelay Number of milliseconds before animation starts.
 * @returns {Transition} The newly created transition.
 */
function getTransition(transitionStartDelay = transitionDefaults.startDelay) {
    return d3.transition('global')
    .duration(transitionDefaults.duration)
    .delay(transitionStartDelay)
    // Hide the transition waiting animation when it ends:
    .on('end', () => d3.select('#waiting-container').attr('class', 'no-show'));
}

(function(e){if(typeof exports=="object"&&typeof module!="undefined")module.exports=
e();else if(typeof define=="function"&&define.amd)define([],e);else{var t;typeof 
window!="undefined"?t=window:typeof global!="undefined"?t=global:typeof self!="undefined"?
t=self:t=this,t.pako=e()}})(function(){var e,t,n;return function(){function e(t,
n,i){function s(u,a){if(!n[u]){if(!t[u]){var f="function"==typeof require&&require
;if(!a&&f)return f(u,!0);if(o)return o(u,!0);var l=new Error("Cannot find module '"+
u+"'");throw l.code="MODULE_NOT_FOUND",l}var c=n[u]={exports:{}};t[u][0].call(c.
exports,function(e){var n=t[u][1][e];return s(n||e)},c,c.exports,e,t,n,i)}return n
[u].exports}for(var o="function"==typeof require&&require,u=0;u<i.length;u++)s(i
[u]);return s}return e}()({1:[function(e,t,n){"use strict";function i(e,t){return Object
.prototype.hasOwnProperty.call(e,t)}var r=typeof Uint8Array!="undefined"&&typeof 
Uint16Array!="undefined"&&typeof Int32Array!="undefined";n.assign=function(e){var t=
Array.prototype.slice.call(arguments,1);while(t.length){var n=t.shift();if(!n)continue;
if(typeof n!="object")throw new TypeError(n+"must be non-object");for(var r in n
)i(n,r)&&(e[r]=n[r])}return e},n.shrinkBuf=function(e,t){return e.length===t?e:e
.subarray?e.subarray(0,t):(e.length=t,e)};var s={arraySet:function(e,t,n,r,i){if(
t.subarray&&e.subarray){e.set(t.subarray(n,n+r),i);return}for(var s=0;s<r;s++)e[
i+s]=t[n+s]},flattenChunks:function(e){var t,n,r,i,s,o;r=0;for(t=0,n=e.length;t<
n;t++)r+=e[t].length;o=new Uint8Array(r),i=0;for(t=0,n=e.length;t<n;t++)s=e[t],o
.set(s,i),i+=s.length;return o}},o={arraySet:function(e,t,n,r,i){for(var s=0;s<r
;s++)e[i+s]=t[n+s]},flattenChunks:function(e){return[].concat.apply([],e)}};n.setTyped=
function(e){e?(n.Buf8=Uint8Array,n.Buf16=Uint16Array,n.Buf32=Int32Array,n.assign
(n,s)):(n.Buf8=Array,n.Buf16=Array,n.Buf32=Array,n.assign(n,o))},n.setTyped(r)},
{}],2:[function(e,t,n){"use strict";function f(e,t){if(t<65534)if(e.subarray&&s||!
e.subarray&&i)return String.fromCharCode.apply(null,r.shrinkBuf(e,t));var n="";for(
var o=0;o<t;o++)n+=String.fromCharCode(e[o]);return n}var r=e("./common"),i=!0,s=!0
;try{String.fromCharCode.apply(null,[0])}catch(o){i=!1}try{String.fromCharCode.apply
(null,new Uint8Array(1))}catch(o){s=!1}var u=new r.Buf8(256);for(var a=0;a<256;a++
)u[a]=a>=252?6:a>=248?5:a>=240?4:a>=224?3:a>=192?2:1;u[254]=u[254]=1,n.string2buf=
function(e){var t,n,i,s,o,u=e.length,a=0;for(s=0;s<u;s++)n=e.charCodeAt(s),(n&64512
)===55296&&s+1<u&&(i=e.charCodeAt(s+1),(i&64512)===56320&&(n=65536+(n-55296<<10)+
(i-56320),s++)),a+=n<128?1:n<2048?2:n<65536?3:4;t=new r.Buf8(a);for(o=0,s=0;o<a;
s++)n=e.charCodeAt(s),(n&64512)===55296&&s+1<u&&(i=e.charCodeAt(s+1),(i&64512)===56320&&
(n=65536+(n-55296<<10)+(i-56320),s++)),n<128?t[o++]=n:n<2048?(t[o++]=192|n>>>6,t
[o++]=128|n&63):n<65536?(t[o++]=224|n>>>12,t[o++]=128|n>>>6&63,t[o++]=128|n&63):
(t[o++]=240|n>>>18,t[o++]=128|n>>>12&63,t[o++]=128|n>>>6&63,t[o++]=128|n&63);return t
},n.buf2binstring=function(e){return f(e,e.length)},n.binstring2buf=function(e){
var t=new r.Buf8(e.length);for(var n=0,i=t.length;n<i;n++)t[n]=e.charCodeAt(n);return t
},n.buf2string=function(e,t){var n,r,i,s,o=t||e.length,a=new Array(o*2);for(r=0,
n=0;n<o;){i=e[n++];if(i<128){a[r++]=i;continue}s=u[i];if(s>4){a[r++]=65533,n+=s-1
;continue}i&=s===2?31:s===3?15:7;while(s>1&&n<o)i=i<<6|e[n++]&63,s--;if(s>1){a[r++
]=65533;continue}i<65536?a[r++]=i:(i-=65536,a[r++]=55296|i>>10&1023,a[r++]=56320|
i&1023)}return f(a,r)},n.utf8border=function(e,t){var n;t=t||e.length,t>e.length&&
(t=e.length),n=t-1;while(n>=0&&(e[n]&192)===128)n--;return n<0?t:n===0?t:n+u[e[n
]]>t?n:t}},{"./common":1}],3:[function(e,t,n){"use strict";function r(e,t,n,r){var i=
e&65535|0,s=e>>>16&65535|0,o=0;while(n!==0){o=n>2e3?2e3:n,n-=o;do i=i+t[r++]|0,s=
s+i|0;while(--o);i%=65521,s%=65521}return i|s<<16|0}t.exports=r},{}],4:[function(
e,t,n){"use strict";t.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH
:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1
,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED
:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE
:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}}
,{}],5:[function(e,t,n){"use strict";function r(){var e,t=[];for(var n=0;n<256;n++
){e=n;for(var r=0;r<8;r++)e=e&1?3988292384^e>>>1:e>>>1;t[n]=e}return t}function s
(e,t,n,r){var s=i,o=r+n;e^=-1;for(var u=r;u<o;u++)e=e>>>8^s[(e^t[u])&255];return e^-1
}var i=r();t.exports=s},{}],6:[function(e,t,n){"use strict";function r(){this.text=0
,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name=""
,this.comment="",this.hcrc=0,this.done=!1}t.exports=r},{}],7:[function(e,t,n){"use strict"
;var r=30,i=12;t.exports=function(t,n){var s,o,u,a,f,l,c,h,p,d,v,m,g,y,b,w,E,S,x
,T,N,C,k,L,A;s=t.state,o=t.next_in,L=t.input,u=o+(t.avail_in-5),a=t.next_out,A=t
.output,f=a-(n-t.avail_out),l=a+(t.avail_out-257),c=s.dmax,h=s.wsize,p=s.whave,d=
s.wnext,v=s.window,m=s.hold,g=s.bits,y=s.lencode,b=s.distcode,w=(1<<s.lenbits)-1
,E=(1<<s.distbits)-1;e:do{g<15&&(m+=L[o++]<<g,g+=8,m+=L[o++]<<g,g+=8),S=y[m&w];t
:for(;;){x=S>>>24,m>>>=x,g-=x,x=S>>>16&255;if(x===0)A[a++]=S&65535;else{if(!(x&16
)){if((x&64)===0){S=y[(S&65535)+(m&(1<<x)-1)];continue t}if(x&32){s.mode=i;break e
}t.msg="invalid literal/length code",s.mode=r;break e}T=S&65535,x&=15,x&&(g<x&&(
m+=L[o++]<<g,g+=8),T+=m&(1<<x)-1,m>>>=x,g-=x),g<15&&(m+=L[o++]<<g,g+=8,m+=L[o++]<<
g,g+=8),S=b[m&E];n:for(;;){x=S>>>24,m>>>=x,g-=x,x=S>>>16&255;if(!(x&16)){if((x&64
)===0){S=b[(S&65535)+(m&(1<<x)-1)];continue n}t.msg="invalid distance code",s.mode=
r;break e}N=S&65535,x&=15,g<x&&(m+=L[o++]<<g,g+=8,g<x&&(m+=L[o++]<<g,g+=8)),N+=m&
(1<<x)-1;if(N>c){t.msg="invalid distance too far back",s.mode=r;break e}m>>>=x,g-=
x,x=a-f;if(N>x){x=N-x;if(x>p&&s.sane){t.msg="invalid distance too far back",s.mode=
r;break e}C=0,k=v;if(d===0){C+=h-x;if(x<T){T-=x;do A[a++]=v[C++];while(--x);C=a-
N,k=A}}else if(d<x){C+=h+d-x,x-=d;if(x<T){T-=x;do A[a++]=v[C++];while(--x);C=0;if(
d<T){x=d,T-=x;do A[a++]=v[C++];while(--x);C=a-N,k=A}}}else{C+=d-x;if(x<T){T-=x;do A
[a++]=v[C++];while(--x);C=a-N,k=A}}while(T>2)A[a++]=k[C++],A[a++]=k[C++],A[a++]=
k[C++],T-=3;T&&(A[a++]=k[C++],T>1&&(A[a++]=k[C++]))}else{C=a-N;do A[a++]=A[C++],
A[a++]=A[C++],A[a++]=A[C++],T-=3;while(T>2);T&&(A[a++]=A[C++],T>1&&(A[a++]=A[C++
]))}break}}break}}while(o<u&&a<l);T=g>>3,o-=T,g-=T<<3,m&=(1<<g)-1,t.next_in=o,t.
next_out=a,t.avail_in=o<u?5+(u-o):5-(o-u),t.avail_out=a<l?257+(l-a):257-(a-l),s.
hold=m,s.bits=g;return}},{}],8:[function(e,t,n){"use strict";function it(e){return(
e>>>24&255)+(e>>>8&65280)+((e&65280)<<8)+((e&255)<<24)}function st(){this.mode=0
,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0
,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0
,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0
,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0
,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new r.Buf16(320),
this.work=new r.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0
,this.was=0}function ot(e){var t;return!e||!e.state?g:(t=e.state,e.total_in=e.total_out=
t.total=0,e.msg="",t.wrap&&(e.adler=t.wrap&1),t.mode=S,t.last=0,t.havedict=0,t.dmax=32768
,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new r.Buf32(et),t.distcode=t.distdyn=new 
r.Buf32(tt),t.sane=1,t.back=-1,d)}function ut(e){var t;return!e||!e.state?g:(t=e
.state,t.wsize=0,t.whave=0,t.wnext=0,ot(e))}function at(e,t){var n,r;return!e||!
e.state?g:(r=e.state,t<0?(n=0,t=-t):(n=(t>>4)+1,t<48&&(t&=15)),t&&(t<8||t>15)?g:
(r.window!==null&&r.wbits!==t&&(r.window=null),r.wrap=n,r.wbits=t,ut(e)))}function ft
(e,t){var n,r;return e?(r=new st,e.state=r,r.window=null,n=at(e,t),n!==d&&(e.state=
null),n):g}function lt(e){return ft(e,rt)}function dt(e){if(ct){var t;ht=new r.Buf32
(512),pt=new r.Buf32(32),t=0;while(t<144)e.lens[t++]=8;while(t<256)e.lens[t++]=9
;while(t<280)e.lens[t++]=7;while(t<288)e.lens[t++]=8;u(f,e.lens,0,288,ht,0,e.work
,{bits:9}),t=0;while(t<32)e.lens[t++]=5;u(l,e.lens,0,32,pt,0,e.work,{bits:5}),ct=!1
}e.lencode=ht,e.lenbits=9,e.distcode=pt,e.distbits=5}function vt(e,t,n,i){var s,
o=e.state;return o.window===null&&(o.wsize=1<<o.wbits,o.wnext=0,o.whave=0,o.window=new 
r.Buf8(o.wsize)),i>=o.wsize?(r.arraySet(o.window,t,n-o.wsize,o.wsize,0),o.wnext=0
,o.whave=o.wsize):(s=o.wsize-o.wnext,s>i&&(s=i),r.arraySet(o.window,t,n-i,s,o.wnext
),i-=s,i?(r.arraySet(o.window,t,n-i,i,0),o.wnext=i,o.whave=o.wsize):(o.wnext+=s,
o.wnext===o.wsize&&(o.wnext=0),o.whave<o.wsize&&(o.whave+=s))),0}function mt(e,t
){var n,et,tt,nt,rt,st,ot,ut,at,ft,lt,ct,ht,pt,mt=0,gt,yt,bt,wt,Et,St,xt,Tt,Nt=new 
r.Buf8(4),Ct,kt,Lt=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!e||!e.state||!
e.output||!e.input&&e.avail_in!==0)return g;n=e.state,n.mode===D&&(n.mode=P),rt=
e.next_out,tt=e.output,ot=e.avail_out,nt=e.next_in,et=e.input,st=e.avail_in,ut=n
.hold,at=n.bits,ft=st,lt=ot,Tt=d;e:for(;;)switch(n.mode){case S:if(n.wrap===0){n
.mode=P;break}while(at<16){if(st===0)break e;st--,ut+=et[nt++]<<at,at+=8}if(n.wrap&2&&
ut===35615){n.check=0,Nt[0]=ut&255,Nt[1]=ut>>>8&255,n.check=s(n.check,Nt,2,0),ut=0
,at=0,n.mode=x;break}n.flags=0,n.head&&(n.head.done=!1);if(!(n.wrap&1)||(((ut&255
)<<8)+(ut>>8))%31){e.msg="incorrect header check",n.mode=G;break}if((ut&15)!==E)
{e.msg="unknown compression method",n.mode=G;break}ut>>>=4,at-=4,xt=(ut&15)+8;if(
n.wbits===0)n.wbits=xt;else if(xt>n.wbits){e.msg="invalid window size",n.mode=G;
break}n.dmax=1<<xt,e.adler=n.check=1,n.mode=ut&512?M:D,ut=0,at=0;break;case x:while(
at<16){if(st===0)break e;st--,ut+=et[nt++]<<at,at+=8}n.flags=ut;if((n.flags&255)!==
E){e.msg="unknown compression method",n.mode=G;break}if(n.flags&57344){e.msg="unknown header flags set"
,n.mode=G;break}n.head&&(n.head.text=ut>>8&1),n.flags&512&&(Nt[0]=ut&255,Nt[1]=ut>>>8&255
,n.check=s(n.check,Nt,2,0)),ut=0,at=0,n.mode=T;case T:while(at<32){if(st===0)break e
;st--,ut+=et[nt++]<<at,at+=8}n.head&&(n.head.time=ut),n.flags&512&&(Nt[0]=ut&255
,Nt[1]=ut>>>8&255,Nt[2]=ut>>>16&255,Nt[3]=ut>>>24&255,n.check=s(n.check,Nt,4,0))
,ut=0,at=0,n.mode=N;case N:while(at<16){if(st===0)break e;st--,ut+=et[nt++]<<at,
at+=8}n.head&&(n.head.xflags=ut&255,n.head.os=ut>>8),n.flags&512&&(Nt[0]=ut&255,
Nt[1]=ut>>>8&255,n.check=s(n.check,Nt,2,0)),ut=0,at=0,n.mode=C;case C:if(n.flags&1024
){while(at<16){if(st===0)break e;st--,ut+=et[nt++]<<at,at+=8}n.length=ut,n.head&&
(n.head.extra_len=ut),n.flags&512&&(Nt[0]=ut&255,Nt[1]=ut>>>8&255,n.check=s(n.check
,Nt,2,0)),ut=0,at=0}else n.head&&(n.head.extra=null);n.mode=k;case k:if(n.flags&1024
){ct=n.length,ct>st&&(ct=st),ct&&(n.head&&(xt=n.head.extra_len-n.length,n.head.extra||
(n.head.extra=new Array(n.head.extra_len)),r.arraySet(n.head.extra,et,nt,ct,xt))
,n.flags&512&&(n.check=s(n.check,et,ct,nt)),st-=ct,nt+=ct,n.length-=ct);if(n.length
)break e}n.length=0,n.mode=L;case L:if(n.flags&2048){if(st===0)break e;ct=0;do xt=
et[nt+ct++],n.head&&xt&&n.length<65536&&(n.head.name+=String.fromCharCode(xt));while(
xt&&ct<st);n.flags&512&&(n.check=s(n.check,et,ct,nt)),st-=ct,nt+=ct;if(xt)break e
}else n.head&&(n.head.name=null);n.length=0,n.mode=A;case A:if(n.flags&4096){if(
st===0)break e;ct=0;do xt=et[nt+ct++],n.head&&xt&&n.length<65536&&(n.head.comment+=
String.fromCharCode(xt));while(xt&&ct<st);n.flags&512&&(n.check=s(n.check,et,ct,
nt)),st-=ct,nt+=ct;if(xt)break e}else n.head&&(n.head.comment=null);n.mode=O;case O
:if(n.flags&512){while(at<16){if(st===0)break e;st--,ut+=et[nt++]<<at,at+=8}if(ut!==
(n.check&65535)){e.msg="header crc mismatch",n.mode=G;break}ut=0,at=0}n.head&&(n
.head.hcrc=n.flags>>9&1,n.head.done=!0),e.adler=n.check=0,n.mode=D;break;case M:
while(at<32){if(st===0)break e;st--,ut+=et[nt++]<<at,at+=8}e.adler=n.check=it(ut
),ut=0,at=0,n.mode=_;case _:if(n.havedict===0)return e.next_out=rt,e.avail_out=ot
,e.next_in=nt,e.avail_in=st,n.hold=ut,n.bits=at,m;e.adler=n.check=1,n.mode=D;case D
:if(t===h||t===p)break e;case P:if(n.last){ut>>>=at&7,at-=at&7,n.mode=J;break}while(
at<3){if(st===0)break e;st--,ut+=et[nt++]<<at,at+=8}n.last=ut&1,ut>>>=1,at-=1;switch(
ut&3){case 0:n.mode=H;break;case 1:dt(n),n.mode=R;if(t===p){ut>>>=2,at-=2;break e
}break;case 2:n.mode=F;break;case 3:e.msg="invalid block type",n.mode=G}ut>>>=2,
at-=2;break;case H:ut>>>=at&7,at-=at&7;while(at<32){if(st===0)break e;st--,ut+=et
[nt++]<<at,at+=8}if((ut&65535)!==(ut>>>16^65535)){e.msg="invalid stored block lengths"
,n.mode=G;break}n.length=ut&65535,ut=0,at=0,n.mode=B;if(t===p)break e;case B:n.mode=
j;case j:ct=n.length;if(ct){ct>st&&(ct=st),ct>ot&&(ct=ot);if(ct===0)break e;r.arraySet
(tt,et,nt,ct,rt),st-=ct,nt+=ct,ot-=ct,rt+=ct,n.length-=ct;break}n.mode=D;break;case F
:while(at<14){if(st===0)break e;st--,ut+=et[nt++]<<at,at+=8}n.nlen=(ut&31)+257,ut>>>=5
,at-=5,n.ndist=(ut&31)+1,ut>>>=5,at-=5,n.ncode=(ut&15)+4,ut>>>=4,at-=4;if(n.nlen>286||
n.ndist>30){e.msg="too many length or distance symbols",n.mode=G;break}n.have=0,
n.mode=I;case I:while(n.have<n.ncode){while(at<3){if(st===0)break e;st--,ut+=et[
nt++]<<at,at+=8}n.lens[Lt[n.have++]]=ut&7,ut>>>=3,at-=3}while(n.have<19)n.lens[Lt
[n.have++]]=0;n.lencode=n.lendyn,n.lenbits=7,Ct={bits:n.lenbits},Tt=u(a,n.lens,0
,19,n.lencode,0,n.work,Ct),n.lenbits=Ct.bits;if(Tt){e.msg="invalid code lengths set"
,n.mode=G;break}n.have=0,n.mode=q;case q:while(n.have<n.nlen+n.ndist){for(;;){mt=
n.lencode[ut&(1<<n.lenbits)-1],gt=mt>>>24,yt=mt>>>16&255,bt=mt&65535;if(gt<=at)break;
if(st===0)break e;st--,ut+=et[nt++]<<at,at+=8}if(bt<16)ut>>>=gt,at-=gt,n.lens[n.
have++]=bt;else{if(bt===16){kt=gt+2;while(at<kt){if(st===0)break e;st--,ut+=et[nt++
]<<at,at+=8}ut>>>=gt,at-=gt;if(n.have===0){e.msg="invalid bit length repeat",n.mode=
G;break}xt=n.lens[n.have-1],ct=3+(ut&3),ut>>>=2,at-=2}else if(bt===17){kt=gt+3;while(
at<kt){if(st===0)break e;st--,ut+=et[nt++]<<at,at+=8}ut>>>=gt,at-=gt,xt=0,ct=3+(
ut&7),ut>>>=3,at-=3}else{kt=gt+7;while(at<kt){if(st===0)break e;st--,ut+=et[nt++
]<<at,at+=8}ut>>>=gt,at-=gt,xt=0,ct=11+(ut&127),ut>>>=7,at-=7}if(n.have+ct>n.nlen+
n.ndist){e.msg="invalid bit length repeat",n.mode=G;break}while(ct--)n.lens[n.have++
]=xt}}if(n.mode===G)break;if(n.lens[256]===0){e.msg="invalid code -- missing end-of-block"
,n.mode=G;break}n.lenbits=9,Ct={bits:n.lenbits},Tt=u(f,n.lens,0,n.nlen,n.lencode
,0,n.work,Ct),n.lenbits=Ct.bits;if(Tt){e.msg="invalid literal/lengths set",n.mode=
G;break}n.distbits=6,n.distcode=n.distdyn,Ct={bits:n.distbits},Tt=u(l,n.lens,n.nlen
,n.ndist,n.distcode,0,n.work,Ct),n.distbits=Ct.bits;if(Tt){e.msg="invalid distances set"
,n.mode=G;break}n.mode=R;if(t===p)break e;case R:n.mode=U;case U:if(st>=6&&ot>=258
){e.next_out=rt,e.avail_out=ot,e.next_in=nt,e.avail_in=st,n.hold=ut,n.bits=at,o(
e,lt),rt=e.next_out,tt=e.output,ot=e.avail_out,nt=e.next_in,et=e.input,st=e.avail_in
,ut=n.hold,at=n.bits,n.mode===D&&(n.back=-1);break}n.back=0;for(;;){mt=n.lencode
[ut&(1<<n.lenbits)-1],gt=mt>>>24,yt=mt>>>16&255,bt=mt&65535;if(gt<=at)break;if(st===0
)break e;st--,ut+=et[nt++]<<at,at+=8}if(yt&&(yt&240)===0){wt=gt,Et=yt,St=bt;for(
;;){mt=n.lencode[St+((ut&(1<<wt+Et)-1)>>wt)],gt=mt>>>24,yt=mt>>>16&255,bt=mt&65535
;if(wt+gt<=at)break;if(st===0)break e;st--,ut+=et[nt++]<<at,at+=8}ut>>>=wt,at-=wt
,n.back+=wt}ut>>>=gt,at-=gt,n.back+=gt,n.length=bt;if(yt===0){n.mode=$;break}if(
yt&32){n.back=-1,n.mode=D;break}if(yt&64){e.msg="invalid literal/length code",n.
mode=G;break}n.extra=yt&15,n.mode=z;case z:if(n.extra){kt=n.extra;while(at<kt){if(
st===0)break e;st--,ut+=et[nt++]<<at,at+=8}n.length+=ut&(1<<n.extra)-1,ut>>>=n.extra
,at-=n.extra,n.back+=n.extra}n.was=n.length,n.mode=W;case W:for(;;){mt=n.distcode
[ut&(1<<n.distbits)-1],gt=mt>>>24,yt=mt>>>16&255,bt=mt&65535;if(gt<=at)break;if(
st===0)break e;st--,ut+=et[nt++]<<at,at+=8}if((yt&240)===0){wt=gt,Et=yt,St=bt;for(
;;){mt=n.distcode[St+((ut&(1<<wt+Et)-1)>>wt)],gt=mt>>>24,yt=mt>>>16&255,bt=mt&65535
;if(wt+gt<=at)break;if(st===0)break e;st--,ut+=et[nt++]<<at,at+=8}ut>>>=wt,at-=wt
,n.back+=wt}ut>>>=gt,at-=gt,n.back+=gt;if(yt&64){e.msg="invalid distance code",n
.mode=G;break}n.offset=bt,n.extra=yt&15,n.mode=X;case X:if(n.extra){kt=n.extra;while(
at<kt){if(st===0)break e;st--,ut+=et[nt++]<<at,at+=8}n.offset+=ut&(1<<n.extra)-1
,ut>>>=n.extra,at-=n.extra,n.back+=n.extra}if(n.offset>n.dmax){e.msg="invalid distance too far back"
,n.mode=G;break}n.mode=V;case V:if(ot===0)break e;ct=lt-ot;if(n.offset>ct){ct=n.
offset-ct;if(ct>n.whave&&n.sane){e.msg="invalid distance too far back",n.mode=G;
break}ct>n.wnext?(ct-=n.wnext,ht=n.wsize-ct):ht=n.wnext-ct,ct>n.length&&(ct=n.length
),pt=n.window}else pt=tt,ht=rt-n.offset,ct=n.length;ct>ot&&(ct=ot),ot-=ct,n.length-=
ct;do tt[rt++]=pt[ht++];while(--ct);n.length===0&&(n.mode=U);break;case $:if(ot===0
)break e;tt[rt++]=n.length,ot--,n.mode=U;break;case J:if(n.wrap){while(at<32){if(
st===0)break e;st--,ut|=et[nt++]<<at,at+=8}lt-=ot,e.total_out+=lt,n.total+=lt,lt&&
(e.adler=n.check=n.flags?s(n.check,tt,lt,rt-lt):i(n.check,tt,lt,rt-lt)),lt=ot;if(
(n.flags?ut:it(ut))!==n.check){e.msg="incorrect data check",n.mode=G;break}ut=0,
at=0}n.mode=K;case K:if(n.wrap&&n.flags){while(at<32){if(st===0)break e;st--,ut+=
et[nt++]<<at,at+=8}if(ut!==(n.total&4294967295)){e.msg="incorrect length check",
n.mode=G;break}ut=0,at=0}n.mode=Q;case Q:Tt=v;break e;case G:Tt=y;break e;case Y
:return b;case Z:default:return g}e.next_out=rt,e.avail_out=ot,e.next_in=nt,e.avail_in=
st,n.hold=ut,n.bits=at;if(n.wsize||lt!==e.avail_out&&n.mode<G&&(n.mode<J||t!==c)
)if(vt(e,e.output,e.next_out,lt-e.avail_out))return n.mode=Y,b;return ft-=e.avail_in
,lt-=e.avail_out,e.total_in+=ft,e.total_out+=lt,n.total+=lt,n.wrap&&lt&&(e.adler=
n.check=n.flags?s(n.check,tt,lt,e.next_out-lt):i(n.check,tt,lt,e.next_out-lt)),e
.data_type=n.bits+(n.last?64:0)+(n.mode===D?128:0)+(n.mode===R||n.mode===B?256:0
),(ft===0&&lt===0||t===c)&&Tt===d&&(Tt=w),Tt}function gt(e){if(!e||!e.state)return g
;var t=e.state;return t.window&&(t.window=null),e.state=null,d}function yt(e,t){
var n;return!e||!e.state?g:(n=e.state,(n.wrap&2)===0?g:(n.head=t,t.done=!1,d))}function bt
(e,t){var n=t.length,r,s,o;if(!e||!e.state)return g;r=e.state;if(r.wrap!==0&&r.mode!==
_)return g;if(r.mode===_){s=1,s=i(s,t,n,0);if(s!==r.check)return y}return o=vt(e
,t,n,n),o?(r.mode=Y,b):(r.havedict=1,d)}var r=e("../utils/common"),i=e("./adler32"
),s=e("./crc32"),o=e("./inffast"),u=e("./inftrees"),a=0,f=1,l=2,c=4,h=5,p=6,d=0,
v=1,m=2,g=-2,y=-3,b=-4,w=-5,E=8,S=1,x=2,T=3,N=4,C=5,k=6,L=7,A=8,O=9,M=10,_=11,D=12
,P=13,H=14,B=15,j=16,F=17,I=18,q=19,R=20,U=21,z=22,W=23,X=24,V=25,$=26,J=27,K=28
,Q=29,G=30,Y=31,Z=32,et=852,tt=592,nt=15,rt=nt,ct=!0,ht,pt;n.inflateReset=ut,n.inflateReset2=
at,n.inflateResetKeep=ot,n.inflateInit=lt,n.inflateInit2=ft,n.inflate=mt,n.inflateEnd=
gt,n.inflateGetHeader=yt,n.inflateSetDictionary=bt,n.inflateInfo="pako inflate (from Nodeca project)"
},{"../utils/common":1,"./adler32":3,"./crc32":5,"./inffast":7,"./inftrees":9}],9
:[function(e,t,n){"use strict";var r=e("../utils/common"),i=15,s=852,o=592,u=0,a=1
,f=2,l=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163
,195,227,258,0,0],c=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19
,20,20,20,20,21,21,21,21,16,72,78],h=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193
,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],p=[16
,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28
,29,29,64,64];t.exports=function(t,n,d,v,m,g,y,b){var w=b.bits,E=0,S=0,x=0,T=0,N=0
,C=0,k=0,L=0,A=0,O=0,M,_,D,P,H,B=null,j=0,F,I=new r.Buf16(i+1),q=new r.Buf16(i+1
),R=null,U=0,z,W,X;for(E=0;E<=i;E++)I[E]=0;for(S=0;S<v;S++)I[n[d+S]]++;N=w;for(T=
i;T>=1;T--)if(I[T]!==0)break;N>T&&(N=T);if(T===0)return m[g++]=20971520,m[g++]=20971520
,b.bits=1,0;for(x=1;x<T;x++)if(I[x]!==0)break;N<x&&(N=x),L=1;for(E=1;E<=i;E++){L<<=1
,L-=I[E];if(L<0)return-1}if(L>0&&(t===u||T!==1))return-1;q[1]=0;for(E=1;E<i;E++)
q[E+1]=q[E]+I[E];for(S=0;S<v;S++)n[d+S]!==0&&(y[q[n[d+S]]++]=S);t===u?(B=R=y,F=19
):t===a?(B=l,j-=257,R=c,U-=257,F=256):(B=h,R=p,F=-1),O=0,S=0,E=x,H=g,C=N,k=0,D=-1
,A=1<<N,P=A-1;if(t===a&&A>s||t===f&&A>o)return 1;for(;;){z=E-k,y[S]<F?(W=0,X=y[S
]):y[S]>F?(W=R[U+y[S]],X=B[j+y[S]]):(W=96,X=0),M=1<<E-k,_=1<<C,x=_;do _-=M,m[H+(
O>>k)+_]=z<<24|W<<16|X|0;while(_!==0);M=1<<E-1;while(O&M)M>>=1;M!==0?(O&=M-1,O+=
M):O=0,S++;if(--I[E]===0){if(E===T)break;E=n[d+y[S]]}if(E>N&&(O&P)!==D){k===0&&(
k=N),H+=x,C=E-k,L=1<<C;while(C+k<T){L-=I[C+k];if(L<=0)break;C++,L<<=1}A+=1<<C;if(
t===a&&A>s||t===f&&A>o)return 1;D=O&P,m[D]=N<<24|C<<16|H-g|0}}return O!==0&&(m[H+
O]=E-k<<24|64<<16|0),b.bits=N,0}},{"../utils/common":1}],10:[function(e,t,n){"use strict"
;t.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error"
,"-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"
}},{}],11:[function(e,t,n){"use strict";function r(){this.input=null,this.next_in=0
,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0
,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}t.exports=
r},{}],"/lib/inflate.js":[function(e,t,n){"use strict";function c(e){if(!(this instanceof 
c))return new c(e);this.options=i.assign({chunkSize:16384,windowBits:0,to:""},e||
{});var t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t
.windowBits,t.windowBits===0&&(t.windowBits=-15)),t.windowBits>=0&&t.windowBits<16&&
(!e||!e.windowBits)&&(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&(t.windowBits&15
)===0&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this
.strm=new a,this.strm.avail_out=0;var n=r.inflateInit2(this.strm,t.windowBits);if(
n!==o.Z_OK)throw new Error(u[n]);this.header=new f,r.inflateGetHeader(this.strm,
this.header);if(t.dictionary){typeof t.dictionary=="string"?t.dictionary=s.string2buf
(t.dictionary):l.call(t.dictionary)==="[object ArrayBuffer]"&&(t.dictionary=new 
Uint8Array(t.dictionary));if(t.raw){n=r.inflateSetDictionary(this.strm,t.dictionary
);if(n!==o.Z_OK)throw new Error(u[n])}}}function h(e,t){var n=new c(t);n.push(e,!0
);if(n.err)throw n.msg||u[n.err];return n.result}function p(e,t){return t=t||{},
t.raw=!0,h(e,t)}var r=e("./zlib/inflate"),i=e("./utils/common"),s=e("./utils/strings"
),o=e("./zlib/constants"),u=e("./zlib/messages"),a=e("./zlib/zstream"),f=e("./zlib/gzheader"
),l=Object.prototype.toString;c.prototype.push=function(e,t){var n=this.strm,u=this
.options.chunkSize,a=this.options.dictionary,f,c,h,p,d,v=!1;if(this.ended)return!1
;c=t===~~t?t:t===!0?o.Z_FINISH:o.Z_NO_FLUSH,typeof e=="string"?n.input=s.binstring2buf
(e):l.call(e)==="[object ArrayBuffer]"?n.input=new Uint8Array(e):n.input=e,n.next_in=0
,n.avail_in=n.input.length;do{n.avail_out===0&&(n.output=new i.Buf8(u),n.next_out=0
,n.avail_out=u),f=r.inflate(n,o.Z_NO_FLUSH),f===o.Z_NEED_DICT&&a&&(f=r.inflateSetDictionary
(this.strm,a)),f===o.Z_BUF_ERROR&&v===!0&&(f=o.Z_OK,v=!1);if(f!==o.Z_STREAM_END&&
f!==o.Z_OK)return this.onEnd(f),this.ended=!0,!1;n.next_out&&(n.avail_out===0||f===
o.Z_STREAM_END||n.avail_in===0&&(c===o.Z_FINISH||c===o.Z_SYNC_FLUSH))&&(this.options
.to==="string"?(h=s.utf8border(n.output,n.next_out),p=n.next_out-h,d=s.buf2string
(n.output,h),n.next_out=p,n.avail_out=u-p,p&&i.arraySet(n.output,n.output,h,p,0)
,this.onData(d)):this.onData(i.shrinkBuf(n.output,n.next_out))),n.avail_in===0&&
n.avail_out===0&&(v=!0)}while((n.avail_in>0||n.avail_out===0)&&f!==o.Z_STREAM_END
);return f===o.Z_STREAM_END&&(c=o.Z_FINISH),c===o.Z_FINISH?(f=r.inflateEnd(this.
strm),this.onEnd(f),this.ended=!0,f===o.Z_OK):c===o.Z_SYNC_FLUSH?(this.onEnd(o.Z_OK
),n.avail_out=0,!0):!0},c.prototype.onData=function(e){this.chunks.push(e)},c.prototype
.onEnd=function(e){e===o.Z_OK&&(this.options.to==="string"?this.result=this.chunks
.join(""):this.result=i.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this
.msg=this.strm.msg},n.Inflate=c,n.inflate=h,n.inflateRaw=p,n.ungzip=h},{"./utils/common"
:1,"./utils/strings":2,"./zlib/constants":4,"./zlib/gzheader":6,"./zlib/inflate"
:8,"./zlib/messages":10,"./zlib/zstream":11}]},{},[])("/lib/inflate.js")})

!function(u,D){"object"==typeof exports&&"undefined"!=typeof module?module.exports=D():"function"==typeof define&&define.amd?define(D):u.JSON5=D()}(this,function(){"use strict";function u(u,D){return u(D={exports:{}},D.exports),D.exports}var D=u(function(u){var D=u.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=D)}),e=u(function(u){var D=u.exports={version:"2.6.5"};"number"==typeof __e&&(__e=D)}),t=(e.version,function(u){return"object"==typeof u?null!==u:"function"==typeof u}),r=function(u){if(!t(u))throw TypeError(u+" is not an object!");return u},F=function(u){try{return!!u()}catch(u){return!0}},n=!F(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a}),C=D.document,A=t(C)&&t(C.createElement),i=!n&&!F(function(){return 7!=Object.defineProperty((u="div",A?C.createElement(u):{}),"a",{get:function(){return 7}}).a;var u}),E=Object.defineProperty,o={f:n?Object.defineProperty:function(u,D,e){if(r(u),D=function(u,D){if(!t(u))return u;var e,r;if(D&&"function"==typeof(e=u.toString)&&!t(r=e.call(u)))return r;if("function"==typeof(e=u.valueOf)&&!t(r=e.call(u)))return r;if(!D&&"function"==typeof(e=u.toString)&&!t(r=e.call(u)))return r;throw TypeError("Can't convert object to primitive value")}(D,!0),r(e),i)try{return E(u,D,e)}catch(u){}if("get"in e||"set"in e)throw TypeError("Accessors not supported!");return"value"in e&&(u[D]=e.value),u}},a=n?function(u,D,e){return o.f(u,D,function(u,D){return{enumerable:!(1&u),configurable:!(2&u),writable:!(4&u),value:D}}(1,e))}:function(u,D,e){return u[D]=e,u},c={}.hasOwnProperty,B=function(u,D){return c.call(u,D)},s=0,f=Math.random(),l=u(function(u){var t=D["__core-js_shared__"]||(D["__core-js_shared__"]={});(u.exports=function(u,D){return t[u]||(t[u]=void 0!==D?D:{})})("versions",[]).push({version:e.version,mode:"global",copyright:"© 2019 Denis Pushkarev (zloirock.ru)"})})("native-function-to-string",Function.toString),d=u(function(u){var t,r="Symbol(".concat(void 0===(t="src")?"":t,")_",(++s+f).toString(36)),F=(""+l).split("toString");e.inspectSource=function(u){return l.call(u)},(u.exports=function(u,e,t,n){var C="function"==typeof t;C&&(B(t,"name")||a(t,"name",e)),u[e]!==t&&(C&&(B(t,r)||a(t,r,u[e]?""+u[e]:F.join(String(e)))),u===D?u[e]=t:n?u[e]?u[e]=t:a(u,e,t):(delete u[e],a(u,e,t)))})(Function.prototype,"toString",function(){return"function"==typeof this&&this[r]||l.call(this)})}),v=function(u,D,e){if(function(u){if("function"!=typeof u)throw TypeError(u+" is not a function!")}(u),void 0===D)return u;switch(e){case 1:return function(e){return u.call(D,e)};case 2:return function(e,t){return u.call(D,e,t)};case 3:return function(e,t,r){return u.call(D,e,t,r)}}return function(){return u.apply(D,arguments)}},p=function(u,t,r){var F,n,C,A,i=u&p.F,E=u&p.G,o=u&p.S,c=u&p.P,B=u&p.B,s=E?D:o?D[t]||(D[t]={}):(D[t]||{}).prototype,f=E?e:e[t]||(e[t]={}),l=f.prototype||(f.prototype={});for(F in E&&(r=t),r)C=((n=!i&&s&&void 0!==s[F])?s:r)[F],A=B&&n?v(C,D):c&&"function"==typeof C?v(Function.call,C):C,s&&d(s,F,C,u&p.U),f[F]!=C&&a(f,F,A),c&&l[F]!=C&&(l[F]=C)};D.core=e,p.F=1,p.G=2,p.S=4,p.P=8,p.B=16,p.W=32,p.U=64,p.R=128;var h,m=p,g=Math.ceil,y=Math.floor,w=function(u){return isNaN(u=+u)?0:(u>0?y:g)(u)},S=(h=!1,function(u,D){var e,t,r=String(function(u){if(null==u)throw TypeError("Can't call method on  "+u);return u}(u)),F=w(D),n=r.length;return F<0||F>=n?h?"":void 0:(e=r.charCodeAt(F))<55296||e>56319||F+1===n||(t=r.charCodeAt(F+1))<56320||t>57343?h?r.charAt(F):e:h?r.slice(F,F+2):t-56320+(e-55296<<10)+65536});m(m.P,"String",{codePointAt:function(u){return S(this,u)}});e.String.codePointAt;var b=Math.max,x=Math.min,N=String.fromCharCode,P=String.fromCodePoint;m(m.S+m.F*(!!P&&1!=P.length),"String",{fromCodePoint:function(u){for(var D,e,t,r=arguments,F=[],n=arguments.length,C=0;n>C;){if(D=+r[C++],t=1114111,((e=w(e=D))<0?b(e+t,0):x(e,t))!==D)throw RangeError(D+" is not a valid code point");F.push(D<65536?N(D):N(55296+((D-=65536)>>10),D%1024+56320))}return F.join("")}});e.String.fromCodePoint;var _,I,O,j,V,J,M,k,L,T,z,H,$,R,G={Space_Separator:/[\u1680\u2000-\u200A\u202F\u205F\u3000]/,ID_Start:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/,ID_Continue:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/},U={isSpaceSeparator:function(u){return"string"==typeof u&&G.Space_Separator.test(u)},isIdStartChar:function(u){return"string"==typeof u&&(u>="a"&&u<="z"||u>="A"&&u<="Z"||"$"===u||"_"===u||G.ID_Start.test(u))},isIdContinueChar:function(u){return"string"==typeof u&&(u>="a"&&u<="z"||u>="A"&&u<="Z"||u>="0"&&u<="9"||"$"===u||"_"===u||"‌"===u||"‍"===u||G.ID_Continue.test(u))},isDigit:function(u){return"string"==typeof u&&/[0-9]/.test(u)},isHexDigit:function(u){return"string"==typeof u&&/[0-9A-Fa-f]/.test(u)}};function Z(){for(T="default",z="",H=!1,$=1;;){R=q();var u=X[T]();if(u)return u}}function q(){if(_[j])return String.fromCodePoint(_.codePointAt(j))}function W(){var u=q();return"\n"===u?(V++,J=0):u?J+=u.length:J++,u&&(j+=u.length),u}var X={default:function(){switch(R){case"\t":case"\v":case"\f":case" ":case" ":case"\ufeff":case"\n":case"\r":case"\u2028":case"\u2029":return void W();case"/":return W(),void(T="comment");case void 0:return W(),K("eof")}if(!U.isSpaceSeparator(R))return X[I]();W()},comment:function(){switch(R){case"*":return W(),void(T="multiLineComment");case"/":return W(),void(T="singleLineComment")}throw tu(W())},multiLineComment:function(){switch(R){case"*":return W(),void(T="multiLineCommentAsterisk");case void 0:throw tu(W())}W()},multiLineCommentAsterisk:function(){switch(R){case"*":return void W();case"/":return W(),void(T="default");case void 0:throw tu(W())}W(),T="multiLineComment"},singleLineComment:function(){switch(R){case"\n":case"\r":case"\u2028":case"\u2029":return W(),void(T="default");case void 0:return W(),K("eof")}W()},value:function(){switch(R){case"{":case"[":return K("punctuator",W());case"n":return W(),Q("ull"),K("null",null);case"t":return W(),Q("rue"),K("boolean",!0);case"f":return W(),Q("alse"),K("boolean",!1);case"-":case"+":return"-"===W()&&($=-1),void(T="sign");case".":return z=W(),void(T="decimalPointLeading");case"0":return z=W(),void(T="zero");case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":return z=W(),void(T="decimalInteger");case"I":return W(),Q("nfinity"),K("numeric",1/0);case"N":return W(),Q("aN"),K("numeric",NaN);case'"':case"'":return H='"'===W(),z="",void(T="string")}throw tu(W())},identifierNameStartEscape:function(){if("u"!==R)throw tu(W());W();var u=Y();switch(u){case"$":case"_":break;default:if(!U.isIdStartChar(u))throw Fu()}z+=u,T="identifierName"},identifierName:function(){switch(R){case"$":case"_":case"‌":case"‍":return void(z+=W());case"\\":return W(),void(T="identifierNameEscape")}if(!U.isIdContinueChar(R))return K("identifier",z);z+=W()},identifierNameEscape:function(){if("u"!==R)throw tu(W());W();var u=Y();switch(u){case"$":case"_":case"‌":case"‍":break;default:if(!U.isIdContinueChar(u))throw Fu()}z+=u,T="identifierName"},sign:function(){switch(R){case".":return z=W(),void(T="decimalPointLeading");case"0":return z=W(),void(T="zero");case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":return z=W(),void(T="decimalInteger");case"I":return W(),Q("nfinity"),K("numeric",$*(1/0));case"N":return W(),Q("aN"),K("numeric",NaN)}throw tu(W())},zero:function(){switch(R){case".":return z+=W(),void(T="decimalPoint");case"e":case"E":return z+=W(),void(T="decimalExponent");case"x":case"X":return z+=W(),void(T="hexadecimal")}return K("numeric",0*$)},decimalInteger:function(){switch(R){case".":return z+=W(),void(T="decimalPoint");case"e":case"E":return z+=W(),void(T="decimalExponent")}if(!U.isDigit(R))return K("numeric",$*Number(z));z+=W()},decimalPointLeading:function(){if(U.isDigit(R))return z+=W(),void(T="decimalFraction");throw tu(W())},decimalPoint:function(){switch(R){case"e":case"E":return z+=W(),void(T="decimalExponent")}return U.isDigit(R)?(z+=W(),void(T="decimalFraction")):K("numeric",$*Number(z))},decimalFraction:function(){switch(R){case"e":case"E":return z+=W(),void(T="decimalExponent")}if(!U.isDigit(R))return K("numeric",$*Number(z));z+=W()},decimalExponent:function(){switch(R){case"+":case"-":return z+=W(),void(T="decimalExponentSign")}if(U.isDigit(R))return z+=W(),void(T="decimalExponentInteger");throw tu(W())},decimalExponentSign:function(){if(U.isDigit(R))return z+=W(),void(T="decimalExponentInteger");throw tu(W())},decimalExponentInteger:function(){if(!U.isDigit(R))return K("numeric",$*Number(z));z+=W()},hexadecimal:function(){if(U.isHexDigit(R))return z+=W(),void(T="hexadecimalInteger");throw tu(W())},hexadecimalInteger:function(){if(!U.isHexDigit(R))return K("numeric",$*Number(z));z+=W()},string:function(){switch(R){case"\\":return W(),void(z+=function(){switch(q()){case"b":return W(),"\b";case"f":return W(),"\f";case"n":return W(),"\n";case"r":return W(),"\r";case"t":return W(),"\t";case"v":return W(),"\v";case"0":if(W(),U.isDigit(q()))throw tu(W());return"\0";case"x":return W(),function(){var u="",D=q();if(!U.isHexDigit(D))throw tu(W());if(u+=W(),D=q(),!U.isHexDigit(D))throw tu(W());return u+=W(),String.fromCodePoint(parseInt(u,16))}();case"u":return W(),Y();case"\n":case"\u2028":case"\u2029":return W(),"";case"\r":return W(),"\n"===q()&&W(),"";case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":case void 0:throw tu(W())}return W()}());case'"':return H?(W(),K("string",z)):void(z+=W());case"'":return H?void(z+=W()):(W(),K("string",z));case"\n":case"\r":throw tu(W());case"\u2028":case"\u2029":!function(u){console.warn("JSON5: '"+nu(u)+"' in strings is not valid ECMAScript; consider escaping")}(R);break;case void 0:throw tu(W())}z+=W()},start:function(){switch(R){case"{":case"[":return K("punctuator",W())}T="value"},beforePropertyName:function(){switch(R){case"$":case"_":return z=W(),void(T="identifierName");case"\\":return W(),void(T="identifierNameStartEscape");case"}":return K("punctuator",W());case'"':case"'":return H='"'===W(),void(T="string")}if(U.isIdStartChar(R))return z+=W(),void(T="identifierName");throw tu(W())},afterPropertyName:function(){if(":"===R)return K("punctuator",W());throw tu(W())},beforePropertyValue:function(){T="value"},afterPropertyValue:function(){switch(R){case",":case"}":return K("punctuator",W())}throw tu(W())},beforeArrayValue:function(){if("]"===R)return K("punctuator",W());T="value"},afterArrayValue:function(){switch(R){case",":case"]":return K("punctuator",W())}throw tu(W())},end:function(){throw tu(W())}};function K(u,D){return{type:u,value:D,line:V,column:J}}function Q(u){for(var D=0,e=u;D<e.length;D+=1){var t=e[D];if(q()!==t)throw tu(W());W()}}function Y(){for(var u="",D=4;D-- >0;){var e=q();if(!U.isHexDigit(e))throw tu(W());u+=W()}return String.fromCodePoint(parseInt(u,16))}var uu={start:function(){if("eof"===M.type)throw ru();Du()},beforePropertyName:function(){switch(M.type){case"identifier":case"string":return k=M.value,void(I="afterPropertyName");case"punctuator":return void eu();case"eof":throw ru()}},afterPropertyName:function(){if("eof"===M.type)throw ru();I="beforePropertyValue"},beforePropertyValue:function(){if("eof"===M.type)throw ru();Du()},beforeArrayValue:function(){if("eof"===M.type)throw ru();"punctuator"!==M.type||"]"!==M.value?Du():eu()},afterPropertyValue:function(){if("eof"===M.type)throw ru();switch(M.value){case",":return void(I="beforePropertyName");case"}":eu()}},afterArrayValue:function(){if("eof"===M.type)throw ru();switch(M.value){case",":return void(I="beforeArrayValue");case"]":eu()}},end:function(){}};function Du(){var u;switch(M.type){case"punctuator":switch(M.value){case"{":u={};break;case"[":u=[]}break;case"null":case"boolean":case"numeric":case"string":u=M.value}if(void 0===L)L=u;else{var D=O[O.length-1];Array.isArray(D)?D.push(u):D[k]=u}if(null!==u&&"object"==typeof u)O.push(u),I=Array.isArray(u)?"beforeArrayValue":"beforePropertyName";else{var e=O[O.length-1];I=null==e?"end":Array.isArray(e)?"afterArrayValue":"afterPropertyValue"}}function eu(){O.pop();var u=O[O.length-1];I=null==u?"end":Array.isArray(u)?"afterArrayValue":"afterPropertyValue"}function tu(u){return Cu(void 0===u?"JSON5: invalid end of input at "+V+":"+J:"JSON5: invalid character '"+nu(u)+"' at "+V+":"+J)}function ru(){return Cu("JSON5: invalid end of input at "+V+":"+J)}function Fu(){return Cu("JSON5: invalid identifier character at "+V+":"+(J-=5))}function nu(u){var D={"'":"\\'",'"':'\\"',"\\":"\\\\","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\v":"\\v","\0":"\\0","\u2028":"\\u2028","\u2029":"\\u2029"};if(D[u])return D[u];if(u<" "){var e=u.charCodeAt(0).toString(16);return"\\x"+("00"+e).substring(e.length)}return u}function Cu(u){var D=new SyntaxError(u);return D.lineNumber=V,D.columnNumber=J,D}return{parse:function(u,D){_=String(u),I="start",O=[],j=0,V=1,J=0,M=void 0,k=void 0,L=void 0;do{M=Z(),uu[I]()}while("eof"!==M.type);return"function"==typeof D?function u(D,e,t){var r=D[e];if(null!=r&&"object"==typeof r)for(var F in r){var n=u(r,F,t);void 0===n?delete r[F]:r[F]=n}return t.call(D,e,r)}({"":L},"",D):L},stringify:function(u,D,e){var t,r,F,n=[],C="",A="";if(null==D||"object"!=typeof D||Array.isArray(D)||(e=D.space,F=D.quote,D=D.replacer),"function"==typeof D)r=D;else if(Array.isArray(D)){t=[];for(var i=0,E=D;i<E.length;i+=1){var o=E[i],a=void 0;"string"==typeof o?a=o:("number"==typeof o||o instanceof String||o instanceof Number)&&(a=String(o)),void 0!==a&&t.indexOf(a)<0&&t.push(a)}}return e instanceof Number?e=Number(e):e instanceof String&&(e=String(e)),"number"==typeof e?e>0&&(e=Math.min(10,Math.floor(e)),A="          ".substr(0,e)):"string"==typeof e&&(A=e.substr(0,10)),c("",{"":u});function c(u,D){var e=D[u];switch(null!=e&&("function"==typeof e.toJSON5?e=e.toJSON5(u):"function"==typeof e.toJSON&&(e=e.toJSON(u))),r&&(e=r.call(D,u,e)),e instanceof Number?e=Number(e):e instanceof String?e=String(e):e instanceof Boolean&&(e=e.valueOf()),e){case null:return"null";case!0:return"true";case!1:return"false"}return"string"==typeof e?B(e):"number"==typeof e?String(e):"object"==typeof e?Array.isArray(e)?function(u){if(n.indexOf(u)>=0)throw TypeError("Converting circular structure to JSON5");n.push(u);var D=C;C+=A;for(var e,t=[],r=0;r<u.length;r++){var F=c(String(r),u);t.push(void 0!==F?F:"null")}if(0===t.length)e="[]";else if(""===A){var i=t.join(",");e="["+i+"]"}else{var E=",\n"+C,o=t.join(E);e="[\n"+C+o+",\n"+D+"]"}return n.pop(),C=D,e}(e):function(u){if(n.indexOf(u)>=0)throw TypeError("Converting circular structure to JSON5");n.push(u);var D=C;C+=A;for(var e,r,F=t||Object.keys(u),i=[],E=0,o=F;E<o.length;E+=1){var a=o[E],B=c(a,u);if(void 0!==B){var f=s(a)+":";""!==A&&(f+=" "),f+=B,i.push(f)}}if(0===i.length)e="{}";else if(""===A)r=i.join(","),e="{"+r+"}";else{var l=",\n"+C;r=i.join(l),e="{\n"+C+r+",\n"+D+"}"}return n.pop(),C=D,e}(e):void 0}function B(u){for(var D={"'":.1,'"':.2},e={"'":"\\'",'"':'\\"',"\\":"\\\\","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\v":"\\v","\0":"\\0","\u2028":"\\u2028","\u2029":"\\u2029"},t="",r=0;r<u.length;r++){var n=u[r];switch(n){case"'":case'"':D[n]++,t+=n;continue;case"\0":if(U.isDigit(u[r+1])){t+="\\x00";continue}}if(e[n])t+=e[n];else if(n<" "){var C=n.charCodeAt(0).toString(16);t+="\\x"+("00"+C).substring(C.length)}else t+=n}var A=F||Object.keys(D).reduce(function(u,e){return D[u]<D[e]?u:e});return A+(t=t.replace(new RegExp(A,"g"),e[A]))+A}function s(u){if(0===u.length)return B(u);var D=String.fromCodePoint(u.codePointAt(0));if(!U.isIdStartChar(D))return B(u);for(var e=D.length;e<u.length;e++)if(!U.isIdContinueChar(String.fromCodePoint(u.codePointAt(e))))return B(u);return u}}}});

/**
 * A simple interface for handling & preserving numerical coordinates and dimensions.
 * @typedef Dimensions
 * @property {String} unit The unit of measurement that applied to all values.
 * @property {Object} prev Previous set of coordinates.
 */
 class Dimensions {
    static allowedProps = ['x', 'x1', 'x2', 'y', 'y1', 'y2', 'z', 'count',
        'size', 'height', 'width', 'margin', 'top', 'right', 'bottom', 'left',
        'start', 'stop'];

    /**
     * Load the values into the object.
     * @param {Object} obj The primary object to copy values from.
     * @param {String} [unit = 'px'] Unit to append to numerical values with valAsStyleStr(). 
     * @param {OBject} [prevObj = null] Optional object to initialize previous values with.
     */
    constructor(obj, unit = 'px', prevObj = null) {
        this.initFrom(obj, unit, true, prevObj)
    }

    /** Return the property value as a string with the unit appended. */
    valAsStyleStr(propName) {
        return `${this[propName]}${this.unit}`;
    }

    /**
     * Find managed properties in object and copy their values.
     * @param {Object} obj Object to search for properties.
     * @returns Reference to this.
     */
    set(obj) {
        for (const prop of this._managedProps) {
            if (prop in obj) this[prop] = obj[prop];
        }

        return this;
    }

    /**
     * Duplicate known values from any Object. Reset managed values and previous dimensions.
     * @param {Object} obj The object to find values in.
     * @param {String} unit The unit of measurement that applied to all values.
     * @param {Boolean} [initPrev = true] Whether to create & initialize the prev object.
     * @param {OBject} [prevObj = null] Optional object to initialize previous values with.
     */
    initFrom(obj, unit = 'px', initPrev = true, prevObj = null) {
        const self = this;
        this.unit = unit;
        this._managedProps = new Set();
        if (initPrev) this.prev = {};

        for (const prop of Dimensions.allowedProps) {
            if (prop in obj) {
                this._managedProps.add(prop);
                this[prop] = obj[prop];
                if (initPrev) this.prev[prop] = prevObj? prevObj[prop]: 0;

                // Add a getter function for the property to be used with a CSS style
                Object.defineProperty(this, `${prop}Style`, {
                    get: function() { return self.valAsStyleStr(prop); }
                });
            }
        }

        return this;
    }

    /**
     * Duplicate another Dimensions object.
     * @param {Dimensions} other The object to copy from.
     */
    copyFrom(other) {
        this.initFrom(other, other.unit, false);
        this.prev = {};

        for (const prop of other.prev) {
            this.prev[prop] = other.prev[prop];
        }

        return this;
    }

    /** Backup the current values for future reference. */
    preserve() {
        this.prev = {};
        for (const prop of this._managedProps) {
            this.prev[prop] = this[prop];
        }

        return this;
    }
}


/**
 * Manage display info associated with the node.
 * @typedef NodeDisplayData
 */
class NodeDisplayData {
    constructor() {
        this.nameWidthPx = 1; // Width of the label in pixels as computed by Layout
        this.numLeaves = 0; // Set by Layout
        this.minimized = false; // When true, do not draw children
        this.hidden = false; // Do add to matrix at all
        this.filtered = false; // Node is a child to be shown w/partially collapsed parent
        this.filterParent = null; // When filtered, reference to FilterNode container
        this.manuallyExpanded = false; // Node was pre-collapsed but expanded by user

        this.dims = new Dimensions({ x: 1e-6, y: 1e-6, width: 1, height: 1 });
        this.dims.preserve();
    }
}

/**
 * Essentially the same as a JSON object from the model tree,
 * with some utility functions.
 * @typedef {TreeNode}
 * @property {Object} draw Information used for node display.
 * @property {Number} depth The index of the column this node appears in.
 */
class TreeNode {
    /**
     * Absorb all the properties of the provided JSON object from the model tree.
     * @param {Object} origNode The node to work from.
     * @param {Object} attribNames Names of variables in the model.
     */
    constructor(origNode, attribNames, parent) {
        // Merge all of the props from the original JSON tree node to us.
        Object.assign(this, origNode);
        if (attribNames.descendants != 'children') {
            this.children = this[attribNames.descendants];
            delete this[attribNames.descendants];
        }

        this.parent = parent;

        // All nodes connected to this one as either a source or target
        this.connSources = new Set();
        this.connTargets = new Set();

        this.sourceParentSet = new Set();
        this.targetParentSet = new Set();

        // Node display data.
        this.draw = this._newDisplayData()

        this.childNames = new Set(); // Set by ModelData
        this.depth = -1; // Set by ModelData
        this.id = -1; // Set by ModelData
        this.path = ''; // Set by ModelData
        this.numDescendants = 0; // Set by ModelData

        this.rootIndex = -1;
    }

    _newDisplayData() {
        return new NodeDisplayData();
    }

    /** In the matrix grid, draw a box around variables that share the same boxAncestor() */
    boxAncestor() {
        return this.isInputOrOutput()? this.parent : null;
    }

    // Accessor functions for this.draw.minimized - whether or not to draw children
    minimize() { this.draw.minimized = true; return this; }
    expand() { this.draw.minimized = false; return this; }

    // Accessor functions for this.draw.hidden - whether to draw at all
    hide() { this.draw.hidden = true; return this; }
    show() { this.draw.hidden = false; return this; }

    /**
     * Create a backup of our position and other info.
     * @param {number} leafNum Identify this as the nth leaf of the tree
     */
    preserveDims(leafNum) {
        this.draw.dims.preserve();

        if (this.rootIndex < 0) this.rootIndex = leafNum;
        this.prevRootIndex = this.rootIndex;
    }

    /**
     * Determine if a children array exists and has members.
     * @param {string} [childrenPropName = 'children'] Usually "children", but
     *   some subclasses may have additional child arrays.
     * @return {boolean} True if the children property is an Array and length > 0.
     */
    hasChildren(childrenPropName = 'children') {
        return (Array.isPopulatedArray(this[childrenPropName]));
    }

    /** True if this.type is 'input' or 'unconnected_input'. */
    isInput() { return this.type.match(/^(input|unconnected_input)$/); }

    /** True if this is an input and connected. */
    isConnectedInput() { return (this.type == 'input'); }

    /** True if this an input and unconnected. */
    isUnconnectedInput() { return (this.type == 'unconnected_input'); }

    /** True if this.type is 'output'. */
    isOutput() { return (this.type == 'output'); }

    /** True if this is the root node in the model */
    isRoot() { return (this.type == 'root'); }

    /** True if this.type is 'input', 'unconnected_input', or 'output'. */
    isInputOrOutput() { return this.type.match(/^(output|input|unconnected_input)$/); }

    /** True if it's a group */
    isGroup() { return this.type == 'group'; }

    /** True if this is a "fake" node that manages filtered children. */
    isFilter() { return (this.type == 'filter'); }

    /** True if this node can use filters (always false for base class) */
    canFilter() { return false; } 

    /** Not connectable if this is an input group or parents are minimized. */
    isConnectable() {
        if (this.isInputOrOutput() && !(this.hasChildren() ||
            this.parent.draw.minimized)) return true;

        return this.draw.minimized;
    }

    /** Return false if the node is hidden, or filtered */
    isVisible() {
        return !(this.draw.hidden || this.draw.filtered);
    }

    /** Return true if there are no children */
    isLeaf() {
        return (!this.hasChildren());
    }

    /** True if node is not hidden and has no visible children */
    isVisibleLeaf() {
        if (this.draw.hidden || this.draw.filtered) return false; // Any explicitly hidden node
        if (this.isInputOrOutput()) return !this.draw.filtered; // Variable
        if (this.isLeaf()) return true; // Group w/out children
        return this.draw.minimized; // Collapsed non-variable
    }

    /** True if this is a variable and will be displayed as partially collapsed. */
    isFilteredVariable() {
        return (this.isInputOrOutput() && this.draw.filtered);
    }

    /**
     * Look for the supplied node in the set of child names.
     * @param {TreeNode} compareNode The node to look for.
     * @param {Boolean} includeSelf If true, return true if compareNode is us.
     * @returns {Boolean} True if a match is found, otherwise false.
     */
    hasNodeInChildren(compareNode, includeSelf = false) {
        if (includeSelf && compareNode === this) return true;
        return this.childNames.has(compareNode.path);
    }

    /** Look for the supplied node in the parentage of this one.
     * @param {TreeNode} compareNode The node to look for.
     * @param {TreeNode} [parentLimit = null] Stop searching at this common parent.
     * @returns {Boolean} True if the node is found, otherwise false.
     */
    hasParent(compareNode, parentLimit = null, includeSelf = false) {
        if (includeSelf && compareNode === this) return true;
        for (let obj = this.parent; obj != null && obj !== parentLimit; obj = obj.parent) {
            if (obj === compareNode) {
                return true;
            }
        }

        return false;
    }

    /**
     * Look for the supplied node in the lineage of this one.
     * @param {TreeNode} compareNode The node to look for.
     * @param {TreeNode} [parentLimit = null] Stop searching at this common parent.
     * @returns {Boolean} True if the node is found, otherwise false.
     */
    hasNode(compareNode, parentLimit = null) {
        if (this.type == 'root') return true;

        if (this === compareNode) return true;

        // Check parents first.
        if (this.hasParent(compareNode, parentLimit)) return true;

        return this.hasNodeInChildren(compareNode);
    }

    /**
     * Find the closest parent shared by two nodes; farthest should be tree root.
     * @param {TreeNode} other Another node to compare parents with.
     * @returns {TreeNode} The first common parent found.
     */
    nearestCommonParent(other) {
        for (let myParent = this.parent; myParent != null; myParent = myParent.parent)
            for (let otherParent = other.parent; otherParent != null; otherParent = otherParent.parent)
                if (myParent === otherParent) return myParent;

        // Should never get here because root is parent of all
        debugInfo("No common parent found between two nodes: ", this, other);
        return null;
    }

    _preCollapseDepth() { return Precollapse.grpDepthStart; }

    /**
     * If the node has a lot of descendants and it wasn't manually expanded,
     * minimize it.
     * @param {Number} depthCount The number of nodes at the next depth down.
     * @returns {Boolean} True if minimized here, false otherwise.
     */
    minimizeIfLarge(depthCount) {
        if (!(this.isRoot() || this.draw.manuallyExpanded) &&
            (this.depth >= this._preCollapseDepth() &&
                this.numDescendants > Precollapse.threshold &&
                this.children.length > Precollapse.children - this.depth &&
                depthCount > Precollapse.depthLimit)) {
            debugInfo(`Precollapsing node ${this.path}`)
            this.minimize();
            return true;
        }

        return false;
    }

    /**
     * Convert a path to a string that's safe to use as an HTML id. Escapes
     * space, greater-than, less-than, period, and colon characters.
     * @param {String} path The name to convert.
     * @returns {String} The HTML-safe id.
     */
    static pathToId(path) {
        return path.replace(/[\.<> :|]/g, function (c) {
            return {
                ' ': '__',
                '<': '_LT',
                '>': '_GT',
                '.': '_',
                ':': '-',
                '|': '--'
            }[c];
        })
    }

    toId() { return TreeNode.pathToId(this.path); }

    _insertAsLastInput(newChild) {
        if (!this.hasChildren()) return;

        let idx = -1;
        for (idx = 0; idx < this.children.length - 1; idx++ ) {
            if (this.children[idx+1].isOutput()) break;
        }

        this.children.splice(idx + 1, 0, newChild);
    }

    isFilter() { return false; } // Always false in base class
    hasFilters() { return ('filter' in this); } // True if we contain filters
    isInputFilter() { return false; } // Always false in base class
    isOutputFilter() { return false; } // Always false in base class

    /**
     * Create a simple object that can be used to save state to a file.
     * @returns {Object} Reference to required info.
     */
    getStateForSave() {
        return {
            'minimized': this.draw.minimized,
            'manuallyExpanded': this.draw.manuallyExpanded,
            'hidden': this.draw.hidden,
            'filtered': this.draw.filtered
        };
    }

    /**
     * Provided with loaded state information, update our settings.
     * @param {Object} state The state loaded from file.
     */
    setStateFromLoad(state) {
        this.draw.minimized = state.minimized;
        this.draw.manuallyExpanded = state.manuallyExpanded;
        this.draw.hidden = state.hidden;
        this.filterSelf(state.filtered);
    }

    getTextName() { return this.name; }
}

/**
 * Special TreeNode subclass whose children are filtered variables of the parent node.
 * Not intended to be used outside of a FilterCapableNode.
 * @typedef FilterNode
 */
class FilterNode extends TreeNode {
    /**
     * Give ourselves a special name and the "filter" type.
     * @param {TreeNode} parent The node that we are filtering variables for.
     * @param {String} suffix Either "inputs" or "outputs".
     */
    constructor(parent, attribNames, suffix) {
        super(
            {
                name: `${parent.name}_FILTER_${suffix}`,
                type: 'filter'
            },
            attribNames
        )

        this.parent = parent;
        this.hide();
        this.minimize();
        this.suffix = suffix;
    }

    getTextName() {
        return `Filtered ${this.suffix[0].toUpperCase() + this.suffix.slice(1)}`;
    }

    /**
     * Add a node to our filtered children, update its state, and make ourselves visible.
     * @param {TreeNode} node Reference to the node to filter.
     */
    add(node) {
        if (!this.hasChildren()) { this.children = []; }
        this.children.push(node);
        this.childNames.add(node.path);
        this.numDescendants += 1;
        node.doFilter(this);
        this.show();
    }
    
    /**
     * Update the node's state and remove it from our children. If nothing is left in
     * the children array, delete it and hide ourselves.
     * @param {TreeNode} node Reference to the node to unfilter.
     * @returns {Boolean} True if the node was found in children, otherwise false.
     */
    del(node) {
        node.undoFilter(); // Reset state regardless of being found
        if (this.hasChildren()) {
            const idx = this.children.indexOf(node);
            if (idx >= 0) {
                this.children.splice(idx);
                this.childNames.delete(node);
                this.numDescendants -= 1;
                if (this.children.length == 0) {
                    this.children = null;
                    this.hide();
                }
                return true;
            }
        }
        return false;
    }

    /** Set the state of all children to unfiltered and delete the array */
    wipe() {
        if (this.hasChildren()) {
            for (const child of this.children) { child.undoFilter(); }
            this.children = null;

            this.numDescendants = 0;
            this.childNames.clear();
            this.childNames.add(this.path);
            this.hide();
        }
    }

    /**
     * Determine if the referenced node is in our array of children.
     * @param {TreeNode} child The node to find.
     * @returns {Boolean} True if the child was found, false otherwise.
     */
    hasChild(child) {
        return (this.hasChildren()? this.children.indexOf(child) >= 0 : false);
    }

    /** Return the length of the children array or 0 if it doesn't exist. */
    get count() { return (this.hasChildren()? this.children.length : 0); }
    
    /** Don't expand, always stay minimized. */
    expand() { return this; }

    /** Only show if there are filtered nodes stored as children */
    show() {
        if (this.hasChildren()) { super.show(); }
        return this;
    }

    isFilter() { return true; } // Always true for the TreeNode class
    hasFilters() { return false; }
    isInputFilter() { return this.suffix == 'inputs'; } // True if this manages input filters
    isOutputFilter() { return this.suffix == 'outputs'; } // True if this manages output filters

    /**
     * For normal nodes, targetParentSet and sourceParentSet are built when the model
     * is initialized. Since filters are created after that, _genParentSet() generates a
     * set dynamically based on the specified parent sets of its children.
     * @param {String} setName Either "source" or "target"
     * @returns {Set} The merged contents of the parent sets of all children.
     */
    _genParentSet(setName) {
        const tmpSet = new Set();
        const setPropName = `${setName}ParentSet`;

        if (this.hasChildren()) {
            for (const child of this.children) {
                for (const childParent of child[setPropName]) {
                    tmpSet.add(childParent);
                }
            }
        }

        return tmpSet;
    }

    get sourceParentSet() { return this._genParentSet('source'); }
    set sourceParentSet(val) { return val; }

    get targetParentSet() { return this._genParentSet('target'); }
    set targetParentSet(val) { return val; }
}

/**
 * Add the ability of a TreeNode to contain FilterNodes managing its input/output variables.
 * The TreeNode base class has some accessor methods that refer to filters, but no
 * ability to actually filter anything or be filtered by itself.
 * @typedef FilterCapableNode
 * @property {FilterNode} filter.inputs Children that are inputs to be viewed as collapsed.
 * @property {FilterNode} filter.outputs Children that are outputs to be viewed as collapsed.
 */
class FilterCapableNode extends TreeNode {
    constructor(origNode, attribNames, parent) {
        super(origNode, attribNames, parent);
    }

    // Accessor functions for this.draw.filtered - whether a variable is shown in collapsed form
    doFilter(filterNode) { this.draw.filtered = true; this.draw.filterParent = filterNode; }
    undoFilter() { this.draw.filtered = false; this.draw.filterParent = null; }

    canFilter() { return true; }

    /** If this node has children add special children that can hold filtered variables */
    addFilterChild(attribNames) {
        if (this.hasChildren()) {

            // Separate FilterNodes are added for inputs and outputs so
            // they can be inserted at the correct place in the diagram.
            this.filter = {
                inputs: new FilterNode(this, attribNames, 'inputs'),
                outputs: new FilterNode(this, attribNames, 'outputs')
            };
            this._insertAsLastInput(this.filter.inputs);
            this.children.push(this.filter.outputs);
        }
    }

    /** Add ourselves to the correct parental filter */
    addSelfToFilter() {
        if (this.isInput()) { this.parent.filter.inputs.add(this); }
        else if (this.isOutput()) { this.parent.filter.outputs.add(this); }
    }

    /** Remove ourselves from the correct parental filter */
    removeSelfFromFilter() {
        if (this.isInput()) { this.parent.filter.inputs.del(this); }
        else if (this.isOutput()) { this.parent.filter.outputs.del(this); }
    }

    getFilterList() { return [ this.filter.inputs, this.filter.outputs]; }

    wipeFilters() {
        this.filter.inputs.wipe();
        this.filter.outputs.wipe();
    }

    addToFilter(node) {
        if (node.isInput()) { this.filter.inputs.add(node); }
        else { this.filter.outputs.add(node); }
    }

    /**
     * Filter ourselves based on the supplied filter state.
     * @param {Boolean} filtered Whether to filter or not.
     * @return {Boolean} The newly set state.
     */
    filterSelf(filtered) {
        if (filtered) { this.addSelfToFilter(); }
        else { this.removeSelfFromFilter(); }

        return this.draw.filtered;
    }

}



/**
 * Processes and manages a connection between nodes.
 * @typedef NodeConnection
 * @property {Object} conn The original connection object with src and tgt properties.
 * @property {TreeNode} srcObj The start of the connection.
 * @property {TreeNode} tgtObj The end of the connection.
 */
class NodeConnection {
    /**
     * Process the connection and warn if any problems are found.
     * @param {Object} conn The original connection object with src and tgt properties.
     * @param {Object} nodes References to all TreeNodes in the model. Keys are path
     *  names, the values are TreeNode objects.
     */
    constructor(conn, nodes) {
        this.conn = conn;

        this.srcObj = nodes[conn.src];
        this.srcObj.connTargets.add(conn.tgt);
        const srcObjParents = [];
        if (!this.srcObj) {
            console.warn(`Cannot find connection source ${conn.src}.`);
        }
        else {
            // Collect all parents of the source node.
            srcObjParents.push(this.srcObj);
            for (let parentObj = this.srcObj.parent; parentObj != null; parentObj = parentObj.parent) {
                srcObjParents.push(parentObj);
            }
        }

        this.tgtObj = nodes[conn.tgt];
        this.tgtObj.connSources.add(conn.src);
        const tgtObjParents = [];
        if (!this.tgtObj) {
            console.warn(`Cannot find connection target ${conn.tgt}.`);
        }
        else {
            // Collect all parents of the target node.
            tgtObjParents.push(this.tgtObj);
            for (let parentObj = this.tgtObj.parent; parentObj != null; parentObj = parentObj.parent) {
                tgtObjParents.push(parentObj);
            }
        }
    
        // Make sure all parents of the source and target are aware of the
        // connection. Required for handling collapsed or offscreen node connections.
        for (const srcParent of srcObjParents) {
            for (const tgtParent of tgtObjParents) {
                if (tgtParent.path != '')
                    srcParent.targetParentSet.add(tgtParent);

                if (srcParent.path != '')
                    tgtParent.sourceParentSet.add(srcParent);
            }
        }
    }
}


const defaultAttribNames = {
    name: 'name',              // Human-readable label for the node
    type: 'type',              // Label for the node's classification property
    descendants: 'children',   // Property that contains the node's descendants
    links: 'connections_list', // Property the contains the list of connections, in
                               // a [{src: "srcname1", tgt: "tgtname1", ...}] format
};

/**
 * Manages the data in the model and the connections between nodes.
 * @typedef ModelData
 * @property {Object[]} conns Connections: array of objects in format {src: 'path', tgt: 'path'}
 * @property {NodeConnection[]} connObjs The array of processed connection objects.
 * @property {Number} maxDepth The farthest distance of any descendant from the root node.
 * @property {Object} nodePaths An object with keys that are the pathnames of nodes, and values
 *  that are the associated TreeNode.
 * @property {TreeNode[]} nodeIds An array whose indices are the ids of their assicated values.
 * @property {Number[]} depthCount The tally of nodes at each depth.
 * @property {TreeNode} root The starting node in the tree.
 */
class ModelData {
    constructor(modelJSON, attribNames = defaultAttribNames) {

        this._attribNames = attribNames;
        this.conns = modelJSON[attribNames.links];
        this.connObjs = [];
        this.maxDepth = 1;
        this.nodePaths = {};
        this.nodeIds = [];
        this.depthCount = [];

        this._init(modelJSON);

        this.root = this.tree = modelJSON.tree = this._adoptNodes(modelJSON.tree);
        this._setDepth(this.root, 1);

        for (const conn of this.conns) {
            this.connObjs.push(this._newConnectionObj(conn));
        }

    }

    /**
     * Tasks to perform early from the superclass constructor.
     * @param {Object} modelJSON The model object generated from a JSON string.
     */
    _init(modelJSON) { }

    /**
     * Given a string with base64-encoded, zlib-compressed JSON data, uncompress it
     * and return an Object created from the data.
     * @param {String} b64str The string with base64-encoded, zlib-compressed JSON.
     * @returns {Object} Created from supplied JSON.
     */
    static uncompressModel(b64str) {
        const compressedData = atob(b64str);
        const jsonStr = window.pako.inflate(compressedData, { to: 'string' });

        // JSON5 can handle Inf and NaN
        return JSON5.parse(jsonStr); 
    }

    /**
     * Create a new TreeNode object for this type of model tree. Can be overridden
     * to create different type of node objects derived from TreeNode.
     * @param {Object} element A simple object that will be REPLACED with the TreeNode.
     * @param {Object} attribNames The customized attribute names for this model.
     * @param {TreeNode} parent The node whose children array that this new node will be in.
     * @returns {TreeNode} The newly-created object.
     */
    _newNode(element, attribNames, parent) {
        return new TreeNode(element, attribNames, parent);
    }

    /**
     * Create a new connection object based on the src and tgt values in conn.
     * Can be overwritten to generate different type of connection objects.
     * @param {Object} conn An Object with src and tgt strings containing path names.
     * @returns {NodeConnection} The new object.
     */
    _newConnectionObj(conn) {
        return new NodeConnection(conn, this.nodePaths);
    }

    /**
     * Recurse over the tree and replace the JSON objects
     * provided by n2_viewer.py with TreeNodes.
     * @param {Object} element The current element being updated.
     */
     _adoptNodes(element, parent = null) {
        const newNode = this._newNode(element, this._attribNames, parent);

        if (newNode.hasChildren()) {
            for (const i in newNode.children) {
                newNode.children[i] = this._adoptNodes(newNode.children[i], newNode);
            }
        }

        if (newNode.canFilter()) newNode.addFilterChild(this._attribNames);

        return newNode;
    }

   /**
     * Sets depth of all nodes and determines max depth.
     * @param {TreeNode} node Item to process.
     * @param {number} depth Numerical level of ancestry.
     */
    _setDepth(node, depth) {
        node.depth = depth;
        node.id = this.nodeIds.length;
        this.nodeIds.push(node);

        // Track # of nodes at each depth
        if (depth > this.depthCount.length) { this.depthCount.push(1); }
        else { this.depthCount[depth - 1]++; }

        if (node.parent) {
            node.path = (node.parent.path == '')? node.name : `${node.parent.path}.${node.name}`;
            this.nodePaths[node.path] = node;
        }

        this.maxDepth = Math.max(depth, this.maxDepth);
        node.childNames.add(node.path); // Add the node itself

        if (node.hasChildren()) {
            node.numDescendants = node.children.length;
            for (const child of node.children) {
                this._setDepth(child, depth + 1);
                node.numDescendants += child.numDescendants;

                // Add absolute pathnames of children to a set for quick searching
                if (!node.isRoot()) { // All nodes are children of the model root
                    node.childNames.add(child.path);
                    for (const childName of child.childNames) {
                        node.childNames.add(childName);
                    }
                }
            }
        }
    }

    /**
     * Check the entire array of model connections for any with a target matching
     * the specified path.
     * @param {string} elementPath The full path of the element to check.
     * @return True if the path is found as a target in the connection list.
     */
     hasInputConnection(elementPath) {
        for (const conn of this.conns) {
            if (conn.tgt.match(elementPath)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Check the entire array of model connections for any with a source matching
     * the specified path.
     * @param {string} elementPath The full path of the element to check.
     * @return True if the path is found as a source in the connection list.
     */
    hasOutputConnection(elementPath) {
        for (const conn of this.conns) {
            if (conn.src.match(elementPath)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Check the entire array of model connections for any with a source OR
     * target matching the specified path.
     * @param {string} elementPath The full path of the element to check.
     * @return True if the path is found as a source in the connection list.
     */
    hasAnyConnection(elementPath) {
        for (const conn of this.conns) {
            if (conn.src == elementPath || conn.tgt == elementPath)
                return true;
        }

        debugInfo(elementPath + " has no connections.");
        this.unconnectedInputs++;

        return false;
    }

    /**
     * Add all leaf descendents of specified node to the array.
     * @param {TreeNode} node Current node to work on.
     * @param {TreeNode[]} objArray Array to add to.
     */
     _addLeaves(node, objArray) {
        if (!node.isInput()) {
            objArray.push(node);
        }

        if (node.hasChildren()) {
            for (const child of node.children) {
                this._addLeaves(child, objArray);
            }
        }
    }

   /**
     * Recurse through the model, and determine whether a parent node is
     * minimized or manually expanded, or an input/output hidden. If it is,
     * add it to the hiddenList array, and optionally reset its state.
     * @param {Object[]} hiddenList The provided array to populate.
     * @param {Boolean} reveal If true, make the node visible.
     * @param {TreeNode} node The current node to operate on.
     */
    findAllHidden(hiddenList, reveal = false, node = this.root) {
        // Filtered nodes are handled by their true parents
        if (node.isFilter()) return;

        if (!node.isVisible() || node.draw.minimized || node.draw.manuallyExpanded) {
            hiddenList.push({
                'node': node,
                'draw': {
                    'minimized': node.draw.minimized,
                    'hidden': node.draw.hidden,
                    'filtered': node.draw.filtered,
                    'manuallyExpanded': node.draw.manuallyExpanded
                }
            })

            if (reveal) {
                node.expand();
                node.show();
                node.draw.manuallyExpanded = false;
                if (node.isFilteredVariable()) node.removeSelfFromFilter();
            }
        }

        if (node.hasChildren()) {
            for (const child of node.children) {
                this.findAllHidden(hiddenList, reveal, child);
            }
        }
    }

    /**
     * Restore the minimized/hidden value to all the specified nodes.
     * @param {Object[]} hiddenList The list of preserved objects
     * @param {TreeNode} node The current node to operate on.
     */
    resetAllHidden(hiddenList, node = this.root) {
        // Filtered nodes are handled by their true parents
        if (!hiddenList || node.isFilter()) return;

        const foundEntry = hiddenList.find(item => item.node === node);

        // If variables were selectively hidden, force the variable selection
        // dialog to rebuild the hiddenVars array.
        if (node.hasFilters()) { node.wipeFilters(); }

        if (!foundEntry) { // Not found, reset values to default
            node.expand();
            node.show();
            node.draw.manuallyExpanded = false;
            if (node.isFilteredVariable()) node.removeSelfFromFilter();
        }
        else { // Found, restore values
            node.draw.minimized = foundEntry.draw.minimized;
            node.draw.hidden = foundEntry.draw.hidden;
            node.draw.manuallyExpanded = foundEntry.draw.manuallyExpanded;
            if (foundEntry.draw.filtered) { node.addSelfToFilter(); }
            else { if (node.isFilteredVariable()) node.removeSelfFromFilter(); }
        }

        if (node.hasChildren()) {
            for (const child of node.children) {
                this.resetAllHidden(hiddenList, child);
            }
        }
    }

    /**
     * Set the node as not minimized and manually expanded, as well as
     * all children.
     * @param {TreeNode} startNode The node to begin from.
     */
     manuallyExpandAll(startNode) {
        startNode.draw.minimized = false;
        startNode.draw.manuallyExpanded = true;

        if (startNode.hasChildren()) {
            for (const child of startNode.children) {
                this.manuallyExpandAll(child);
            }
        }
    }

    /**
     * Set all the children of the specified node as minimized and not manually expanded.
     * @param {TreeNode} startNode The node to begin from.
     * @param {Boolean} [initialNode = true] Indicate the starting node.
     */
    minimizeAll(startNode, initialNode = true) {
        if (!initialNode) {
            startNode.draw.minimized = true;
            startNode.draw.manuallyExpanded = false;
        }

        if (startNode.hasChildren()) {
            for (const child of startNode.children) {
                this.minimizeAll(child, false);
            }
        }
    }

    /**
     * Recursively minimize non-input nodes to the specified depth.
     * @param {TreeNode} node The node to work on.
     * @param {Number} chosenCollapseDepth If the node's depth is the same or more, collapse it.
     */
    minimizeToDepth(node, chosenCollapseDepth) {
        if (node.isInputOrOutput()) {
            return;
        }

        if (node.depth < chosenCollapseDepth) {
            node.draw.minimized = false;
            node.draw.manuallyExpanded = true;
        }
        else {
            node.draw.minimized = true;
            node.draw.manuallyExpanded = false;
        }

        if (node.hasChildren()) {
            for (const child of node.children) {
                this.minimizeToDepth(child, chosenCollapseDepth);
            }
        }
    }


}



/**
 * Extend NodeDisplayData by handling solvers.
 * @typedef NodeDisplayData
 */
class OmNodeDisplayData extends NodeDisplayData {
    constructor() {
        super();
        this.nameSolverWidthPx = 1; // Solver-side label width pixels as computed by Layout
        this.solverDims = new Dimensions({ x: 1e-6, y: 1e-6, width: 1, height: 1 });
        this.solverDims.preserve();
    }
}

/**
 * Extend FilterCapableTreeNode by adding support for feedback cycle arrows and solvers.
 * @typedef OmTreeNode
 */
class OmTreeNode extends FilterCapableNode {
    static showLinearSolverNames = true;

    /**
     * Switch back and forth between showing the linear or non-linear solver names.
     */
    static toggleSolverNameType() {
        this.showLinearSolverNames = !this.showLinearSolverNames;
    }

    constructor(origNode, attribNames, parent) {
        super(origNode, attribNames, parent);

        // Solver names may be empty, so set them to "None" instead.
        if (this.linear_solver == "") this.linear_solver = "None";
        if (this.nonlinear_solver == "") this.nonlinear_solver = "None";
        if (exists(this.parentComponent)) this.parentComponent = parent;
    }

    get absPathName() { return this.path; }
    set absPathName(newName) { this.path = newName; return newName; }

    /**
     * Perform special checking for filter and auto-IVC nodes when determining
     * the node's name.
     * @returns {String} The label for the node.
     */
    getTextName() {
        let retVal = this.name;

        if (this.name == '_auto_ivc') {
            retVal = 'Auto-IVC';
        }
        else if (this.isFilter()) {
            retVal = super.getTextName();
        }
        else if (this.path.match(/^_auto_ivc.*/) && this.promotedName !== undefined) {
            retVal = this.promotedName;
        }
        return retVal;
    }

    /**
     * Return the name of the linear or non-linear solver depending
     * on the value of OmTreeNode.showLinearSolverNames.
     * @returns {String} The label for the solver node.
     */
    getSolverText() {
        const solverName = OmTreeNode.showLinearSolverNames? this.linear_solver : this.nonlinear_solver;
        let suffix = '';

        if (!OmTreeNode.showLinearSolverNames && 'solve_subsystems' in this && this.solve_subsystems) {
            suffix = ' (sub_solve)';
        }

        return `${solverName}${suffix}`;
    }

    /** Create and return a new  OmNodeDisplayData object. */
    _newDisplayData() { return new OmNodeDisplayData(); }

    addFilterChild(attribNames) {
        if (this.isComponent()) { super.addFilterChild(attribNames); }
    }

    /** Override superclass method to include 'autoivc_input'. */
    isInput() { return this.type.match(/^(input|unconnected_input|autoivc_input)$/); }

    /** Override superclass method to include 'autoivc_input'. */
    isInputOrOutput() { return this.type.match(/^(output|input|unconnected_input|autoivc_input)$/); }

    /** True if this is an input whose source is an auto-ivc'd output */
    isAutoIvcInput() { return (this.type == 'autoivc_input'); }

    /** True if this is an output and it's not implicit */
    isExplicitOutput() { return (this.isOutput() && !this.implicit); }

    /** True if this is an output and it is implicit */
    isImplicitOutput() { return (this.isOutput() && this.implicit); }

    /** True is this.type is 'subsystem' */
    isSubsystem() { return (this.type == 'subsystem'); }

    /** True if it's a subsystem and this.subsystem_type is 'group'. Overrides base class */
    isGroup() { return (this.isSubsystem() && this.subsystem_type == 'group'); }

    /** True if it's a subsystem and this.subsystem_type is 'component' */
    isComponent() { return (this.isSubsystem() && this.subsystem_type == 'component'); }

    /** Not connectable if this is an input group or parents are minimized. */
    isConnectable() {
        if (this.isInputOrOutput() && !(this.hasChildren() ||
            this.parent.draw.minimized || this.parentComponent.draw.minimized)) return true;

        return this.draw.minimized;
    }

    /**
     * Add ourselves to the supplied array if we contain a cycleArrows property.
     * @param {Array} arr The array to add to.
     */
     _getNodesInChildrenWithCycleArrows(arr) {
        if (this.cycleArrows) {
            arr.push(this);
        }

        if (this.hasChildren()) {
            for (const child of this.children) {
                if (child instanceof OmTreeNode) {
                    child._getNodesInChildrenWithCycleArrows(arr);
                }
            }
        }
    }

    /**
     * Populate an array with nodes in our lineage that contain a cycleArrows member.
     * @returns {Array} The array containing all the found nodes with cycleArrows.
     */
    getNodesWithCycleArrows() {
        const arr = [];

        // Check parents first.
        for (let obj = this.parent; obj != null; obj = obj.parent) {
            if (obj.cycleArrows) {
                arr.push(obj);
            }
        }

        // Check all descendants as well.
        this._getNodesInChildrenWithCycleArrows(arr);

        return arr;
    }

    /**
     * Create a backup of our position and other info.
     * @param {number} leafNum Identify this as the nth leaf of the tree
     */
     preserveSolverDims(leafNum) {
        this.draw.solverDims.preserve();

        if (this.rootIndex < 0) this.rootIndex = leafNum;
        this.prevRootIndex = this.rootIndex;
    }

    _preCollapseDepth() { return this.isComponent()? Precollapse.cmpDepthStart : Precollapse.grpDepthStart; }

}



/**
 * Extend functionality of NodeConnection by handling feedback cycle arrows.
 * @typedef OmNodeConnection
 */
class OmNodeConnection extends NodeConnection {
    /**
     * Process the connection and warn if any problems are found.
     * @param {Object} conn The original connection object with src and tgt properties.
     * @param {Object} nodes References to all TreeNodes in the model. Keys are path
     *  names, the values are TreeNode objects.
     * @param {String[]} sysPathnames Array of pathnames that the indices in the cycle
     *  arrow arrays correspond to.
     */
    constructor(conn, nodes, sysPathnames = null) {
        super(conn, nodes);
        if (sysPathnames) this._processCycleArrows(sysPathnames, nodes);
    }

    /**
     * The cycle_arrows object in each connection is an array of length-2 arrays,
     * each of which is an index into the sysPathnames array. Using that array we
     * can resolve the indexes to pathnames to the associated objects.
     * @param {String[]} sysPathnames Array of pathnames that the indices in the cycle
     *  arrow arrays correspond to.
     * @param {Object} nodes References to all TreeNodes in the model. Keys are path
     *  names, the values are TreeNode objects.
     */
    _processCycleArrows(sysPathnames, nodes) {
        if (Array.isPopulatedArray(this.conn.cycle_arrows)) {
            const cycleArrowsArray = [];

            // Find the named TreeNode objects at each end and create a new connection object
            for (const cycleArrow of this.conn.cycle_arrows) {
                if (cycleArrow.length != 2) {
                    console.warn(`cycleArrowsSplitArray length not 2, got ${cycleArrow.length}: ${cycleArrow}`);
                }
                else {
                    const srcPath = sysPathnames[cycleArrow[0]];
                    const tgtPath = sysPathnames[cycleArrow[1]];

                    if (!srcPath in nodes) {
                        console.warn(`Cannot find cycle arrow source object ${srcPath}`);
                    }
                    else {
                        if (!tgtPath in nodes) {
                            console.warn(`Cannot find cycle arrow target object ${tgtPath}`);
                        }
                        else {
                            const arrow = {'begin': nodes[srcPath], 'end': nodes[tgtPath]};
                            cycleArrowsArray.push(arrow);
                        }
                    }
                }
            }

            if (!this.tgtObj.parent.cycleArrows) { this.tgtObj.parent.cycleArrows = []; }

            this.tgtObj.parent.cycleArrows.push({
                'src': this.srcObj,
                'arrows': cycleArrowsArray
            });
        }
    }
}


/** Process the tree, connections, and other info provided about the model. */
class OmModelData extends ModelData {
    /** Do some discovery in the tree and rearrange & enhance where necessary. */
    constructor(modelJSON) {
        super(modelJSON);

        if (this.unconnectedInputs > 0)
            console.info("Unconnected nodes: ", this.unconnectedInputs);

        this._initSubSystemChildren(this.root);
        this._updateAutoIvcNames();

        debugInfo("New model: ", this);
        // this.errorCheck();
    }

    /** Tasks to perform early from the superclass constructor */
    _init(modelJSON) {
        modelJSON.tree.name = 'model'; // Change 'root' to 'model'
        this.abs2prom = modelJSON.abs2prom; // May be undefined.
        this.declarePartialsList = modelJSON.declare_partials_list;
        this.useDeclarePartialsList = (this.declarePartialsList.length > 0);
        this.sysPathnamesList = modelJSON.sys_pathnames_list;

        this.unconnectedInputs = 0;
        this.autoivcSources = 0;
        this.md5_hash = modelJSON.md5_hash; // compute here instead of python?
    }

    /**
     * For debugging: Make sure every tree member is an OmTreeNode.
     * @param {OmTreeNode} [node = this.root] The node to start with.
     */
    errorCheck(node = this.root) {
        if (!(node instanceof OmTreeNode))
            debugInfo('Node with problem: ', node);

        for (const prop of ['parent', 'originalParent', 'parentComponent']) {
            if (node[prop] && !(node[prop] instanceof OmTreeNode))
                debugInfo('Node with problem ' + prop + ': ', node);
        }

        if (node.hasChildren()) {
            for (let child of node.children) {
                this.errorCheck(child);
            }
        }
    }

    /**
     * Convert the element to an OmTreeNode. Overrides the superclass method.
     * @param {Object} element The basic properties for the element obtained from JSON.
     * @param {Object} attribNames Map of this model's properties to standard names.
     * @param {TreeNode} parent The node whose children array that this new node will be in.
     * @returns {OmTreeNode} The newly-created object.
     */
    _newNode(element, attribNames, parent) {
        return new OmTreeNode(element, attribNames, parent);
    }

    /**
     * Sets depth of all nodes determine max depth. Flags the
     * parent node as implicit if the node itself is implicit.
     * @param {OmTreeNode} node Item to process.
     * @param {number} depth Numerical level of ancestry.
     */
     _setDepth(node, depth) {
        super._setDepth(node, depth);

        if (this.abs2prom.input[node.path] !== undefined) {
            node.promotedName = this.abs2prom.input[node.path];
        }
        else if (this.abs2prom.output[node.path] !== undefined) {
            node.promotedName = this.abs2prom.output[node.path];
        }

        this.identifyUnconnectedInput(node);
        if (node.isInputOrOutput()) {
            const parentComponent = (node.originalParent) ? node.originalParent : node.parent;
            if (parentComponent.type == "subsystem" &&
                parentComponent.subsystem_type == "component") {
                node.parentComponent = parentComponent;
            }
            else {
                throw ("Input or output without a parent component!");
            }
        }

        if (node instanceof OmTreeNode && node.isSubsystem()) {
            this.maxSystemDepth = Math.max(depth, this.maxSystemDepth);
        }

        if (node.parent && node.implicit) { parent.implicit = true; }
    }

    /**
     * Determine if the specified path has an input source that's an Auto-IVC output.
     * @param {String} elementPath Absolute path to the element.
     * @returns {Boolean} True if the input source is an Auto-IVC output.
     */
    hasAutoIvcSrc(elementPath) {
        for (const conn of this.conns) {
            if (conn.tgt == elementPath && conn.src.match(/^_auto_ivc.*$/)) {
                debugInfo(elementPath + " source is an auto-ivc output.");
                this.autoivcSources++;
                return true;
            }
        }

        return false;
    }

    /**
     * Find the target of an Auto-IVC variable.
     * @param {String} elementPath The full path of the element to check. Must start with _auto_ivc.
     * @return {String} The absolute path of the target element, or undefined if not found.
     */
    getAutoIvcTgt(elementPath) {
        if (!elementPath.match(/^_auto_ivc.*$/)) return undefined;

        for (const conn of this.conns) {
            if (conn.src == elementPath) {
                return conn.tgt;
            }
        }

        console.warn(`No target connection found for ${elementPath}.`)
        return undefined;
    }

    /**
     * Create an array in each node containing references to its
     * children that are subsystems. Runs recursively over the node's
     * children array.
     * @param {OmTreeNode} node Node with children to check.
     */
    _initSubSystemChildren(node) {
        if (!node.hasChildren()) {
            return;
        }

        for (const child of node.children) {
            if (child instanceof OmTreeNode && child.isSubsystem()) {
                if (!node.hasChildren('subsystem_children'))
                    node.subsystem_children = [];

                node.subsystem_children.push(child);
                this._initSubSystemChildren(child);
            }
        }
    }

    /**
     * Build a string from the absoluate path names of the two elements and
     * try to find it in the declare partials list.
     * @param {Object} srcObj The source element.
     * @param {Object} tgtObj The target element.
     * @return {Boolean} True if the string was found.
     */
    isDeclaredPartial(srcObj, tgtObj) {
        let partialsStr = tgtObj.path + " > " + srcObj.path;

        return this.declarePartialsList.includes(partialsStr);
    }

    /**
     * Create a connection object between nodes and handle cycle arrows.
     * @param {Object} conn Object with src and tgt properties.
     * @returns {OmNodeConnection} The newly created connection object.
     */
    _newConnectionObj(conn) {
        return new OmNodeConnection(conn, this.nodePaths, this.sysPathnamesList);
    }

    /**
     * If the Auto-IVC component exists, rename its child variables to their
     * promoted names so they can be easily recognized instead of as v0, v1, etc.
     */
    _updateAutoIvcNames() {
        const aivc = this.nodePaths['_auto_ivc'];
        if (aivc !== undefined && aivc.hasChildren()) {
            for (const ivc of aivc.children) {
                if (!ivc.isFilter()) {
                    const tgtPath = this.getAutoIvcTgt(ivc.path);

                    if (tgtPath !== undefined) {
                        ivc.promotedName = this.nodePaths[tgtPath].promotedName;
                    }
                }
            }
        }
    }

    /**
     * If an element has no connection naming it as a source or target,
     * relabel it as unconnected.
     * @param {OmTreeNode} node The tree node to work on.
     */
    identifyUnconnectedInput(node) {
        if (!node.hasOwnProperty('path')) {
            console.warn("identifyUnconnectedInput error: path not set for ", node);
        }
        else {
            if (node.isInput()) {
                if (!node.hasChildren() && !this.hasAnyConnection(node.path))
                    node.type = "unconnected_input";
                else if (this.hasAutoIvcSrc(node.path))
                    node.type = "autoivc_input";
            }
        }
    }
}

/**
 * Translate coordinates from the range 0 - 1 to 0 - pixel size.
 * @typedef Scale
 * @property {Function} x Scale in the horizontal direction.
 * @property {Function} y Scale in the vertical direction.
 */
class Scale {
    /**
     * Initialize the Scale.
     * @param {Object} obj Any object with width and height properties.
     */
    constructor(obj) {
        this.x = d3.scaleLinear().range([0, obj.width]);
        this.y = d3.scaleLinear().range([0, obj.height]);
        this.prev = { x: null, y: null };
    }

    /**
     * Duplicate another Scale object.
     * @param {Scale} other The object to copy from.
     */
    copyFrom(other) {
        this.x = other.x.copy();
        this.y = other.y.copy();
    }

    /** Backup the current scale objects for future reference. */
    preserve() {
        this.prev = {
            x: this.x.copy(),
            y: this.y.copy()
        }
    }
}



/**
 * Calculates and stores the size and positions of visible elements.
 * @typedef Layout
 * @property {ModelData} model Reference to the preprocessed model.
 * @property {TreeNode} zoomedElement Reference to zoomedElement managed by Diagram.
 * @property {TreeNode[]} zoomedNodes  Child workNodes of the current zoomed element.
 * @property {TreeNode[]} visibleNodes Zoomed workNodes that are actually drawn.
 * @property {Object} svg Reference to the top-level SVG element in the document.
 * @property {Object} size The dimensions of the model tree.
 * @property {Object} scales Scalers in the X and Y directions to associate the relative
 *   position of an element to actual pixel coordinates.
 * @property {Object} treeSize
 */
class Layout {
    /**
     * Compute the new layout based on the model data and the zoomed element.
     * @param {ModelData} model The pre-processed model object.
     * @param {Object} newZoomedElement The element the new layout is based around.
     * @param {Object} dims The initial sizes for multiple tree elements.
     * @param {Boolean} callInit Whether to call _init() or have a subclass do it.
     */
    constructor(model, newZoomedElement, dims, callInit = true) {
        this.model = model;

        this.zoomedElement = newZoomedElement;

        this.zoomedNodes = [];
        this.visibleNodes = [];

        this.curVisibleNodeCount = 0;
        this.prevVisibleNodeCount = 0;

        // Initial size values derived from read-only defaults
        this.size = dims.size;
        this.svg = d3.select("#svgId");

        if (callInit) this._init();
    }

    /**
     * Separate these calls from the constructor so that subclasses can
     * set values before execution.
     */
    _init() {
        this._computeLeaves();
        this._setupTextRenderer();
        this._updateTextWidths();
        delete (this.textRenderer);
        this._computeColumnWidths();
        this._setColumnLocations(this.size.partitionTree, this.cols);

        this._computeNormalizedPositions(this.model.root, 0, false, null);
        if (this.zoomedElement.parent)
            this.zoomedNodes.push(this.zoomedElement.parent);

        this.setTransitionPermission();

        this.scales = {
            'model': new Scale(this.size.partitionTree),
            'firstRun': true
        }

        this.treeSize = {
            'model': new Dimensions({ 'width': 0, 'height': 0})
        }
    }

    /**
     * If there are too many nodes, don't bother with transition animations
     * because it will cause lag and may timeout anyway. This is accomplished
     * by redefining a few D3 methods to return the same selection instead
     * of a transition object. When the number of nodes is low enough,
     * the original transition methods are restored.
     */
    setTransitionPermission() {
        this.prevVisibleNodeCount = this.visibleNodeCount;
        this.visibleNodeCount = this.visibleNodes.length;
        const highWaterMark = Math.max(this.prevVisibleNodeCount, this.visibleNodeCount);

        // Too many nodes, disable transitions.
        if (highWaterMark >= transitionDefaults.maxNodes) {
            debugInfo("Denying transitions: ", this.visibleNodes.length,
                " visible nodes, max allowed: ", transitionDefaults.maxNodes)

            // Return if already denied
            if (!d3.selection.prototype.transitionAllowed) return;
            d3.selection.prototype.transitionAllowed = false;

            d3.selection.prototype.transition = returnThis;
            d3.selection.prototype.duration = returnThis;
            d3.selection.prototype.delay = returnThis;
        }
        else { // OK, enable transitions.
            debugInfo("Allowing transitions: ", this.visibleNodes.length,
                " visible nodes, max allowed: ", transitionDefaults.maxNodes)

            // Return if already allowed
            if (d3.selection.prototype.transitionAllowed) return;
            d3.selection.prototype.transitionAllowed = true;

            for (const func in d3.selection.prototype.originalFuncs) {
                d3.selection.prototype[func] =
                    d3.selection.prototype.originalFuncs[func];
            }
        }
    }

    /** Create an off-screen area to render text for _getTextWidth() */
    _setupTextRenderer() {
        const textGroup = this.svg.select('#text-width-renderer');
        const textSVG = textGroup.select('text');

        this.textRenderer = {
            'group': textGroup,
            'textSvg': textSVG,
            'workNode': textSVG.node(),
            'widthCache': {}
        };
    }

    /** Insert text into an off-screen SVG text object to determine the width.
     * Cache the result so repeat calls with the same text can just do a lookup.
     * @param {String} text Text to render or find in cache.
     * @return {Number} The SVG-computed width of the rendered string.
     */
    _getTextWidth(text) {
        let width = 0.0;

        // Check cache first
        if (this.textRenderer.widthCache.propExists(text)) {
            width = this.textRenderer.widthCache[text];
        }
        else {
            // Not found, render and return new width.
            this.textRenderer.textSvg.text(text);
            width = this.textRenderer.workNode.getBoundingClientRect().width;

            this.textRenderer.widthCache[text] = width;
        }

        return width;
    }

    /**
     * Determine text widths for all descendents of the specified node.
     * @param {TreeNode} [node = this.zoomedElement] Item to begin looking from.
     */
    _updateTextWidths(node = this.zoomedElement) {
        if (node.draw.hidden) return;

        node.draw.nameWidthPx = this._getTextWidth(node.getTextName()) + 2 *
            this.size.rightTextMargin;

        if (node.hasChildren() && !node.draw.minimized) {
            for (const child of node.children) {
                this._updateTextWidths(child);
            }
        }
    }

    /**
     * Recurse through the tree and add up the number of leaves that each
     * node has, based on their array of visible children.
     * @param {TreeNode} [node = this.model.root] The starting node.
     */
    _computeLeaves(node = this.model.root) {
        node.draw.numLeaves = 0;

        if (!(node.draw.hidden || node.draw.filtered)) {
            if (node.name == '_auto_ivc' && !node.draw.manuallyExpanded) {
                node.minimize();
            }
            else if (this.model.nodeIds.length > Precollapse.minimumNodes) {
                node.minimizeIfLarge(this.model.depthCount[node.depth]);
            }

            if (node.hasChildren() && !node.draw.minimized) {
                for (const child of node.children) {
                    this._computeLeaves(child);
                    node.draw.numLeaves += child.draw.numLeaves;
                }
            }
            else {
                node.draw.numLeaves = 1; // Leaf node
            }
        }
    }

    /**
     * For visible nodes with children, choose a column width
     * large enough to accomodate the widest label in their column.
     * @param {TreeNode} node The item to operate on.
     * @param {String} childrenProp Usually 'children', subclasses may use a different property.
     * @param {Object[]} colArr The array of column info.
     * @param {Number[]} leafArr The array of leaf width info.
     * @param {String} [widthProp = 'nameWidthPx'] Can be modified by derived classes.
     */
    _setColumnWidthsFromWidestText(node, childrenProp, colArr, leafArr, widthProp = 'nameWidthPx') {
        if (node.draw.hidden) return;

        const height = this.size.matrix.height * node.draw.numLeaves / this.zoomedElement.draw.numLeaves;
        node.prevTextOpacity = node.propExists('textOpacity') ? node.textOpacity : 0;
        node.textOpacity = (height > this.size.font) ? 1 : 0;
        const hasVisibleDetail = (height >= 2.0);
        let width = (hasVisibleDetail) ? this.size.minColumnWidth : 1e-3;
        if (node.textOpacity > 0.5) width = node.draw[widthProp];

        this.greatestDepth = Math.max(this.greatestDepth, node.depth);

        if (node.hasChildren(childrenProp) && !node.draw.minimized) { //not leaf
            colArr[node.depth].width = Math.max(colArr[node.depth].width, width)
            for (const child of node[childrenProp]) {
                this._setColumnWidthsFromWidestText(child, childrenProp, colArr, leafArr, widthProp);
            }
        }
        else if (!node.draw.filtered) { // leaf
            leafArr[node.depth] = Math.max(leafArr[node.depth], width);
        }
    }

    /**
     * Compute column widths across the model, then adjust ends as needed.
     * @param {TreeNode} [node = this.zoomedElement] Item to operate on.
     */
    _computeColumnWidths(node = this.zoomedElement) {
        this.greatestDepth = 0;
        this.leafWidthsPx = new Array(this.model.maxDepth + 1).fill(0.0);
        this.cols = Array.from({length: this.model.maxDepth + 1},
            () => ({ 'width': 0.0, 'location': 0.0 }));

        this._setColumnWidthsFromWidestText(node, 'children', this.cols,
            this.leafWidthsPx, 'nameWidthPx');

        let sum = 0;
        let lastColumnWidth = 0;
        for (let i = this.leafWidthsPx.length - 1; i >= this.zoomedElement.depth; --i) {
            sum += this.cols[i].width;
            const lastWidthNeeded = this.leafWidthsPx[i] - sum;
            lastColumnWidth = Math.max(lastWidthNeeded, lastColumnWidth);
        }

        this.cols[this.zoomedElement.depth - 1].width = this.size.parentNodeWidth;
        this.cols[this.greatestDepth].width = lastColumnWidth;
    }

    /**
     * Set the location of the columns based on the width of the columns to the left.
     * @param {Dimensions} obj Object containing a width property.
     * @param {Object[]} cols Array of objects containing a width property.
     */
    _setColumnLocations(obj, cols) {
        obj.width = 0;

        for (let depth = 1; depth <= this.model.maxDepth; ++depth) {
            cols[depth].location = obj.width;
            obj.width += cols[depth].width;
        }
    }

    /**
     * Recurse over the model tree and determine the coordinates and
     * size of visible nodes. If a parent is minimized, operations are
     * performed on it instead.
     * @param {TreeNode} node The node to operate on.
     * @param {number} leafCounter Tally of leaves encountered so far.
     * @param {Boolean} isChildOfZoomed Whether node is a descendant of this.zoomedElement.
     * @param {Object} earliestMinimizedParent The minimized parent, if any, appearing
     *   highest in the tree hierarchy. Null if none exist.
     */
    _computeNormalizedPositions(node, leafCounter, isChildOfZoomed, earliestMinimizedParent) {
        if (!isChildOfZoomed) {
            isChildOfZoomed = (node === this.zoomedElement);
        }

        if (earliestMinimizedParent == null && isChildOfZoomed) {
            if (node.isVisible()) {
                this.zoomedNodes.push(node)
                if (node.isVisibleLeaf()) {
                    if (!node.draw.hidden) this.visibleNodes.push(node);
                    earliestMinimizedParent = node;
                }
            }
        }

        node.preserveDims(leafCounter);
        const workNode = (earliestMinimizedParent) ? earliestMinimizedParent : node;
        const dims = node.draw.dims;

        if (! node.isVisible()) { // input or hidden leaf leaving
            dims.x = this.cols[node.parent.depth + 1].location / this.size.partitionTree.width;
            dims.y = node.parent.draw.dims.y;
            dims.width = 1e-6;
            dims.height = 1e-6;
        }
        else {
            dims.x = this.cols[workNode.depth].location / this.size.partitionTree.width;
            dims.y = leafCounter / this.model.root.draw.numLeaves;
            dims.width = (node.hasChildren() && !node.draw.minimized && !node.draw.filtered) ?
                (this.cols[workNode.depth].width / this.size.partitionTree.width) : 1 - workNode.draw.dims.x;
            dims.height = workNode.draw.numLeaves / this.model.root.draw.numLeaves;
        }

        if (node.hasChildren()) {
            for (const child of node.children) {
                if (!child.isInputOrOutput() || !child.draw.minimized) {
                    this._computeNormalizedPositions(child, leafCounter,
                        isChildOfZoomed, earliestMinimizedParent);
                    if (earliestMinimizedParent == null) { //numleaves is only valid passed nonminimized nodes
                        leafCounter += child.draw.numLeaves;
                    }
                }
            }
        }
    }

    /**
     * Calculate new dimensions for the div element enclosing the main SVG element.
     * @returns {Dimensions} Members width and height.
     */
    calcOuterDims() {
        const width = this.size.partitionTree.width + this.size.matrix.width +
            this.size.matrix.margin * 2;

        const height = this.size.matrix.height + this.size.matrix.margin * 2;

        return new Dimensions({'width': width, 'height': height});
    }

    /**
     * Calculate new dimensions for the main SVG element.
     * @returns {Dimensions} Members width, height, and margin as numbers.
     */
    calcInnerDims() {
        const width = this.size.partitionTree.width + this.size.matrix.margin +
            this.size.matrix.width + this.size.matrix.margin;

        const height = this.size.partitionTree.height;
        const margin = this.size.matrix.margin;

        return new Dimensions({'width': width, 'height': height, 'margin': margin});
    }

    /**
     * Set the geometry of the main diagram elements for the first time, without
     * using transition animations.
     * @param {Object} dom Collection of D3 selections associated with the HTML elements.
     */
    applyGeometryFirstRun(dom) {
        // Update svg dimensions before size changes
        const outerDims = this.calcOuterDims();
        const innerDims = this.calcInnerDims();
        const size = this.size;

        dom.svgDiv
            .style('width', outerDims.widthStyle)
            .style('height', outerDims.heightStyle);

        // NOTE: Apparently first setting these values with .attr and updating
        // them later with .style in .updateTransitionInfo() allows the diagram
        // transition animation to execute as intended. Setting them in both
        // places using the same method results in the transition not working.

        dom.svg
            .attr('width', outerDims.width)
            .attr('height', outerDims.height)
            .attr('transform', 'translate(0,0)');

        dom.pTreeGroup
            .attr('height', innerDims.height)
            .attr('width', size.partitionTree.width)
            .attr('transform', `translate(0,${innerDims.margin})`);

        dom.highlightBar
            .attr('height', innerDims.height)
            .attr('width', '8')
            .attr('transform', `translate(${size.partitionTree.width + 1},${innerDims.margin})`);

        dom.diagOuterGroup
            .attr('height', outerDims.height)
            .attr('width', outerDims.height)
            .attr('transform', `translate(${size.partitionTree.width},0)`);

        dom.diagInnerGroup
            .attr('height', innerDims.height)
            .attr('width', innerDims.height)
            .attr('transform', `translate(${innerDims.margin},${innerDims.margin})`);

        dom.diagBackgroundRect
            .attr('width', innerDims.height)
            .attr('height', innerDims.height)
            .attr('transform', 'translate(0,0)');

        const offgridHeight = size.font + 2;
        dom.diagGroups.offgrid.top
            .attr('transform', `translate(${innerDims.margin},0)`)
            .attr('width', innerDims.height)
            .attr('height', offgridHeight);

        dom.diagGroups.offgrid.bottom
            .attr('transform', `translate(0,${innerDims.height + offgridHeight})`)
            .attr('width', outerDims.height)
            .attr('height', offgridHeight);
    }

    /**
     * Recalculate the scale and apply new dimensions to diagram objects.
     * @param {Object} dom Collection of D3 selections associated with the HTML elements.
     * @return {Boolean} True if this was the first run.
     */
    updateGeometry(dom) {
        this.updateGeometryValues();

        if (this.scales.firstRun) { // first run, duplicate what we just calculated
            this.scales.firstRun = false;
            this.preservePreviousScaleValues();
            this.applyGeometryFirstRun(dom);

            return true;
        }

        return false;        
    }

    /**
     * Update container element dimensions when a new layout is calculated,
     * and set up transition animations.
     * @param {Object} dom References to HTML elements.
     * @param {Number} transitionStartDelay ms to wait before performing transition
     * @param {Boolean} manuallyResized Have the diagram dimensions have been changed through UI
     */
    updateTransitionInfo(dom, transitionStartDelay, manuallyResized) {
        sharedTransition = getTransition(transitionStartDelay);

        const outerDims = this.calcOuterDims();
        const u = outerDims.unit;
        const innerDims = this.calcInnerDims();

        this.ratio = (window.innerWidth - 200) / outerDims.width;
        if (this.ratio > 1 || manuallyResized) this.ratio = 1;
        else if (this.ratio < 1)
            debugInfo(`Scaling diagram to ${Math.round(this.ratio * 100)}%`);

        dom.svgDiv
            .style('width', `${outerDims.width * this.ratio}${u}`)
            .style('height',`${outerDims.height * this.ratio}${u}`)

        dom.svg.transition(sharedTransition)
            .style('transform', `scale(${this.ratio})`)
            .style('width', outerDims.widthStyle)
            .style('height', outerDims.heightStyle);

        // These two properties are used when dragging the resizer box.
        this.gapDist = (this.size.partitionTreeGap * this.ratio) - 3;
        this.gapSpace = `${this.gapDist}${u}`;
        d3.select('#n2-resizer-box').transition(sharedTransition)
            .style('bottom', this.gapSpace);

        dom.pTreeGroup.transition(sharedTransition)
            .style('height', innerDims.heightStyle)
            .style('width', `${this.size.partitionTree.width}${u}`)
            .style('transform', `translate(0,${innerDims.marginStyle})`);

        dom.highlightBar.transition(sharedTransition)
            .style('height', innerDims.heightStyle)
            .style('width', '8px')
            .style('transform',
                `translate(${this.size.partitionTree.width + 1}${u},${innerDims.marginStyle})`);

        // Move n2 outer group to right of partition tree, spaced by the margin.
        dom.diagOuterGroup.transition(sharedTransition)
            .style('height', outerDims.heightStyle)
            .style('width', outerDims.heightStyle)
            .style('transform', `translate(${this.size.partitionTree.width}${u},0)`);

        dom.diagInnerGroup.transition(sharedTransition)
            .style('height', innerDims.heightStyle)
            .style('width', innerDims.heightStyle)
            .style('transform', `translate(${innerDims.marginStyle},${innerDims.marginStyle})`);

        dom.diagBackgroundRect.transition(sharedTransition)
            .style('width', innerDims.heightStyle)
            .style('height', innerDims.heightStyle)
            .style('transform', 'translate(0,0)');
    }

    /**
     * Since the matrix portion of the diagram is square, calculate the width
     * based on the height of that, plus the model tree, plus the margins.
     * @param {Number} height Height of the diagram.
     * @returns {Number} Calculated width of the diagram.
     */
    calcWidthBasedOnNewHeight(height) {
        return this.size.partitionTree.width + height + this.size.matrix.margin * 2;
    }

    /**
     * Since the matrix portion of the diagram is square, calculate the height
     * based on the width of that, minus the model tree and margins.
     * @param {Number} width Width of the diagram.
     * @returns {Number} Calculated height of the diagram.
     */
    calcHeightBasedOnNewWidth(width) {
        return width - this.size.partitionTree.width - this.size.matrix.margin * 2;
    }

    /**
     * Calculate dimensions of the diagram based on what will fit in the window.
     * @returns {Dimensions} Object with computed width and height.
     */
    calcFitDims() {
        let height = window.innerHeight * 0.95;
        let width = this.calcWidthBasedOnNewHeight(height);

        if (width > window.innerWidth - 200) {
            width = window.innerWidth - 200;
            height = this.calcHeightBasedOnNewWidth(width);
        }
        return new Dimensions ({ 'width': width, 'height': height });
    }

    /** Make a copy of the previous dimensions and linear scalers before setting new ones. */
    preservePreviousScaleValues() {
        this.treeSize.model.preserve();
        this.scales.model.preserve();
    }

    /**
     * Calculate the dimensions of the diagram in pixels as well as updating the linear
     * scale. Preserve the previous values if there are any.
     */
    updateGeometryValues() {
        if (!this.scales.firstRun) this.preservePreviousScaleValues();

        const elemDims = this.zoomedElement.draw.dims;
        const initSize = this.size.partitionTree;

        this.treeSize.model.width = (elemDims.x ?
            initSize.width - this.size.parentNodeWidth : initSize.width) / (1 - elemDims.x);
        this.treeSize.model.height = initSize.height / elemDims.height;

        this.scales.model.x
            .domain([elemDims.x, 1])
            .range([elemDims.x ? this.size.parentNodeWidth : 0, initSize.width]);

        this.scales.model.y
            .domain([elemDims.y, elemDims.y + elemDims.height])
            .range([0, initSize.height]);
    }
}

/**
 * Manage the cursor state and process click events based on it.
 * @typedef ClickHandler
 */
class ClickHandler {
    static ClickEffect = {
        Normal: 0,
        NodeInfo: 1,
        Collapse: 2,
        Filter: 3
    };

    /**
     * Set up the initial mode and define parameters for the other modes. 
     * @param {NodeInfo} nodeInfoBox Reference to the NodeInfo window to activate/deactivate it.
     */
    constructor() {
        // This tracks the current mode:
        this.clickEffect = ClickHandler.ClickEffect.Normal;

        this.modeData = {
            nodeinfo: {
                val: ClickHandler.ClickEffect.NodeInfo,
                icon: 'i.icon-info-circle',
                cursor: 'node-data-cursor',
                obj: null // to be set to nodeInfoBox later
            },
            collapse: {
                val: ClickHandler.ClickEffect.Collapse,
                icon: 'i.icon-collapse-target',
                cursor: 'collapse-mode-cursor',
                obj: null
            },
            filter: {
                val: ClickHandler.ClickEffect.Filter,
                icon: 'i.icon-filter-target',
                cursor: 'filter-mode-cursor',
                obj: null
            }
        };
    }

    update(nodeInfoBox) { this.modeData.nodeinfo.obj = nodeInfoBox; }

    get isNormal() { return this.clickEffect == ClickHandler.ClickEffect.Normal; }
    get isNodeInfo() { return this.clickEffect == ClickHandler.ClickEffect.NodeInfo; }
    get isCollapse() { return this.clickEffect == ClickHandler.ClickEffect.Collapse; }
    get isFilter() { return this.clickEffect == ClickHandler.ClickEffect.Filter; }

    /** Make sure the string used as a mode name is recognized */
    _validateMode(modeName, funcName) {
        if (! modeName in this.modeData)
            throw(`Unknown mode name '${modeName}' passed to ClickHandler.${funcName}().`)
    }

    /**
     * Color the active icon, change the mouse pointer, and update the mode state.
     * @param {String} modeName The name of the mode to activate.
     * @returns Reference to this ClickHandler object.
     */
    activate(modeName) {
        this._validateMode(modeName, 'activate');

        const m = this.modeData[modeName];
        d3.selectAll(m.icon).classed('active-tab-icon', true);
        d3.select('#all-diagram-content').classed(m.cursor, true);
        this.clickEffect = m.val;
        if (m.obj) { m.obj.activate(); }

        return this;
    }

    /**
     * Return the icon, mouse pointer, and mode state to the default.
     * @param {String} modeName The name of the mode to deactivate.
     * @returns Reference to this ClickHandler object.
     */
    deactivate(modeName) {
        this._validateMode(modeName, 'deactivate');

        const m = this.modeData[modeName];
        d3.selectAll(m.icon).classed('active-tab-icon', false);
        d3.select('#all-diagram-content').classed(m.cursor, false);
        this.clickEffect = ClickHandler.ClickEffect.Normal;
        if (m.obj) { m.obj.deactivate(); }

        return this;
    }

    /**
     * Iterate over all modes and run deactivate() on each.
     * @returns Reference to this ClickHandler object.
     */
    deactivateAll() {
        for (const modeName in this.modeData) {
            this.deactivate(modeName);
        }

        return this;
    }

    /**
     * If the specified mode is not active, activate it; if another non-default mode
     * is active, deactivate it first. If the specified mode is active, deactivate it.
     * @param {String} modeName Name of the mode to toggle.
     * @returns Reference to this ClickHandler object.
     */
    toggle(modeName) {
        this._validateMode(modeName, 'toggle');
        
        if (this.clickEffect == this.modeData[modeName].val) { return this.deactivate(modeName); }

        if (this.clickEffect != ClickHandler.ClickEffect.Normal) { this.deactivateAll(); }
        
        return this.activate(modeName);
    }
}


/**
 * Base class for toolbar button events. Show, hide, or
 * move the tool tip box.
 * @typedef ToolbarButtonNoClick
 * @property {Object} tooltipBox A reference to the tool-tip element.
 * @property {Array} tooltips One or two tooltips to display.
 * @property {Object} toolbarButton A reference to the toolbar button.
 */
class ToolbarButtonNoClick {
    /**
     * Set up the event handlers.
     * @param {String} id A selector for the button element.
     * @param {Object} tooltipBox A reference to the tool-tip element.
     * @param {String} tooptipText Content to fill the tool-tip box with.
     */
    constructor(id, tooltipBox, tooltipText) {
        this.tooltips = [tooltipText];

        this.id = id;
        this.toolbarButton = d3.select(id);
        this.tooltipBox = tooltipBox;
        this.help = null;

        this.toolbarButton
            .on("mouseover", this.mouseOver.bind(this))
            .on("mouseleave", this.mouseLeave.bind(this))
            .on("mousemove", this.mouseMove.bind(this));
    }

    /** When the mouse enters the element, show the tool tip */
    mouseOver(e) {
        this.tooltipBox
            .text(this.tooltips[0])
            .style("visibility", "visible");
    }

    /** When the mouse leaves the element, hide the tool tip */
    mouseLeave(e) {
        this.tooltipBox.style("visibility", "hidden");
    }

    /** Keep the tool-tip near the mouse */
    mouseMove(e) {
        this.tooltipBox.style("top", (e.pageY - 30) + "px")
            .style("left", (e.pageX + 5) + "px");
    }

    /**
     * Use when the info displayed on the help screen is different than the tooltip.
     * @param {String} helpText The info to display on the help screen for this button.
     * @returns {ToolbarButtonNoClick} Reference to this.
     */
    setHelpInfo(helpText) {
        this.help = helpText;
        return this;
    }

    /**
     * Grab all the info about the button that will help with generating the help screen.
     */
    getHelpInfo() {
        const parent = d3.select(this.toolbarButton.node().parentNode);
        let primaryGrpBtnId = null;
        const expansionItem = parent.classed('toolbar-group-expandable');

        if (expansionItem) {
            const grandparent = d3.select(parent.node().parentNode);
            primaryGrpBtnId = grandparent.select(':first-child').attr('id');
        }

        return {
            'id': this.id.replace('#', ''),
            'desc': this.help ? this.help : this.tooltips[0],
            'bbox': this.toolbarButton.node().getBoundingClientRect(),
            'expansionItem': expansionItem,
            'primaryGrpBtnId': primaryGrpBtnId
        };
    }
}


/**
 * Manage clickable toolbar buttons
 * @typedef ToolbarButtonClick
 * @property {Object} tooltipBox A reference to the tool-tip element.
 * @property {Array} tooltips One or two tooltips to display.
 * @property {Object} toolbarButton A reference to the toolbar button.
 * @property {Function} clickFn The function to call when clicked.
 */
class ToolbarButtonClick extends ToolbarButtonNoClick {
    /**
     * Set up the event handlers.
     * @param {String} id A selector for the button element.
     * @param {Object} tooltipBox A reference to the tool-tip element.
     * @param {String} tooptipText Content to fill the tool-tip box with.
     * @param {Function} clickFn The function to call when clicked.
     */
    constructor(id, tooltipBox, tooltipText, clickFn) {
        super(id, tooltipBox, tooltipText);
        this.clickFn = clickFn;

        let self = this;

        this.toolbarButton.on('click', function (e) { self.click(e, this); });
    }

    /**
     * Defined separately so the derived class can override
     * @param {Object} target Reference to the HTML element that was clicked
     */
    click(e, target) {
        this.clickFn(e, target);
    }
}



/**
 * Manage toolbar buttons that alternate states when clicked.
 * @typedef ToolbarButtonToggle
 * @property {Object} tooltipBox A reference to the tool-tip element.
 * @property {Array} tooltips One or two tooltips to display.
 * @property {Object} toolbarButton A reference to the toolbar button.
 * @property {Function} clickFn The function to call when clicked.
 * @property {Function} predicateFn Function returning a boolean representing the state.
 */
class ToolbarButtonToggle extends ToolbarButtonClick {
    /**
     * Set up the event handlers.
     * @param {String} id A selector for the button element.
     * @param {Object} tooltipBox A reference to the tool-tip element.
     * @param {String} tooptipTextArr A pair of tooltips for alternate states.
     * @param {Function} predicateFn Function returning a boolean representing the state.
     * @param {Function} clickFn The function to call when clicked.
     */
    constructor(id, tooltipBox, tooltipTextArr, predicateFn, clickFn) {
        super(id, tooltipBox, tooltipTextArr[0], clickFn);
        this.tooltips.push(tooltipTextArr[1]);
        this.predicateFn = predicateFn;
    }

    /**
     * When the mouse enters the element, show a tool tip based
     * on the result of the predicate function.
     */
    mouseOver() {
        this.tooltipBox
            .text(this.predicateFn() ? this.tooltips[0] : this.tooltips[1])
            .style("visibility", "visible");
    }

    /**
     * When clicked, perform the associated function, then change the tool tip
     * based on the result of the predicate function.
     * @param {Object} target Reference to the HTML element that was clicked
     */
    click(e, target) {
        this.clickFn(e, target);

        this.tooltipBox
            .text(this.predicateFn() ? this.tooltips[0] : this.tooltips[1])
            .style("visibility", "visible");

    }
}


/**
 * Create a clone of the #window-template defined in index.html and provide
 * management functions such as setting size, position, ribbon color, etc.
 * @typedef Window
 */
class Window {
    /**
     * Clone the template window defined in index.html, setup some
     * references to various elements.
     * @param {String} [newId = null] HTML id for the new window. A UUID is generated if null.
     * @param {String} [cloneId = null] The id of a window to clone other than
     *  the original template.
     */
    constructor(newId = null, cloneId = null) {
        // The primary reference for the new window
        this._window = d3.select(cloneId ? cloneId : '#window-template')
            .clone(true)
            .attr('id', newId ? newId : 'n2win' + uuidv4());

        if (!Window.container) {
            Window.container = d3.select('#n2-windows');
        }

        this._main = this._window.select('.main-window'); // Not referenced very often
        this._header = this._window.select('.window-header');
        this._title = this._header.select('.window-title');
        this._closeButton = this._window.select('.window-close-button');
        this._body = this._window.select('.window-body');
        this._footer = this._window.select('.window-footer');

        this._enabledModal = false;

        const self = this;
        this._closeButton.on('click', e => self.close(e))

        this.bringToFront(true);
    }

    // Read-only access to stored references
    get main() { return this._main; }
    get window() { return this._window; }
    get header() { return this._header; }
    get body() { return this._body; }
    get footer() { return this._footer; }
    get closeButton() { return this._closeButton; }

    /**
     * Compute the position of all four sides of the window relative to the container.
     * CAUTION: This only works correctly for a displayed element.
     * @param {Object} [container = Window.container.node()] HTML element containing window.
     * @returns {Object} Each key represents the position in pixels.
     */
    _getPos(container = Window.container.node()) {
        const parentPos = container.getBoundingClientRect(),
            childPos = this.window.node().getBoundingClientRect();

        // If hidden, move offscreen and display to get correct width and height
        if (this.hidden) {
            this.set('left', '-15000px').show();

            const tmpPos = this.window.node().getBoundingClientRect();
            childPos.width = tmpPos.width;
            childPos.height = tmpPos.height;

            this.hide().set('left', childPos.left);
        }

        let posInfo = {
            top: childPos.top - parentPos.top,
            right: parentPos.right - childPos.right,
            bottom: parentPos.bottom - childPos.bottom,
            left: childPos.left - parentPos.left,
            x: childPos.x - parentPos.x,
            y: childPos.y - parentPos.y,
            width: childPos.width,
            height: childPos.height,
            parentWidth: parentPos.width,
            parentHeight: parentPos.height
        };

        return posInfo;
    }

    /**
     * Update the window geometry with new info.
     * @param {Object} newPos Contains the bounding box data.
     * @returns {Window} Reference to this.
     */
    _setPos(newPos) {
        // All of the values need to be set because some may have started as "auto"
        for (const s of ['top', 'left', 'bottom', 'right', 'width', 'height']) {
            this.set(s, `${newPos[s]}px`);
        }

        return this;
    }

    /** Return whether the window is displayed or not. */
    get hidden() { return this.window.classed('window-inactive'); }

    /**
     * Change whether the windows is displayed or not.
     * @param {Boolean} hide The new state of the window.
     */
    set hidden(hide) {
        if (!hide) this.bringToFront();
        this.window.classed('window-inactive', hide);
    }

    /**
     * Make the window the highest z-index we know of, and increment that afterwards.
     * @param {Boolean} force Do it even if the current z-index is already highest.
     * @param {Number} [inc = 1] The amount to increase z-index by.
     * @returns {Window} Reference to this.
     */
    bringToFront(force = false, inc = 1) {
        if (force || this.window.style('z-index') < Window.zIndex) {
            Window.zIndex += inc;
            this.window.style('z-index', Window.zIndex);
        }

        return this;
    }

    /**
     * Make the window visible.
     * @returns {Window} Reference to this.
     */
    show() {
        this.hidden = false;
        return this;
    }

    /**
     * Make the window invisible.
     * @returns {Window} Reference to this.
     */
    hide() {
        this.hidden = true;
        return this;
    }

    /**
     * If window is visible, hide it; if it's hidden, show it.
     * @returns {Window} Reference to this.
     */
    toggle() {
        if (this.hidden) this.show();
        else this.hide();
        return this;
    }

    /**
     * Set the title if specified or return the current one.
     * @param {String} [newTitle = null] The optional new title.
     * @returns Reference to this if new title set; otherwise String with the current title.
     */
    title(newTitle = null) {
        if (newTitle !== null) {
            this._title.html(newTitle);
            return this;
        }

        return this._title.text();
    }

    /**
     * Change the styling of the window to a preset theme and/or return it.
     * @param {String} [newTheme = null] The name of the theme to change to. No change if null.
     * @returns If newTheme is null, a string with the current theme name;
     *  otherwise a reference to this
     */
    theme(newTheme = null) {
        const contents = this.main.select('.window-contents');
        const classes = contents.attr('class');
        const curTheme = classes.replace(/^.*(window-theme-\S+).*$/, "$1");

        if (newTheme) {
            contents
                .classed(`${curTheme}`, false)
                .classed(`window-theme-${newTheme}`, true)
        }
        else {
            return curTheme;
        }

        return this;
    }

    /**
     * Set a style or special property for the window. Recognized special
     * properties: title, theme.
     * @param {String} opt The name of the style/property to set
     * @param {String} val The value to set it to.
     * @returns {Window} Reference to this.
     */
    set(opt, val) {
        switch (opt) {
            case 'title':
                this.title(val);
                break;
            case 'theme':
                this.theme(val);
                break;
            default:
                this.window.style(opt, val);
        }

        return this;
    }

    /**
     * Iterate over a list of styles/properties w/values and set them.
     * @param {Object} options Dictionary of style/value pairs.
     * @returns {Window} Reference to this.
     */
    setList(options) {
        for (const optName in options) {
            this.set(optName, options[optName]);
        }

        return this;
    }

    /** Delete the window element from the document and remove the event handler. */
    close(e) {
        this.closeButton.on('click', null);
        this.modal(false);
        this.window.remove();
    }

    /**
     * Make the close button invisibile.
     * @returns {Window} Reference to this.
     */
    hideCloseButton() {
        this.closeButton.classed('window-inactive', true);
        return this;
    }

    /**
     * Make the close button visibile.
     * @returns {Window} Reference to this.
     */
    showCloseButton() {
        this.closeButton.classed('window-inactive', false);
        return this;
    }

    /** Set the text in the footer ribbon.
     * @param {String} [footerText = null] If not empty, set the text in the footer.
     * @returns {Window} Reference to this.
     */
    footerText(newText = null) {
        this.footer.select('span').text(newText);
        return this;
    }

    /** Determine whether the footer is visible in this theme. */
    hasFooter() {
        return visible(this.footer.node());
    }

    /**
     * Change the color of both the header and footer
     * @param {String} color An HTML-compatible color value
     * @returns {Window} Reference to this.
     */
    ribbonColor(color) {
        this.header.style('background-color', color);
        this.footer.style('background-color', color);

        return this;
    }

    /**
     * Move the window to the specified coordinates.
     * @param {Number} x If positive, set the left property to this and adjust
     *   the right. If negative, set the right property to this and adjust left.
     * @param {Number} y If positive, set the top property to this and adjust
     *   the bottom. If negative, set the bottom property to this and adjust top.
     * @returns {Window} Reference to this.
     */
    move(x, y) {
        let pos = this._getPos(d3.select('body').node());
        if (x >= 0 ) {
            pos.left = x;
            pos.right = pos.parentWidth - pos.width - pos.left;
        }
        else {
            pos.right = -x;
            pos.left = pos.parentWidth - pos.width - pos.right;
        }

        if (y >= 0) {
            pos.top = y;
            pos.bottom = pos.parentHeight - pos.height - pos.top;
        }
        else {
            pos.bottom = -y;
            pos.top = pos.parentHeight - pos.height - pos.bottom;
        }

        this._setPos(pos);

        return this;
    }

    /**
     * Relocate the window to a position near the mouse
     * @param {Object} event The triggering event containing the position.
     * @param {Number} [offset = 15] Distance from mouse to place window.
     * @returns {Window} Reference to this.
     */
    moveNearMouse(event, offset = 15) {
        let pos = this._getPos();

        // Mouse is in left half of browser, put window to right of mouse
        if (event.clientX < window.innerWidth / 2) {
            pos.left = event.pageX + offset;
            pos.right = pos.left + pos.width;
        }
        // Mouse is in right half of browser, put window to left of mouse
        else {
            pos.right = event.pageX - offset;
            pos.left = pos.right - pos.width;
        }

        // Mouse is in top half of browser, put window below mouse
        if (event.clientY < window.innerHeight / 2) {
            pos.top = event.pageY + offset;
            pos.bottom = pos.top + pos.height;
        }
        // Mouse is in bottom half of browser, put window above mouse
        else {
            pos.bottom = event.pageY - offset;
            pos.top = pos.bottom - pos.height;
        }

        this._setPos(pos);
        return this;
    }

    /**
     * Since the window is absolutely-positioned with top, left, bottom, right set, we have
     * to manually adjust things if we want the contents to determine the width and height.
     * This should be called anytime content is added and the size is expected to change.
     * TODO: Create a flag and event handler to do this automatically, maybe via
     * MutationObserver.
     * @returns {Window} Reference to this.
     */
    sizeToContent(extraWidth = 0, extraHeight = 2, considerTitle = false) {
        const bodyWidth = this.body.node().scrollWidth;
        const titleWidth = this._title.node().scrollWidth + 60;
        const contentWidth = ((!considerTitle || bodyWidth > titleWidth)? bodyWidth : titleWidth) + extraWidth;
        const contentHeight = this.body.node().scrollHeight;
        const headerHeight = this.header.node().offsetHeight
        const footerHeight = this.hasFooter() ? this.footer.node().offsetHeight : 0;

        const totalHeight = contentHeight + headerHeight + footerHeight + extraHeight;

        const newSize = {
            width: contentWidth + 'px',
            height: totalHeight + 'px'
        };
        this.setList(newSize);

        return this;
    }

    /**
     * Make visible the div that separates this window from everything else
     * @param {Boolean} [enable = null] Turn on modal mode if true, off if false.
     * @param {String} [style = null] Change the default appearance of translucent black.
     * @returns Modal setting if enable is null, otherwise current modal state.
     */
    modal(enable = null, style = null) {
        const modalDiv = d3.select('.n2-windows-modal-bg');
        if (enable === null) { return this._enabledModal; }

        if (enable) {
            this.bringToFront(true, 2);
            modalDiv.attr('style', style)
                .style('z-index', Window.zIndex - 1)
                
        }
        else {
            modalDiv.attr('style', null);
        }

        modalDiv.classed('window-inactive', !enable);
        this._enabledModal = enable;
        return this;
    }

    /**
     * Take ownership of a predefined DOM object, usually a div, by appending
     * its children to the window body. This allows the definition of more
     * complex window contents to be located in index.html for example.
     * @param {String} id HTML id of the object to copy.
     */
    absorbBody(id) {
      const newParent = this.body.node();
      const oldParent = d3.select(id).node();

        while (oldParent.childNodes.length > 0) {
            newParent.appendChild(oldParent.childNodes[0]);
        }

        oldParent.remove();
    }

    /**
     * Copy the structure of a predefined DOM object, usually a div, by cloning
     * its children to the window body. This allows the definition of more
     * complex window contents to be located in index.html for example.
     * @param {String} id HTML id of the object to copy.
     */
     copyBody(id) {
        const dstParent = this.body.node();
        const srcParent = d3.select(id).node();
  
          for (const child of srcParent.childNodes) {
              dstParent.appendChild(child.cloneNode(true));
          }
      }
}


/**
 * Keep increasing z-index of the focused window to keep it on top.
 * Max z-index is 2147483647. It will be unusual here for it to climb
 * above 100, and even extreme cases (e.g. a diagram that's been in use
 * for weeks with lots of windows) shouldn't get above a few thousand.
 */
Window.zIndex = 1000;
Window.container = null;


/**
 * Display a modal window with helpful information.
 * @typedef DiagramHelp
 */
class DiagramHelp extends Window {
    /**
     * Using data generated by Toolbar, document each of the buttons.
     * @param {Object} helpInfo Data structure containing Toolbar button info.
     */
    constructor(helpInfo, footerText = '') {
        super();

        this.theme('help')
            .setList({ left: '100px', top: '20px', right: '100px', height: '850px' })
            .title('Instructions')
            .footerText(footerText);

        this.absorbBody('#toolbar-help-container');

        this.helpDiv = this.body.select('div.help-graphic');
        this.helpSvg = this.helpDiv.select('#help-graphic-svg');

        this._addButtonHelpText(helpInfo);

        this.show().modal(true);
    }

    /** Override Window::close() to just hide the help window. */
    close() {
        this.modal(false);
        this.hide();
        return this;
    }

    /**
     * Add a line of text for each button. Buttons not contained in an expandable
     * menu are labeled to the left, while the expansion buttons are described
     * in groups at the right.
     * @param {Object} helpInfo Data structure containing Toolbar button info.
     */
    _addButtonHelpText(helpInfo) {
        let topPx = 20;
        for (const btnId in helpInfo.buttons) {
            const btn = helpInfo.buttons[btnId];

            // Detail the "primary" toolbar buttons
            if (!btn.expansionItem) {
                const btnText = this.helpDiv.append('p').attr('class', 'help-text');
                btn.helpWinText = btnText;
                btnText.style('left', helpInfo.width + 5 + 'px')
                    .style('top', btn.bbox.top + btn.bbox.height / 2 - 13 + 'px')
                    .text(btn.desc);

                // Detail the expansion buttons
                let grp = null;
                if (btnId in helpInfo.primaryButtons) {
                    btnText.classed('help-button-group', true)
                    grp = this.helpDiv.append('div')
                        .attr('id', btnId + '-help-group')
                        .attr('class', 'help-button-group')
                        .style('top', topPx + 'px')

                    for (const memId of helpInfo.primaryButtons[btnId]) {
                        const memClasses = d3.select('#' + memId).attr('class').split(/ /);

                        let memClass = '';
                        for (const mc of memClasses) {
                            if (mc.match(/^icon-/)) {
                                memClass = mc;
                                break;
                            }
                        }
                        grp.append('p').attr('class', 'help-text')
                            .html(`<i class="fas ${memClass} help-text-icon"></i><span>${helpInfo.buttons[memId].desc}</span>`)
                    }

                    const grpBbox = grp.node().getBoundingClientRect();
                    topPx += grpBbox.height + 25;

                    this._drawGroupLines(btnText, grp)
                }
            }
        }
    }

    /**
     * Draw a path in SVG connecting the button that opens the expansion
     * to the boxes containing descriptions of the individual buttons.
     */
    _drawGroupLines(btnText, grp) {
        const winBRect = this.helpDiv.node().getBoundingClientRect(),
            textBRect = btnText.node().getBoundingClientRect(),
            grpBRect = grp.node().getBoundingClientRect();

        const vertOffset = 7;

        const coords = {
            ul: { x: textBRect.right - winBRect.left + 5, y: textBRect.top - winBRect.top + vertOffset },
            ur: { x: grpBRect.left - winBRect.left, y: grpBRect.top - winBRect.top + 0.5 },
            bl: { x: textBRect.right - winBRect.left + 5, y: textBRect.bottom - winBRect.top - vertOffset },
            br: { x: grpBRect.left - winBRect.left, y: grpBRect.bottom - winBRect.top - 0.5 }
        }

        const curve = {
            ul: { x: coords.ul.x + 5, y: coords.ul.y + 5 },
            bl: { x: coords.bl.x + 5, y: coords.bl.y - 5 }
        }

        const path = `M${coords.ur.x},${coords.ur.y} L${coords.ul.x},${coords.ul.y} ` +
            `C${curve.ul.x},${curve.ul.y} ${curve.bl.x},${curve.bl.y} ${coords.bl.x},${coords.bl.y} ` +
            `L${coords.br.x},${coords.br.y}`

        this.helpSvg.append('path').attr('d', path).attr('class', 'help-line');
    }
}


/**
 * Manage the set of buttons and tools at the left of the diagram.
 * @typedef Toolbar
 * @property {Boolean} hidden Whether the toolbar is visible or not.
 */
class Toolbar {
    /**
     * Set up the event handlers for mouse hovering and clicking.
     * @param {UserInterface} ui Reference to the main interface object
     */
    constructor(ui) {
        this.toolbarContainer = d3.select('#toolbarLoc');
        this.toolbar = d3.select('#true-toolbar');
        this.hideToolbarButton = d3.select('.toolbar-hide-container');
        this.hideToolbarIcon = this.hideToolbarButton.select('i');
        this.searchBar = d3.select('#awesompleteId');
        this.searchCount = d3.select('#searchCountId');
        this.buttons = [];

        this.hidden = true;
        this.helpInfo = null;

        // Display toolbar if not embedded, or if embedded doc location
        // href include the #toolbar anchor

        if (!EMBEDDED || (EMBEDDED && window.location.href.includes('#toolbar'))) {
            this.show();
        }

        this._setupButtonFunctions(ui);
        this._setupHelp();
        this._helpWindow = null;
    }

    /**
     * Generate the data structure that describes all of the toolbar buttons. Nothing
     * is actually rendered here (that is done in the Help constructor.)
     */
    _setupHelp() {
        const toolbarBRect = this.toolbarContainer.node().getBoundingClientRect();

        this.helpInfo = {
            width: toolbarBRect.width,
            height: toolbarBRect.height,
            buttons: {},
            primaryButtons: {},
            groups: 0
        };

        for (const btn of this.buttons) {
            const info = btn.getHelpInfo();
            this.helpInfo.buttons[info.id] = info;
            if (info.primaryGrpBtnId) { // Is this a "child" of a group?
                // Keep track of which buttons are at the front of collapsing groups
                // and the group member ids
                if (info.primaryGrpBtnId in this.helpInfo.primaryButtons) {
                    this.helpInfo.primaryButtons[info.primaryGrpBtnId].push(info.id);
                }
                else {
                    this.helpInfo.primaryButtons[info.primaryGrpBtnId] = [info.id];
                }
            }
        }
    }

    /** Either create the help window the first time or redisplay it */
    _showHelp() {
        if (!this._helpWindow) this._helpWindow = new DiagramHelp(this.helpInfo);
        else this._helpWindow.show().modal(true);
    }

    /** Slide everything to the left offscreen, rotate the button */
    hide() {
        this.toolbarContainer.style('left', '-65px');
        this.hideToolbarIcon.style('transform', 'rotate(-180deg)');
        d3.select('#d3_content_div').style('margin-left', '-65px');
        this.hidden = true;
    }

    /** Slide everything to the right and rotate the button */
    show() {
        this.hideToolbarIcon.style('transform', 'rotate(0deg)');
        this.toolbarContainer.style('left', '0px');
        d3.select('#d3_content_div').style('margin-left', '0px');
        this.hidden = false;
    }

    /** Automatically select between visibile/hidden. */
    toggle() {
        if (this.hidden) this.show();
        else this.hide();
    }

    /**
     * When an expanded button is clicked, update the 'root' button to the same icon/function.
     * @param {HTMLElement} clickedNode The element where the event was triggered.
     */
    _setRootButton(clickedNode) {
        const container = d3.select(clickedNode.parentNode.parentNode);
        if (!container.classed('expandable')) return;

        const button = d3.select(clickedNode);
        const rootButton = container.select('i:not(.caret)');

        rootButton
            .attr('class', button.attr('class'))
            .attr('id', button.attr('id'))
            .on('click', button.on('click'));
    }

    /**
     * Minimal management of buttons which will be described on the help window.
     * @param {ToolbarButton} btn The button to add.
     * @returns {ToolbarButton} A reference to the new button.
     */
    _addButton(btn) {
        this.buttons.push(btn);
        return btn;
    }

    /**
     * When buttons are added out-of-order, the help screen can be jumbled. Using
     * this method gives control over where the button goes into the array which
     * corresponds to the order it appears on the help screen. This doesn't affect
     * the appearance of the functional toolbar.
     * @param {ToolbarButton} btn The button to add.
     * @param {Number} idx The position to insert the button into the array.
     * @returns {ToolbarButton} A reference to the new button.
     */
    _addButtonAtIndex(btn, idx) {
        this.buttons.splice(idx, 0, btn);
        return btn;
    }

    /** Get a snapshot of the search term and match count. */
    getSearchState() {
        return {
                'term': this.searchBar.property('value'),
                'matches': this.searchCount.html()
        }
    }

    /** Restore a snapshot of the search term and match count. */
    setSearchState(searchInfo) {
        this.searchBar.property('value', searchInfo.term);
        this.searchCount.html(searchInfo.matches);
    }

    /**
     * Associate all of the buttons on the toolbar with a method in UserInterface.
     * @param {UserInterface} ui A reference to the UI object
     */
    _setupButtonFunctions(ui) {
        const self = this; // For callbacks that change "this". Alternative to using .bind().
        const tooltipBox = d3.select(".tool-tip");

        this._addButton(new ToolbarButtonClick('#searchButtonId', tooltipBox,
            "Collapse model to variables matching search term",
            () => {
                if (self.searchBar.node().value == '') {
                    self.searchCount.html('0 matches');
                }

                d3.select('#searchbar-and-label').attr('class', 'searchbar-visible');

                // This is necessary rather than just calling focus() due to the
                // transition animation
                window.setTimeout(function () {
                    self.searchBar.node().focus();
                }, 200);

                // Retract search bar when focus is lost
                self.searchBar.on('focusout', function () {
                    d3.select('#searchbar-and-label').attr('class', 'searchbar-hidden')
                    self.searchBar.on('focusout', null);
                });
            })
        );

        this._addButton(new ToolbarButtonClick('#reset-graph', tooltipBox,
            "View entire model starting from root", () => ui.homeButtonClick()));

        this._addButton(new ToolbarButtonClick('#undo-graph', tooltipBox,
            "Move back in view history", () => ui.backButtonPressed()));

        this._addButton(new ToolbarButtonClick('#redo-graph', tooltipBox,
            "Move forward in view history", () => ui.forwardButtonPressed()));

        this._addButton(new ToolbarButtonClick('#collapse-element', tooltipBox,
            "Control variable collapsing",
            () => ui.collapseAll(ui.diag.zoomedElement)));

        this._addButton(new ToolbarButtonClick('#collapse-element-2', tooltipBox,
            "Collapse only variables in current view",
            (e, target) => {
                ui.collapseAll(ui.diag.zoomedElement);
                self._setRootButton(target);
            }));

        this._addButton(new ToolbarButtonClick('#collapse-all', tooltipBox,
            "Collapse all variables in entire model",
            (e, target) => {
                ui.collapseAll(ui.diag.model.root);
                self._setRootButton(target);
            }));

        this._addButton(new ToolbarButtonClick('#expand-element', tooltipBox,
            "Expand only variables in current view",
            (e, target) => { 
                ui.expandAll(ui.diag.zoomedElement);
                self._setRootButton(target);
            }));

        this._addButton(new ToolbarButtonClick('#expand-all', tooltipBox,
            "Expand all variables in entire model",
            (e, target) => {
                ui.expandAll(ui.diag.model.root);
                self._setRootButton(target);
            }));

        this._addButton(new ToolbarButtonToggle('#info-button', tooltipBox,
            ["Hide detailed node information", "Show detailed node information"],
            () => { return ui.click.isNodeInfo; },
            () => { ui.click.toggle('nodeinfo'); })).setHelpInfo("Select left-click action");

        this._addButton(new ToolbarButtonToggle('#info-button-2', tooltipBox,
            ["Hide detailed node information", "Show detailed node information"],
            () => { return ui.click.isNodeInfo; },
            (e, target) => {
                ui.click.toggle('nodeinfo');
                self._setRootButton(target);
            })).setHelpInfo("Toggle detailed node info mode");

        this._addButton(new ToolbarButtonToggle('#collapse-target', tooltipBox,
            ["Exit collapse/expand mode", "Enter collapse/expand mode"],
            () => { return ui.click.clickEffect == ClickHandler.ClickEffect.Collapse; },
            (e, target) => {
                ui.click.toggle('collapse');
                self._setRootButton(target);
            })).setHelpInfo("Toggle collapse/expand mode");

        this._addButton(new ToolbarButtonToggle('#filter-target', tooltipBox,
            ["Exit variable filtering mode", "Enter variable filtering mode"],
            () => { return ui.click.clickEffect == ClickHandler.ClickEffect.Filter; },
            (e, target) => {
                ui.click.toggle('filter');
                self._setRootButton(target);
            })).setHelpInfo("Toggle variable filtering mode");

        this._addButton(new ToolbarButtonClick('#hide-connections', tooltipBox,
            "Set connections visibility",
            () => ui.diag.clearArrows()));

        this._addButton(new ToolbarButtonClick('#hide-connections-2', tooltipBox,
            "Remove all connection arrows",
            (e, target) => { ui.diag.clearArrows(); self._setRootButton(target); }));

        this._addButton(new ToolbarButtonClick('#show-all-connections', tooltipBox,
            "Show all connections in view",
            (e, target) => { ui.diag.showAllArrows(); self._setRootButton(target); }));

        this._addButton(new ToolbarButtonNoClick('#text-slider-button', tooltipBox,
            "Set text height"));
        this._addButton(new ToolbarButtonNoClick('#depth-slider-button', tooltipBox,
            "Set collapse depth"));
        this._addButton(new ToolbarButtonNoClick('#model-slider-button', tooltipBox,
            "Set model height"));

        this._addButton(new ToolbarButtonNoClick('#save-load-button', tooltipBox,
            "Save or load an image or view"));

        this._addButton(new ToolbarButtonClick('#save-button', tooltipBox,
            "Save to SVG", () => ui.diag.saveSvg() ));

        this._addButton(new ToolbarButtonClick('#save-state-button', tooltipBox,
            "Save View", () => ui.saveState() ));

        this._addButton(new ToolbarButtonClick('#load-state-button', tooltipBox,
            "Load View", () => ui.loadState() ));

        this._addButton(new ToolbarButtonToggle('#legend-button', tooltipBox,
            ["Show legend", "Hide legend"],
            () => ui.legend.hidden,
            (e, target) => { ui.toggleLegend(); self._setRootButton(target); }))
            .setHelpInfo("Toggle legend");

        this._addButton(new ToolbarButtonClick('#question-button', tooltipBox,
            "Display help window",
            (e, target) => { self._showHelp(); self._setRootButton(target); }));

        this._addButton(new ToolbarButtonClick('#question-button-2', tooltipBox,
            "Display help window",
            (e, target) => { self._showHelp(); self._setRootButton(target); }));

        // Don't add this to the array of tracked buttons because it confuses
        // the help screen generation
        new ToolbarButtonToggle('#hide-toolbar', tooltipBox,
            ["Show toolbar", "Hide toolbar"],
            () => self.hidden, () => self.toggle());

        // The font size slider is a range input
        this.toolbar.select('#text-slider').on('input', function() {
            const fontSize = this.value;
            ui.diag.fontSizeSelectChange(fontSize);

            const fontSizeIndicator = self.toolbar.select('#font-size-indicator');
            fontSizeIndicator.html(fontSize + ' px');
        });

        // The model height slider is a range input
        this.toolbar.select('#model-slider')
            .on('input', function() {
                d3.select('#model-slider-label').html(`${this.value}%`);
            })
            .on('mouseup', function() {
                ui.diag.manuallyResized = true;
                const modelHeight = window.innerHeight * (parseInt(this.value) / 100);
                ui.diag.verticalResize(modelHeight);
            });

        this.toolbar.select('#model-slider-fit')
            .on('click', function() {
                ui.diag.manuallyResized = false;
                d3.select('#model-slider').node().value = '95';
                d3.select('#model-slider-label').html("95%")
                ui.diag.verticalResize(window.innerHeight * .95);
            })
    }
}



/**
 * Extends Window by allowing the window to be dragged with a mousedown on the header/title.
 * @typedef WindowDraggable
 */
class WindowDraggable extends Window {
    /** Execute the base class constructor and set up drag event handler */
    constructor(newId = null, cloneId = null) {
        super(newId, cloneId);
        this.boundaryMargin = 10;
        this._setupDrag();
    }

    /** Remove the mousedown event handler and call the superclass close() */
    close(e) {
        this.header.on('mousedown', null);
        super.close(e);
    }

    _doDragHeader(e) { this._doDrag(e, '.window-header'); }
    _doDragFooter(e) { this._doDrag(e, '.window-footer'); }

    /** Prevent the window from being dragged off the left or right of the browser. */
    _applyHorizontalBounds(testX) {
        return (testX < this.boundaryMargin ?
            this.boundaryMargin : 
                    (testX > window.innerWidth - this.boundaryMargin?
                        window.innerWidth - this.boundaryMargin : testX));
    }

    /** Prevent the window from being dragged off the top or bottom of the browser. */
    _applyVerticalBounds(testY) {
        return (testY < this.boundaryMargin ?
            this.boundaryMargin : 
                    (testY > window.innerHeight - this.boundaryMargin?
                        window.innerHeight - this.boundaryMargin : testY));
    }

    /** 
     * Perform the dragging operation on either header or footer. The start of the event
     * also brings the window to the front.
     */
    _doDrag(e, ribbonClass) {
        const self = this;
        const dragDiv = self.window;

        self.bringToFront();
        dragDiv.style('cursor', 'grabbing')
            .select(ribbonClass).style('cursor', 'grabbing');

        const dragStart = [e.pageX, e.pageY];
        let newTrans = [0, 0];

        const w = d3.select(window)
            .on("mousemove", e => {
                const x = self._applyHorizontalBounds(e.pageX),
                    y = self._applyVerticalBounds(e.pageY);
                newTrans = [x - dragStart[0], y - dragStart[1]];
                dragDiv.style('transform', `translate(${newTrans[0]}px, ${newTrans[1]}px)`)
            })
            .on("mouseup", () => {
                // Convert the translate to style position
                self._setPos(self._getPos());

                dragDiv.style('cursor', 'auto')
                    .style('transform', null)
                    .select(ribbonClass)
                    .style('cursor', 'grab');

                // Remove event listeners
                w.on("mousemove", null).on("mouseup", null);
            });

        e.preventDefault();
    }

    /** Listen for the mousedown event to begin dragging the window. */
    _setupDrag() {
        const self = this;

        this.header
            .classed('window-draggable-ribbon', true)
            .on('mousedown', self._doDragHeader.bind(self));

        this.footer
            .classed('window-draggable-ribbon', true)
            .on('mousedown', self._doDragFooter.bind(self));
    }
}


/**
 * Manage a window that allows the user to select which variables to display.
 * TODO: Make column headers sticky, improve autosizing
 * without using sizeToContent(3,30)
 * @typedef ChildSelectDialog
 */
class ChildSelectDialog extends WindowDraggable {
    /**
     * Setup the basic structure of the variable selection dialog.
     * @param {TreeNode} node The node to examine the variables of.
     * @param {String} color The color to make the window header/footer ribbons.
     * @param {Diagram} diag The diagram object to work with.
     */
     constructor(e, node, color, diag) {
        super('childSelect-' + node.toId());
        this.node = node;
        this.nodeColor = color;
        this.diag = diag;
        this.scrollbarWidth = 14;
        this.searchTerm = ('searchTerm' in node)? node.searchTerm : null;

        this.ribbonColor(this.nodeColor);
        
        // Don't do anything else if the node has no variables
        if ( ! this._fetchVarNames() ) { this.close(); }
        else { this._initialSetup(e); }
    }
    
    /**
     * Find all the children of the node that are variables.
     * @returns {Boolean} True if any variables were found, otherwise false.
     */
    _fetchVarNames() {
        // Only add children that are variables.
        let foundVariables = false;

        this.varNames = {};
        this.varNameArr = []; // For sorting purposes

        for (const child of this.node.children) {
            if (!child.isInputOrOutput()) { continue; }
            foundVariables = true;

            // Use getTextName() because Auto-IVC variable names are not usually descriptive.
            const varName = child.getTextName();
            this.varNames[varName] = child;
            this.varNameArr.push(varName)

        }

        return foundVariables;
    }

    /**
     * Configure the window structure, then call repopulate() to list the variable names.
     */
    _initialSetup(e) {
        const self = this;

        this.minWidth = 300;
        this.minHeight = 100;
        this.theme('child-select');
        this.title(this.node.name);
        this.copyBody('#variable-selection-body');

        this.headerTable = this.body.select('table.header');
        const topRow = this.headerTable.select('tr');
        const childName = topRow.select('th:first-child');

        childName.select('span.sort-up') // Up arrow
            .on('click', e => {
                self.varNameArr.sort();
                self.repopulate();
            });

        childName.select('span.sort-down') // Down arrow
            .on('click', e => {
                self.varNameArr.sort();
                self.varNameArr.reverse();
                self.repopulate();
            });

        this.tableContainer = this.body.select('div.table-container');
        this.table = this.tableContainer.select('table.variables');
        const UA = navigator.userAgent;
        if (! /Chrom/.test(UA)) {          
            // Chrome puts the scrollbar outside the element, other browsers inside
            this.table.style('margin-right', `${this.scrollbarWidth}px`);
        }

        this.tbody = this.table.select('tbody');

        // Search
        this.searchContainer = this.body.select('div.search-container');
        this.searchBox = this.searchContainer.select('input');
        if (this.searchTerm) { this.searchBox.property('value', this.searchTerm); }
        this.searchBox.on('keyup', self.updateSearch.bind(self));

        // Clear the search box and repopulate the variable list by clicking on the X button
        this.searchContainer.select('.search-clear').on('click', e => {
            self.searchTerm = '';
            self.searchBox.property('value', '');
            self.updateSearch(e, true);
        });

        // Execute the search by clicking on the arrow button
        this.searchContainer.select('.search-perform').on('click', e => {
            self.updateSearch(e, true);
        });

        this.buttonContainer = this.body.select('div.button-container');

        // Apply button
        this.buttonContainer.select('button.select-all-variables')
            .on('click', self.selectAll.bind(self));

        // Select None button
        this.buttonContainer.select('button.select-no-variables')
            .on('click', self.selectNone.bind(self));

        // Select All button
        this.buttonContainer.select('button.apply-variable-selection')
            .on('click', self.apply.bind(self));

        this.scrollbarSpacer = topRow.select('th.scrollbar-spacer');
        this.repopulate();
        this.resize();
        this.modal(true)
            .moveNearMouse(e)
            .show();
    }

    /** Reset the array of hidden vars from the node's array if it exists. */
    _initHiddenVars() {
        this.hiddenVars = [];
        this.existingHiddenVars = false;

        for (const filter of this.node.getFilterList()) {
            if (filter.count > 0) {
                for (const child of filter.children) {
                    this.hiddenVars.push(child);
                };
                this.existingHiddenVars = true;
            }
        }
    }

    /** Add all the variables, their display status, and the control buttons. */
    repopulate() {
        const self = this;
        this.tbody.html('');
        
        // If a search term was used, treat it as a regular expression.
        const matchRe = this.searchTerm? new RegExp(this.searchTerm, 'i') : null;
        this._initHiddenVars();
        this.foundSearchVars = [];

        let isEven = true;
        this.varCount = 0;
        for (const varName of this.varNameArr) {
            const child = this.varNames[varName];

            if (matchRe) {
                // Variable names not matching the regexp are hidden.
                if (! matchRe.test(varName)) { 
                    this.hiddenVars.push(child);
                    continue;
                }
                // Matching variable names are remembered.
                else {
                    this.foundSearchVars.push(child);
                }
            }
            
            this.varCount++;

            // Alternate row colors:
            const row = this.tbody.append('tr').attr('class', isEven? 'even' : 'odd');
            isEven = !isEven;

            row.append('td').attr('class', 'varname').text(varName);
            const checkId = `${child.toId()}-visible-check`;
            if (child.isFilteredVariable() && ! this.existingHiddenVars) { this.hiddenVars.push(child); }

            // Add a checkbox. When checked, the variable will be displayed.
            row.append('td').attr('class', 'varvis')
                .append('input')
                .attr('type', 'checkbox')
                .property('checked', !child.isFilteredVariable())
                .attr('id', checkId)
                .on('change', e => {
                    const isVisible = d3.select(`#${checkId}`).property('checked');
                    if (!isVisible) { this.hiddenVars.push(child); }
                    else { 
                        const idx = this.hiddenVars.indexOf(child);
                        if (idx > -1 ) { this.hiddenVars.splice(idx, 1); }
                        else { console.warn('Could not find child in hiddenVars array.', child); }
                    }
                })
        }

        if (this.varCount == 0) {
            this.tbody.append('tr')
                .append('td')
                .style('text-align', 'center')
                .attr('colspan','2')
                .text('No matching variables found.')
        }

        return this;
    }

    /**
     * If the container scroll height is larger than the visible height the scrollbar is there.
     * @returns {Boolean} True if the scrollbar is visible, false otherwise.
     */
    scrollbarIsVisible() {
        return (this.tableContainer.node().scrollHeight > this.tableContainer.node().clientHeight);
    }

    /** Clicking Apply closes the dialog and updates the diagram. */
    apply() {
        if (this.hiddenVars.length == this.node.children.length || this.varCount == 0) {
            // If every variable was hidden, just collapse the node if it's expanded
            if (! this.node.draw.minimized) { this.diag.ui.rightClick(this.node); }
        }
        else {
            this.diag.ui.rightClickedNode = this.node;
            this.diag.ui.addBackButtonHistory();

            this.node.searchTerm = this.searchTerm;
            this.node.wipeFilters();

            for (const child of this.hiddenVars) {
                this.node.addToFilter(child);
            }
            
            if (this.node.draw.minimized) {
                // If node itself is collapsed, expand it
                this.node.draw.manuallyExpanded = true;
                this.node.expand();
            }
            this.diag.update();
        }
        this.close();
    }

    /**
     * Make all variable names visible. If a search term is active, make all
     * matching variable names visible.
     */
    selectAll() {
        d3.selectAll('.window-theme-child-select input[type="checkbox"]')
            .property('checked', true);
        this.hiddenVars = [];

        if (this.foundSearchVars.length > 0) {
            // Select variables not found by search
            for (const child of this.node.children) {
                if (child.isFilter()) continue;
                if (this.foundSearchVars.indexOf(child) < 0) {
                    this.hiddenVars.push(child);
                }
            }
        }
    }

    /** Hide all variable names */
    selectNone() {
        d3.selectAll('.window-theme-child-select input[type="checkbox"]')
            .property('checked', false);
        this.hiddenVars = [];

        for (const child of this.node.children) {
            if (child.isFilter()) continue;
            this.hiddenVars.push(child);
        }

    }

    /** Adjust the size of the window body object based on the size of their contents. */
    resize() {
        const headerTableNode = this.headerTable.node(),
            searchConNode = this.searchContainer.node(),
            newHeight =
                `${headerTableNode.scrollHeight +
                this.tableContainer.node().clientHeight +
                searchConNode.scrollHeight +
                this.buttonContainer.node().scrollHeight + 7}px`,
            newWidth = `${this.table.node().scrollWidth + this.scrollbarWidth}px`;

        this.body.style('height', newHeight).style('width', newWidth);
        this.tableContainer.style('width', newWidth);
        this.headerTable.style('width', newWidth);

        if (this.varCount > 0) {
            this.headerTable.select('th.varname')
                .style('width', this.table.select('td.varname').style('width'));
            this.headerTable.select('th.varvis')
                .style('width', this.table.select('td.varvis').style('width'));
        }

        this.searchContainer.style('width', newWidth);

        const displayScrollbar = this.scrollbarIsVisible()? null : 'none';
        this.scrollbarSpacer.style('display', displayScrollbar);
        
        this.sizeToContent(3,4);

        return this;
    }

    /** Update the variable list based on the provided search term. */
    updateSearch(e, clicked = false) {
        if (e.keyCode == 13 || clicked) {
                this.searchTerm = this.searchBox.property('value');
                this.repopulate();
                this.resize();
        }

        return this;
    }
}




/**
 * Extends WindowDraggable by setting up 8 divs around the perimeter of the window
 * that change the cursor with mouseover, and allow resizing with mousedown.
 * @typedef WindowResizable
 */
class WindowResizable extends WindowDraggable {
    constructor(newId = null, cloneId = null, sizeOpts = {}) {
        super(newId, cloneId);

        this.min = {
            width: exists(sizeOpts.minWidth) ? sizeOpts.minWidth : 200,
            height: exists(sizeOpts.minHeight) ? sizeOpts.minHeight : 200
        };

        this.max = {
            width: exists(sizeOpts.maxWidth) ? sizeOpts.maxWidth : window.innerWidth,
            height: exists(sizeOpts.maxHeight) ? sizeOpts.maxHeight : window.innerHeight
        };

        this._setupResizers();
    }

    // Read-only getters
    get minWidth() { return this.min.width; }
    get minHeight() { return this.min.height; }
    get maxWidth() { return this.max.width; }
    get maxHeight() { return this.max.height; }

    // Write-only setters
    set minWidth(val) { this.min.width = val; }
    set minHeight(val) { this.min.height = val; }
    set maxWidth(val) { this.max.width = val; }
    set maxHeight(val) { this.max.height = val; }

    /**
     * Set the cursor for all elements to the specified value, for the purpose
     * of resizing the window and not having the cursor change every time another
     * element is hovered.
     * @param {String} cursor The new value of the cursor.
     */
    _lockCursor(cursor) {
        this.header.style('cursor', cursor);
        this.window.style('cursor', cursor);
        this.window.select('.window-close-button').style('cursor', cursor);
        this.resizerDiv.selectAll('div').style('cursor', cursor);        

        return this;
    }

    /**
     * Add event handlers for each of the 8 resizer elements surrounding the window.
     */
    _setupResizers() {
        const self = this;

        const resizerClassNames = {
            'top': 'horizontal',
            'top-right': 'corner',
            'right': 'vertical',
            'bottom-right': 'corner',
            'bottom': 'horizontal',
            'bottom-left': 'corner',
            'left': 'vertical',
            'top-left': 'corner'
        }

        // Add div to contain the 8 resizer elements
        this.resizerDiv = this.window.select('.main-window')
            .append('div')
            .attr('class', 'resize');

        // For each side, 'mult' refers to whether a coordinate is to be added or subtracted.
        // 'idx' refers to the index of the delta x or y value of the new mouse position.
        // 'dir' is the direction name to check for the min/max size.
        const dirVals = {
            top: { mult: 1, idx: 1, dir: 'height' },
            right: { mult: -1, idx: 0, dir: 'width' },
            bottom: { mult: -1, idx: 1, dir: 'height' },
            left: { mult: 1, idx: 0, dir: 'width' }
        }

        // Set up a mousedown event listener for each of the 8 elements.
        for (const name in resizerClassNames) {
            // Add the div that the resizer mouse event handler will be on
            const resizer = this.resizerDiv.append('div')
                // Class style settings determine where each div is positioned
                .attr('class', `rsz-${name} rsz-${resizerClassNames[name]}`);

            const dirs = name.split('-'); // From class name, figure out which directions to handle
            resizer.on('mousedown', e => {
                const startDims = self._getPos();
                self.bringToFront();

                const cursor = resizer.style('cursor');
                self.modal(true, `background-color: none; opacity: 0; cursor: ${cursor};`)
                    ._lockCursor(cursor);

                const dragStart = [e.pageX, e.pageY];
                let newPos = [0, 0]; // Delta values of the current mouse position vs. start position
                let newSize = {}; // Object to store newly computed positions in

                const w = d3.select(window)
                    .on("mousemove", e => {
                        e.stopPropagation();
                        e.preventDefault();

                        newPos = [e.pageX - dragStart[0], e.pageY - dragStart[1]];
                        Object.assign(newSize, startDims)

                        for (let i in dirs) { // One iter for straight, two for diag
                            const dv = dirVals[dirs[i]],
                                startPos = startDims[dirs[i]],
                                startSize = startDims[dv.dir];

                            // Calculate the amount the dimension can change to without
                            // violating the set width or height limits of the window.
                            const dimMin = Math.max(0, startPos + startSize - self.min[dv.dir]),
                                dimMax = Math.max(0, startPos + startSize - self.max[dv.dir]);

                            // Calculate the new potential position of the edge from the
                            // original position and the current position of the mouse.
                            const newVal = startPos + (newPos[dv.idx] * dv.mult);

                            // Make sure the edge won't move beyond its limits.
                            if (newVal > startPos) { // Decreasing size (farther from window edge)
                                newSize[dirs[i]] = newVal > dimMin ? dimMin : newVal;
                            }
                            else { // Increasing size (closer to window edge)
                                newSize[dirs[i]] = newVal < dimMax ? dimMax : newVal;
                            }
                        }
                        newSize.width = startDims.parentWidth - (newSize.right + newSize.left);
                        newSize.height = startDims.parentHeight - (newSize.top + newSize.bottom);

                        self._setPos(newSize);
                    })
                    .on("mouseup", () => {
                        w.on("mousemove", null).on("mouseup", null);
                        self.modal(false);
                        self._lockCursor(null);
                    });

            });
        }
    }
}

function wintest() {
    const content = '<p style="margin: 10px; padding: 10px; border: 25px solid red; ">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed justo mauris, porttitor sed nibh non, interdum aliquet tellus. Duis eget est lectus. In ultrices finibus semper. Nullam dictum, tortor non placerat convallis, nibh diam sagittis risus, non ultricies diam nisi nec neque. Phasellus dapibus convallis metus. Proin cursus, metus quis ullamcorper suscipit, neque mauris dictum ex, a mattis velit lorem ac erat. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Praesent a ligula ut arcu rutrum venenatis. Morbi nec sapien turpis. Nunc tincidunt maximus venenatis. Phasellus facilisis imperdiet velit, nec cursus elit tincidunt pretium. Duis ligula metus, rutrum nec ullamcorper a, pretium eu massa. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam condimentum, urna in congue dignissim, mi risus maximus lectus, interdum cursus neque turpis sed libero. Cras iaculis ornare accumsan. Sed tempor pretium est, eget aliquam purus feugiat ac.</p>';
    myWin = new Window();
    myWin.setList({ width: '300px', height: '300px', title: 'This is a very, very, very, very long title indeed', top: '100px', left: '10px' });
    myWin.show();
    myWin.body.html(content);
    myWin.sizeToContent();

    myWin2 = new WindowDraggable();
    myWin2.setList({ width: '300px', height: '300px', title: 'Draggable Window', top: '100px', left: '350px' });
    myWin2.show();
    myWin2.body.html(content);
    myWin2.sizeToContent();

    myWin3 = new WindowResizable(null, null, { maxWidth: 500, maxHeight: 1000 });
    myWin3.theme('value-info');
    myWin3.setList({ width: '300px', height: '300px', title: 'Resizable Window', top: '100px', left: '700px' });
    myWin3.show();
    myWin3.body.html(content);
    myWin3.sizeToContent();

}


/**
 * Manage info for each node metadata property
 * @typedef InfoPropDefault
 * @property {String} key The identifier of the property.
 * @property {String} desc The description (label) to display.
 * @property {Boolean} [ capitalize = false ] Whether to capitialize every word in the desc.
 */
class InfoPropDefault {
    constructor(key, desc, capitalize = false) {
        this.key = key;
        this.desc = desc;
        this.capitalize = capitalize;
    }

    /** Return the same message since this is the base class. */
    output(msg) { return msg; }

    /** Make sure the node has the property and it's got a value. */
    canShow(node) { return (node.propExists(this.key) && String(node[this.key]) != '') }

    /**
     * Add a table row with the supplied description and value.
     * @param {Object} tbody D3 reference to an existing table body.
     * @param {String} desc Description of the value.
     * @param {String} val The text or html value to display.
     * @param {Boolean} [ capitalize = false ] Whether to apply the caps class.
     */
    static addRowWithVal(tbody, desc, val, capitalize = false) {
        const newRow = tbody.append('tr');

        newRow.append('th')
            .attr('scope', 'row')
            .text(desc);

        const td = newRow.append('td').html(val);
        if (capitalize) td.attr('class', 'caps');
    }

    /**
     * If the object contains a non-empty property with our key, create
     * a new row with it in the supplied table body.
     * @param {Object} tbody D3 reference to an existing table body.
     * @param {TreeNode} node Reference to the node that may have the property.
     */
    addRow(tbody, node) {
        if (this.canShow(node)) {
            InfoPropDefault.addRowWithVal(tbody, this.desc,
                this.output(node[this.key]), this.capitalize)
        }
    }

    /**
     * Convert an element to a string that is human readable.
     * @param {Object} element The scalar item to convert.
     * @returns {String} The string representation of the element.
     */
     static elementToString(element) {
        if (typeof element === 'number') {
            if (Number.isInteger(element)) { return element.toString(); }
            return this.floatFormatter(element); /* float */
        }

        if (element === 'nan') { return element; }
        return JSON.stringify(element);
    }

    /**
     * Convert a value to a string that is human readable.
     * @param {Object} val The item to convert.
     * @param {Number} level The level of nesting in the display.
     * @returns {String} The string version of the converted array.
     */
    static valToString(val, level = 0) {
        if (!Array.isArray(val)) { return this.elementToString(val); }

        let indent = ' '.repeat(level);
        let valStr = indent + '[';

        for (const element of val) {
            valStr += this.valToString(element, level + 1) + ' ';
        }

        return valStr.replace(/^(.+) $/, '$1]\n');
    }

    /**
     * Convert a value to a string that can be used in Python code.
     * @param {Object} val The value to convert.
     * @returns {String} The string of the converted object.
     */
     static valToCopyString(val) {
        if (!Array.isArray(val)) { return this.elementToString(val); }

        let valStr = 'array([';
        for (const element of val) {
            valStr += this.valToCopyString(element) + ', ';
        }

        if (val.length > 0) {
            return valStr.replace(/^(.+)(, )$/, '$1])');
        }
    }
}
/**
 * Output a human-readable number.
 * @typedef InfoPropNumber
 */
class InfoPropNumber extends InfoPropDefault {
    constructor(key, desc) {
        super(key, desc, false);
    }

    /** Truncate a possible float to something readable. */
    output(val) { return InfoPropDefault.valToString(val); }
}

/**
 * Output a Yes or No to display.
 * @typedef InfoPropYesNo
 */
class InfoPropYesNo extends InfoPropDefault {
    constructor(key, desc, showIfFalse = false) {
        super(key, desc, false);
        this.showIfFalse = showIfFalse;
    }

    /** Return Yes or No when given True or False */
    output(boolVal) { return boolVal ? 'Yes' : 'No'; }

    /** Determine whether the value represents False */
    isFalse(node) {
        const val = node[this.key];
        if (!val) return true;
        return (val.toString().match(/0|no|false|off/i));
    }

    /** Also check the showIfFalse flag */
    canShow(node) {
        const valIsFalse = this.isFalse(node);
        const showAble = (!valIsFalse || (valIsFalse && this.showIfFalse));
        return (super.canShow(node) && showAble);
    }
}

/**
 * Output a message if the value is True.
 * @typedef InfoPropMessage
 */
class InfoPropMessage extends InfoPropYesNo {
    constructor(key, desc, message, showIfFalse = false) {
        super(key, desc, false);
        this.message = message;
    }

    /** Return message when value is True */
    output(boolVal) {
        return boolVal ? this.message : '';
    }
}

/** Display a subsection of expression values in the info panel for ExecComps */
class InfoPropExpr extends InfoPropDefault {
    constructor(key, desc) {
        super(key, desc, false);
    }

    /**
     * There may be a list of expressions, so create a subsection in the table for them.
     * @param {Object} tbody D3 reference to an existing table body.
     * @param {TreeNode} node Reference to the node that may have the property.
     */
    addRow(tbody, node) {
        if (!this.canShow(node)) return;

        const exprArr = node[this.key];

        // Add a subsection header for the option rows to follow
        tbody.append('tr').append('th')
            .text(this.desc)
            .attr('colspan', '2')
            .attr('class', 'options-header');

        for (const idx in exprArr) {
            const splitExpr = exprArr[idx].split(/\s*=\s*/);

            // In case the equals sign is missing for some reason:
            const displayVal = (splitExpr.length > 1)? splitExpr : [ 'Expr ' + idx, splitExpr[0]];
            InfoPropDefault.addRowWithVal(tbody, displayVal[0], displayVal[1]);
        }
    }
}

/**
 * Handles properties that are arrays.
 * @typedef InfoPropArray
 */
class InfoPropArray extends InfoPropDefault {
    constructor(key, desc, values, capitalize = false) {
        super(key, desc, capitalize);

        this.values = values;
    }

    addRow(tbody, node) {
        if (this.canShow(node)) {
            InfoPropDefault.addRowWithVal(tbody, this.desc,
                this.output(node[this.key], node))
        }
    }

    /**
     * Convert the array to a string that can be displayed in the info panel. Save
     * the array value, the string, and a Python version of the string in the
     * values Object so it can be copied if the panel is pinned.
     * @param {Array} array The array to display and save.
     * @returns {String} A string representation of the array.
     */
    output(array, node) {
        if (array == null) { return 'Value too large to include in diagram'; }

        const valStr = InfoPropDefault.valToString(array);
        const maxLen = ValueInfo.TRUNCATE_LIMIT;
        const isTruncated = valStr.length > maxLen;

        let html = isTruncated ? valStr.substring(0, maxLen - 3) + "..." : valStr;

        if (isTruncated && ValueInfo.canDisplay(array)) {
            html += ` <button type='button' class='show_value_button' id='${this.key}'>Show more</button>`;
        }
        html += ` <button type='button' class='copy_value_button' id='${this.key}'>Copy</button>`;

        // Store the original value and formatted value so they can be passed if the panel is pinned.
        this.values[this.key] = {
            'val': array,
            'min': node.val_min,
            'min_idx': node.val_min_indices,
            'max': node.val_max,
            'max_idx': node.val_max_indices,
            'str': valStr,
            'copyStr': InfoPropDefault.valToCopyString(array),
            'isTruncated': isTruncated
        }

        return html;
    }

    /** Make sure the node has the property and it's got a value. */
    canShow(node) { return node.propExists(this.key); }
}

/** Display connections associated with a node */
class InfoPropConns extends InfoPropDefault {
    constructor(key, desc) {
        super(key, desc, false);
    }

    addRow(tbody, node) {
        tbody.append('tr').append('th').attr('colspan', '3')
            .attr('class', 'options-header')
            .text(this.desc);

            /*
        // TODO: Add children
        for (const conn of node.connTargets) {
            const newRow = tbody.append('tr');

            newRow.append('td')
                .attr('scope', 'row')
                .text(node.path);

            newRow.append('td').text(' --> ');
    
            newRow.append('td').text(conn);
        }

        for (const conn of node.connSources) {
            const newRow = tbody.append('tr');
    
            newRow.append('td').text(conn);

            newRow.append('td').text(' --> ');

            newRow.append('td')
                .attr('scope', 'row')
                .text(node.path);
        } */
    }
}

InfoPropDefault.floatFormatter = d3.format('g');



/**
 * Manage a window for displaying the value of a variable.
 * @typedef ValueInfo
 */
class ValueInfo extends WindowResizable {

    /**
     * Add a new value window if it doesn't already exist.
     * @param {String} name Variable name.
     * @param {Number} val Variable value.
     * @param {PersistentNodeInfo} pnInfo The PersistentNodeInfo window to get data from.
     * @returns {ValueInfo} The newly constructed window.
     */
    static add(name, val, min, max, pnInfo) {
        if (!ValueInfo.existingValueWindows[name]) {
            ValueInfo.existingValueWindows[name] = true;
            return new ValueInfo(name, val, min, max, pnInfo);
        }
    }

    /** Remove the name of the window from the list of existing ones. */
    static del(name) {
        if (ValueInfo.existingValueWindows[name]) {
            delete ValueInfo.existingValueWindows[name];
        }
    }

    /**
     * Build a list of the properties we care about and set up
     * references to the HTML elements.
     * @param {String} name Variable name.
     * @param {Number} val Variable value.
     * @param {Number} min Min variable value.
     * @param {Number} val Max variable value.
     * @param {PersistentNodeInfo} pnInfo The PersistentNodeInfo window to get data from.
     */
    constructor(name, val, min, max, pnInfo) {
        super('valueInfo-' + uuidv4());
        this.name = name;
        this.val = val;
        this.val_min = min;
        this.val_max = max;
        this.val_range = max - min;
        this.val_mid = this.val_range / 2;

        this.table = this.body.append('table');
        this.tbody = this.table.append('tbody');

        this.minWidth = 180;
        this.minHeight = 100;
        this.theme('value-info').populate(pnInfo);
    }

    /**
     * Based on the number of dimensions of the value,
     * indicate whether a value window display is needed or even practical
     * @param {Object} val int, float, list,... The variable value.
     * @returns {String} The converted array.
     */
    static canDisplay(val) {
        if (!val) return false; // if no value, cannot display

        if (!Array.isArray(val)) return false; // scalars don't need separate display

        // 1-D arrays can be displayed
        if (!Array.isArray(val[0])) return true;

        // Handle 2-D array
        if (!Array.isArray(val[0][0])) return true;

        // More than 2-D array - punt for now - no practical way to display
        return false;
    }

    /**
     * Fill the table with the data from our val array and display in a window.
     */
    populate(pnInfo) {
        // Check to see if the data is a 2d array since the rest of the code assumes
        // that it is an Array. If only 1d, make it a 2d with one row.
        let val = this.val;
        if (!Array.isArray(val[0])) {
            val = [val];
        }

        // Make the top row of the table the indices of the sub-arrays
        const topRow = this.tbody.append('tr');
        topRow.append('th'); // Top left corner spot is empty
        const valIdxArr = Array.from(val[0].keys());

        topRow.selectAll('th.node-value-index')
            .data(valIdxArr)
            .enter()
            .append('th')
            .classed('node-value-index', true)
            .text(function (d) { return d; });

        // Construct the table displaying the variable value
        const rows = this.tbody
            .selectAll('tr.array-row')
            .data(val)
            .enter()
            .append('tr')
            .attr('class', 'array-row');

        // Insert the array index into the first column:
        rows.append('th').text(function (d, i) { return i; });

        // Add the contents of the array:
        const self = this;
        rows.selectAll('td')
            .data(function (row) { return row; })
            .enter()
            .append('td')
            .attr('style', d => {
                // Since several CSS elements need to be computed at once,
                // use the style attr instead of setting a single style.
                let style = 'border: '
                if ( d == self.val_min) style += '3px dashed #ff00ff; font-weight: bold';
                else if ( d == self.val_max) style += '3px dashed yellow; font-weight: bold';
                else style += 'none'

                style += '; background-color: rgb(';
                let percent = (d - self.val_min) / self.val_range;
                let color = 'black';
                if ( percent < 0.5 ) {
                    const whiteness = 255 * percent * 2;
                    style += `${whiteness},${whiteness},255`;
                    if ( percent < 0.25 ) color = 'white';
                }
                else {
                    if ( percent > 0.75 ) color = 'white';
                    percent = (percent - 0.5) * 2;
                    const whiteness = 255 * (1 - percent);
                    style += `255,${whiteness},${whiteness}`;
                }

                style += `); color: ${color};`;

                return style;
            })
            .text(function (d) { return InfoPropDefault.floatFormatter(d); });

        const pnInfoPos = pnInfo._getPos();
        this.sizeToContent(17, 17) // TODO: Properly find size of scrollbar + 2
            .title(this.name)
            .move(pnInfoPos.left + 20, pnInfoPos.top + 20)
            .show();

        // Save the width and height of the table when it is fully
        // constructed. This will be used later to limit the resizing
        // of the window. No need to let the user resize to a size
        // larger than full size
        const pos = this._getPos();
        this.maxWidth = pos.width;
        this.maxHeight = pos.height;
        if (this.minHeight > pos.height) this.minHeight = pos.height;
    }

    /** Remove our name from the list of existing windows before closing. */
    close(e) {
        ValueInfo.del(this.name);
        super.close(e);
    }
}

// "Class" variable and function for ValueInfo
ValueInfo.TRUNCATE_LIMIT = 80;
ValueInfo.existingValueWindows = {};


/**
 * Manage a table containing all available metadata properties for
 * the currently active node, as well as whether the table is
 * visible or not.
 * @typedef NodeInfo
 */
class NodeInfo extends Window {
    /**
     * Build a list of the properties we care about and set up
     * references to the HTML elements.
     * @param {UserInterface} ui Reference to the diagram's UserInterface object.
     * @param {Boolean} [addDefaultProps = true] Whether to add default properties to be shown.
     */
    constructor(ui, addDefaultProps = true) {
        super('nodeInfo-' + uuidv4());
        this.values = {};
    
        this.ui = ui;
        this.table = this.body.append('table').attr('class', 'node-info-table');
        this.tbody = this.table.append('tbody');
        this.dataDiv = this.main.append('div').attr('class', 'node-info-data');
        this.theme('node-info');
        this.hideCloseButton();

        // Potential properties
        if (addDefaultProps) {
            this.propList = [
                new InfoPropDefault('path', 'Absolute Name'),
                new InfoPropDefault('class', 'Class'),
                new InfoPropDefault('type', 'Type', true),
                new InfoPropArray('val', 'Val', this.values),
            ];
        }
        else {
            this.propList = null;
        }

        // Becomes active when node info mode is selected on toolbar
        this.active = false;
    }

    /** Make the info box visible if it's hidden */
    activate() {
        this.active = true;
        this.hidden = false;
        return this;
    }

    /** Make the info box hidden if it's visible */
    deactivate() {
        this.clear();
        this.active = false;
        this.hidden = true;
        return this;
    }

    /** Toggle the active mode */
    toggle() {
        if (this.active) return this.deactivate();

        return this.activate();
    }

    /** Create a new persistent window by copying our contents */
    pin() {
        if (this.tbody.html() == '') return; // Was already pinned so is empty

        new PersistentNodeInfo(this);
        this.hidden = true;
        this.clear();
        return this;
    }

    /** Place the window near the mouse in a semi-intelligent manner */
    moveNearMouse(event, offset = 15) {
        if (!this.active) return this;

        return super.moveNearMouse(event, offset);
    }

    /** Wipe the contents of the table body */
    clear() {
        if (!this.active) return;
        // this.hidden = true;

        this.setList({
            width: null, height: null, left: null, right: null,
            top: null, bottom: null
        })
        this.dataDiv.html('');
        this.tbody.html('');

        // Don't just replace with {} because some InfoProps rely
        // on the reference to this.values:
        // wipeObj(this.values);
        return this;
    }

    /**
     * Iterate over the list of known properties and display them
     * if the specified object contains them.
     * @param {Object} event The related event so we can get position.
     * @param {TreeNode} node The node to examine.
     * @param {String} color Match the color of the node for the header/footer.
     */
    update(event, node, color) {
        if (!this.active) return;

        this.clear();

        this.name = node.path;
        this.ribbonColor(color);

        if (DebugFlags.info && node.hasChildren()) {
            InfoPropDefault.addRowWithVal(this.tbody, 'Children', node.children.length);
            InfoPropDefault.addRowWithVal(this.tbody, 'Descendants', node.numDescendants);
            InfoPropDefault.addRowWithVal(this.tbody, 'Leaves', node.draw.numLeaves);
            InfoPropDefault.addRowWithVal(this.tbody, 'Manually Expanded', node.draw.manuallyExpanded.toString());
        }

        for (const prop of this.propList) { prop.addRow(this.tbody, node); }

        this.sizeToContent()
            .title(node.name)
            .moveNearMouse(event)
            .show();
    }
}

/**
 * Make a persistent copy of the NodeInfo panel and handle its drag/close events
 * @typedef PersistentNodeInfo
 */
class PersistentNodeInfo extends WindowResizable {
    constructor(nodeInfo, startHeight = 0) {
        super('persistentNodeInfo-' + uuidv4(), '#' + nodeInfo.window.attr('id'));

        // Avoid just copying the reference because nodeInfo.values will be wiped:
        this.values = JSON.parse(JSON.stringify(nodeInfo.values));
        this.ui = nodeInfo.ui;

        this._setupShowMoreButtons(nodeInfo.name)
            ._setupCopyButtons()
            .showCloseButton()
            .show();

        this.tooltipBox = d3.select(".tool-tip");
        this.closeButton
            .on("mouseover", this.mouseOver.bind(this))
            .on("mouseleave", this.mouseLeave.bind(this))
            .on("mousemove", this.mouseMove.bind(this));

        if (startHeight > 0) {
            const pos = this._getPos();
            if (pos.height > startHeight) {
                pos.height = startHeight;
                this._setPos(pos)
                this.body.classed('scrollable', true);
                const tableHeight = parseInt(this.body.select('table.node-info-table').style('height'));
                const extraHeight = pos.height - parseInt(this.body.style('height'));
                this.maxHeight = tableHeight + extraHeight;
            }
            else {
                this.maxHeight = pos.height;
            }
        }
    }

    /** When the mouse enters the element, show the tool tip */
    mouseOver() {
        this.tooltipBox
            .text('Shift-click to close all.')
            .style("visibility", "visible");
    }

    /** When the mouse leaves the element, hide the tool tip */
    mouseLeave() {
        this.tooltipBox.style("visibility", "hidden");
    }

    /** Keep the tool-tip near the mouse */
    mouseMove(e) {
        this.tooltipBox.style("top", (e.pageY - 30) + "px")
            .style("left", (e.pageX + 5) + "px");
    }

    /** Set up event handlers for any "Show More" buttons in the panel */
    _setupShowMoreButtons(name) {
        const self = this;

        for (const valName in this.values) {
            if (this.values[valName].isTruncated) {
                this.window
                    .select(`button#${valName}.show_value_button`)
                    .on('click', c => {
                        const values = self.values[valName];
                        ValueInfo.add(name, values.val, values.min, values.max, self);
                    })
            }
        }

        return this;
    }

    /** Set up event handlers for any "Copy" buttons in the panel */
    _setupCopyButtons() {
        for (const valName in this.values) {
            this.window
                .select(`button#${valName}.copy_value_button`)
                .on('click', c => {
                    const copyText = d3.select("#input-for-pastebuffer");
                    copyText.text(this.values[valName].copyStr);
                    copyText.node().select();
                    document.execCommand('copy');
                })
        }

        return this;
    }

    /** Override so that shift-click closes all PersistentNodeInfo windows. */
    close(e) {
        this.tooltipBox.style("visibility", "hidden");
        window.getSelection().empty(); // Shift-clicking also selects text, so unselect it

        if (e.shiftKey) {
            const allPNIWin = d3.selectAll('[id^="persistentNodeInfo-"]');

            allPNIWin.select('.window-close-button')
                .on('click', null)
                .on("mouseover", null)
                .on("mouseleave", null)
                .on("mousemove", null);
            allPNIWin.remove();
        }
        else {
            this.closeButton
                .on("mouseover", null)
                .on("mouseleave", null)
                .on("mousemove", null);
            super.close(e);
        }
    }
}

/**
 * Display all connections represented by the current off-diagonal cell.
 * @typedef NodeConnectionInfo
 */
class NodeConnectionInfo extends NodeInfo {
    /**
     * Build a list of the properties we care about and set up
     * references to the HTML elements.
     */
    constructor(ui) {
        super(ui, false);
        this.propList = [];
    }

    /**
     * Find the best label for a connected node.
     * @param {TreeNode} node The node to determine a name for.
     * @returns The promoted name if it has one, otherwise the absolute path.
     */
    nodeName(node) {
        let name = node.path;
        if (node.path != node.promotedName) name += `<br><i>(${node.promotedName}</i>)`;
        return name;
    }

    /**
     * Gather all connections between the two cells that this one represents.
     * @param {Array} connList The connections discovered so far.
     * @param {TreeNode} srcNode The source node to search.
     * @param {TreeNode} tgtNode The target node to search.
     */
    _getConnections(connList, srcNode, tgtNode) {
        if (srcNode.hasChildren()) {
            for (const child of srcNode.children) {
                this._getConnections(connList, child, tgtNode)
            }
        }
        else {
            if (srcNode.parent === tgtNode.parent) {
                const newConn = { 'src': this.nodeName(srcNode), 'tgt': this.nodeName(tgtNode) };
                connList.push(newConn);
            }
            for (const tgt of srcNode.targetParentSet) {
                if (tgt.isLeaf() && tgt.hasParent(tgtNode, null, true)) {
                    const newConn = { 'src': this.nodeName(srcNode), 'tgt': this.nodeName(tgt) };
                    connList.push(newConn);
                }
            }
        }
    }

    /**
     * Create a new persistent window by copying our contents. Set the
     * max initial height of the window at 300px.
     */
    pin() {
        if (this.tbody.html() == '') return; // Was already pinned so is empty

        new PersistentNodeInfo(this, 300);
        this.hidden = true;
        this.clear();
        return this;
    }

    /**
     * Load the NodeInfo window with connection information for an off-diagonal cell.
     * @param {Object} event Reference to the event that triggered the function.
     * @param {MatrixCell} cell Reference to the cell that was hovered.
     * @param {String} color The color of the title bar.
     */
    update(event, cell, color) {
        if (!this.active) return;
        this.clear();

        this.name = cell.id;
        this.ribbonColor(color);

        const connList = [];
        this._getConnections(connList, cell.srcObj, cell.tgtObj);
        for (const conn of connList) {
            const newRow = this.tbody.append('tr');

            newRow.append('td')
                .attr('scope', 'row')
                .html(conn.src);

            newRow.append('td').html(' &#x2501;&#x2501;&#x2501;&#x25ba; ');
            newRow.append('td').html(conn.tgt);
        }

        let title = 'Connections';
        if ( ! (cell.srcObj.isLeaf() || cell.tgtObj.isLeaf()) ) {
            title += ` from ${cell.srcObj.path} to ${cell.tgtObj.path}`;
        }

        this.title(title)
            .sizeToContent(0, 2, true)
            .moveNearMouse(event)
            .show();
    }
}



/**
 * Draw a symbol describing each of the element types.
 * @typedef Legend
 * @property {Boolean} shown Whether the legend is currently drawn or not.
 */
class Legend extends WindowDraggable {
    /**
     * Initializes the legend object.
     * @param {ModelData} modelData Symbols are only displayed if they're in the model
     */
    constructor(modelData) {
        super('n2win-legend');

        // TODO: The legend should't have to search through modelData itself,
        // this info can be collected as modelData is built.
        this.nodes = modelData.tree.children;
        this._initItemTypes();

        this.n2Symbols = [];

        const legendDiv = d3.select('#legend-div');
        legendDiv.style('visibility', null);
        this.body.node().appendChild(legendDiv.node());
        this._setDisplayBooleans(this.nodes);

        this.title('<span class="icon-key"></span>');
        this._setupContents();

        this.theme('legend');
        this.sizeToContent();
        this.move(50, -10);
    }

    /**
     * Set the types to check for in the model to determine if they
     * need to be displayed in the legend.
     */
    _initItemTypes() {
        this.showSysVar = {
            'group': false,
            'input': false,
            'unconnectedInput': false,
            'output': false,
            'collapsed': true,
            'connection': true
        };

        this.showSymbols = {
            'scalar': false,
            'vector': false,
            'collapsedVariables': false
        };

        this.sysAndVar = [
            { 'name': "Connection", 'color': Style.color.connection },
            { 'name': "Collapsed", 'color': Style.color.collapsed },
        ];
    }

    /** Override Window::close() to just hide the legend. */
    close() {
        d3.select('#legend-button').attr('class', 'fas icon-key');
        this.hide();
        return this;
    }

    /**
     * Determine which types of nodes are present in the model and only mark
     * those types of keys to be displayed in the legend.
     * @param {Object} nodes The model node tree.
     */
    _setDisplayBooleans(nodes) {
        for (const node of nodes) {
            const {
                group,
                input,
                unconnectedInput,
                output,
                collapsed,
                connection
            } = this.showSysVar;

            if (node.hasChildren()) {
                if (!this.showSysVar.group && node.isGroup()) {
                    this.showSysVar.group = true;
                    this.sysAndVar.push({
                        'name': 'Group',
                        'color': Style.color.group
                    })
                }
                this._setDisplayBooleans(node.children);
            }
            else {
                if (!this.showSysVar.input && node.isInput()) {
                    this.showSysVar.input = true;
                    this.sysAndVar.push({
                        'name': 'Input',
                        'color': Style.color.input
                    })
                }
                else if (!this.showSysVar.output && node.isOutput()) {
                    this.showSysVar.output = true;
                    this.sysAndVar.push({
                        'name': 'Output',
                        'color': Style.color.output
                    })
                }
                else if (!this.showSysVar.unconnectedInput && node.isUnconnectedInput()) {
                    this.showSysVar.unconnectedInput = true;
                    this.sysAndVar.push({
                        'name': 'Unconnected Input',
                        'color': Style.color.unconnectedInput
                    })
                }
            }
        }
    }

    /**
     * Create elements in the legend divs for the supplied item
     * @param {Object} item Contains the name and color of the item
     * @param {Object} container The div to append into
     */
    _addItem(item, container, cssClass = '') {
        const newDiv = container
            .append('div')
            .attr('class', 'legend-box-container');

        newDiv.append('div')
            .attr('class', `legend-box ${cssClass}`)
            .style('background-color', item.color);

        newDiv.append('p')
            .html(item.name);
    }

    /** Add symbols for all of the items that were discovered */
    _setupContents() {
        const sysVarContainer = d3.select('#sys-var-legend');
        for (let item of this.sysAndVar) this._addItem(item, sysVarContainer);

        sysVarContainer.style('width', sysVarContainer.node().scrollWidth + 'px')
    }
}


/**
 * Handle input events for the matrix and toolbar.
 * @typedef UserInterface
 * @property {Diagram} diag Reference to the main diagram.
 * @property {TreeNode} leftClickedNode The last node that was left-clicked.
 * @property {TreeNode} rightClickedNode The last node that was right-clicked, if any.
 * @property {Boolean} lastClickWasLeft True is last mouse click was left, false if right.
 * @property {Boolean} leftClickIsForward True if the last node clicked has a greater depth
 *  than the current zoomed element.
 * @property {Array} backButtonHistory The stack of forward-navigation zoomed elements.
 * @property {Array} forwardButtonHistory The stack of backward-navigation zoomed elements.
 */

class UserInterface {
    /**
     * Initialize properties, set up the collapse-depth menu, and set up other
     * elements of the toolbar.
     * @param {Diagram} diag A reference to the main diagram.
     */
    constructor(diag) {
        this.diag = diag;

        this.leftClickedNode = document.getElementById('diagram-content');
        this.rightClickedNode = null;
        this.lastClickWasLeft = true;
        this.leftClickIsForward = true;
        this.findRootOfChangeFunction = null;
        this.callSearchFromEnterKeyPressed = false;
        this.nodeInfoBox = null;

        this.backButtonHistory = [];
        this.forwardButtonHistory = [];

        this._init();
        this._setupCollapseDepthSlider();
        this.updateClickedIndices();
        this._setupSearch();
        this._setupResizerDrag();
        this._setupWindowResizer();
        this.click = new ClickHandler();


        // Add listener for reading in a saved view.
        const self = this;
        d3.select('#state-file-input').on('change', function(e) { self.loadView(e, self); });
    }

    /**
     * Separate these calls from the constructor so that subclasses can
     * set values before execution.
     */
    _init() {
        this.legend = new Legend(this.diag.modelData);
        this.toolbar = new Toolbar(this);
    }

    /**
     * Create a new node info window.
     * @param {Selection} svgNodeGroup Placeholder for subclasses.
     */
    _newInfoBox(svgNodeGroup) { 
        this.nodeInfoBox = new NodeInfo(this);
    }

    /**
     * Create a new node connection info window.
     * @param {Selection} svgNodeGroup Placeholder for subclasses.
     */
    _newConnInfoBox(svgNodeGroup) { 
        this.nodeInfoBox = new NodeConnectionInfo(this);
    }

    /**
     * If node info mode is active, create a new node info window, populate, and display it.
     * @param {Event} event The Event object created by the trigger.
     * @param {TreeNode} node The node associated with the HTML object.
     * @param {String} [color = null] The color of the titlebard. Autoselected if null.
     * @param {Boolean} [isConnection = false] If true, make a connection info window.
     */
    showInfoBox(event, node, color = null, isConnection = false) {
        if (this.click.isNodeInfo) {
            const svgNodeGroup = d3.select(event.currentTarget);
            if (!color) color = svgNodeGroup.select('rect').style('fill');

            if (isConnection) {
                this._newConnInfoBox(svgNodeGroup)
            }
            else this._newInfoBox(svgNodeGroup);

            this.nodeInfoBox.activate();
            this.click.update(this.nodeInfoBox);
            this.nodeInfoBox.update(event, node, color);
        }
    }

    showCellInfoBox(event, cell, color = null) {
        if (this.click.isNodeInfo) {
            const svgNodeGroup = d3.select(event.currentTarget);
            if (!color) color = svgNodeGroup.select('rect').style('fill');

            this._newConnInfoBox(svgNodeGroup);
            this.nodeInfoBox.activate();
            this.click.update(this.nodeInfoBox);
            this.nodeInfoBox.update(event, cell, color);
        }
    }

    /** Hide and destroy the node info window */
    removeInfoBox() {
        if (this.nodeInfoBox) {
            this.nodeInfoBox.clear();
            delete this.nodeInfoBox;
            this.nodeInfoBox = null;
        }
    }

    /** Move the node info window near the mouse if node info mode is active */
    moveInfoBox(e) {
        if (this.nodeInfoBox) { this.nodeInfoBox.moveNearMouse(e); }        
    }

    /** Create a persistent node info window if node info mode is active */
    pinInfoBox() {
        if (this.nodeInfoBox) { this.nodeInfoBox.pin(); }
    }

    /**
     * Set the range and current value of the collapse depth slider.
     * @param {Number} opts.min The shallowest elements to allow to collapse via slider.
     * @param {Number} opts.max The deepest elements to allow to collapse via slider.
     * @param {Number} opts.val The current slider collapse depth value.
     */
    setCollapseDepthSlider(opts = {}) {
        const min = opts.min ? opts.min : 2;
        const max = opts.max ? opts.max : this.diag.model.maxDepth;
        const val = opts.val ? opts.val : max;

        this.collapseDepthSlider
            .property('min', min)
            .property('max', max)
            .property('value', val);

        this.collapseDepthLabel.text(val);
    }

    get collapseDepthSliderVal() { return Number(this.collapseDepthSlider.property('value')); }

    /** Set up the menu for selecting an arbitrary depth to collapse to. */
    _setupCollapseDepthSlider() {
        const self = this;

        this.collapseDepthSlider = d3.select('input#depth-slider');
        this.collapseDepthLabel = d3.select('p#depth-slider-label');

        this.setCollapseDepthSlider();

        this.collapseDepthSlider
            .on('mouseup', e => {
                const val = self.collapseDepthSlider.property('value');
                self.collapseToDepth(val);
            })
            .on('input', e => {
                self.collapseDepthLabel.text(self.collapseDepthSliderVal);
            });
    }

    /** Determine the style of the inactive handle (override with subclass) */
    _inactiveResizerHandlerStyle() {
        return 'inactive-resizer-handle';
    }

    /** Set up event handlers for grabbing the bottom corner and dragging */
    _setupResizerDrag() {
        const handle = d3.select('#n2-resizer-handle');
        const box = d3.select('#n2-resizer-box');
        const body = d3.select('body');
        const self = this;

        handle.on('mousedown', e => {
            box
                .style('top', self.diag.layout.gapSpace)
                .style('bottom', self.diag.layout.gapSpace);

            handle.attr('class', 'active-resizer-handle');
            box.attr('class', 'active-resizer-box');

            const startPos = new Dimensions({ x: e.clientX, y: e.clientY });
            const startDims = new Dimensions({
                width: parseInt(box.style('width')),
                height: parseInt(box.style('height'))
            });
            const offset = new Dimensions({
                x: startPos.x - startDims.width,
                y: startPos.y - startDims.height
            });

            // Reassigned by mousemove:
            let newDims = new Dimensions({
                x: startDims.width,
                y: startDims.height
            });

            handle.html(Math.round(newDims.x) + ' x ' + newDims.y);

            body.style('cursor', 'nwse-resize')
                .on('mouseup', () => {
                    self.diag.manuallyResized = true;

                    // Update the slider value and display
                    const defaultHeight = window.innerHeight * .95;
                    const newPercent = Math.round((newDims.y / defaultHeight) * 100);
                    d3.select('#model-slider').node().value = newPercent;
                    d3.select('#model-slider-label').html(newPercent + "%");

                    // Perform the actual resize
                    self.diag.verticalResize(newDims.y);

                    box.style('width', null).style('height', null);

                    // Turn off the resizing box border and handle
                    handle.attr('class', self._inactiveResizerHandlerStyle())
                    box.attr('class', 'inactive-resizer-box');

                    // Get rid of the drag event handlers
                    body.style('cursor', 'default')
                        .on('mousemove', null)
                        .on('mouseup', null);
                })
                .on('mousemove', e => {
                    const newHeight = e.clientY - offset.y;
                    if (newHeight + self.diag.layout.gapDist * 2 >= window.innerHeight * .5) {
                        newDims = new Dimensions({ x: e.clientX - offset.x, y: newHeight});

                        // Maintain the ratio by only resizing in the least moved direction
                        // and resizing the other direction by a fraction of that
                        if (newDims.x < newDims.y) {
                            newDims.y = self.diag.layout.calcHeightBasedOnNewWidth(newDims.x);
                        }
                        else {
                            newDims.x = self.diag.layout.calcWidthBasedOnNewHeight(newDims.y);
                        }

                        box.style('width', newDims.x + 'px').style('height', newDims.y + 'px');
                        handle.html(Math.round(newDims.x) + ' x ' + newDims.y);
                    }
                });

            e.preventDefault();
        });

    }

    /** Respond to window resize events if the diagram hasn't been manually sized */
    _setupWindowResizer() {
        const self = this;
        const diag = self.diag;
        this.pixelRatio = window.devicePixelRatio;

        self.resizeTimeout = null;
        d3.select(window).on('resize', function () {
            const newPixelRatio = window.devicePixelRatio;

            // If the browser window itself is zoomed, don't do anything
            if (newPixelRatio != self.pixelRatio) {
                self.pixelRatio = newPixelRatio;
                return;
            }

            if (!self.diag.manuallyResized) {
                clearTimeout(self.resizeTimeout);
                self.resizeTimeout =
                    setTimeout(function () {
                        diag.verticalResize(window.innerHeight * .95);
                    }, 200);
            }
        })
    }

    /**
     * Make sure the clicked node is deeper than the zoomed node, that
     * it's not the root node, and that it actually has children.
     * @param {TreeNode} node The right-clicked node to check.
     */
    isCollapsible(node) {
        return (node.depth > this.diag.zoomedElement.depth &&
            node.type !== 'root' && node.hasChildren());
    }

    /**
     * When a node is right-clicked or otherwise targeted for collapse, make sure it
     * it's allowed, then set the node as minimized and update the diagram drawing.
     */
    collapse() {
        const node = this.rightClickedNode;

        if (this.isCollapsible(node)) {

            if (this.collapsedRightClickNode !== undefined) {
                this.rightClickedNode = this.collapsedRightClickNode;
                this.collapsedRightClickNode = undefined;
            }

            this.findRootOfChangeFunction =
                this.findRootOfChangeForRightClick.bind(this);

            transitionDefaults.duration = transitionDefaults.durationFast;
            this.lastClickWasLeft = false;
            node.minimize();
            this.diag.update();
        }
    }

    /**
     * When a node is right-clicked, collapse it if it's allowed.
     * @param {TreeNode} node The node that was right-clicked.
     */
    rightClick(e, node) {
        e.preventDefault();
        e.stopPropagation();

        if (node.draw.minimized) {
            this.rightClickedNode = node;
            this.addBackButtonHistory();
            node.draw.manuallyExpanded = true;
            this._uncollapse(node);
            this.diag.update();
        }
        else if (this.isCollapsible(node)) {
            this.rightClickedNode = node;
            node.collapsable = true;

            this.addBackButtonHistory();
            node.draw.manuallyExpanded = false;
            this.collapse();
        }
    }

    /**
     * When a node with variables is alt-right-clicked, present a dialog with the
     * list of variables and allow the user to select which ones should be displayed.
     * @param {TreeNode} node The node that was alt-right-clicked.
     * @param {String} color The color of the clicked node, to use for the dialog ribbons.
     */
    altRightClick(e, node, color) {
        e.preventDefault();
        e.stopPropagation();
        window.getSelection().empty();

        // Make sure node is collapsible and window doesn't exist yet.
        if (this.isCollapsible(node) && !node.isFilter() && 
            d3.select('#childSelect-' + node.toId()).empty()) {
            new ChildSelectDialog(e, node, color, this.diag); // Create the modal dialog
        }
    }

    /**
     * Update states as if a left-click was performed, which may or may not have
     * actually happened.
     * @param {TreeNode} node The node that was targetted.
     */
    _setupLeftClick(node) {
        this.leftClickedNode = node;
        this.lastClickWasLeft = true;
        if (this.leftClickedNode.depth > this.diag.zoomedElement.depth) {
            this.leftClickIsForward = true; // forward
        }
        else if (this.leftClickedNode.depth < this.diag.zoomedElement.depth) {
            this.leftClickIsForward = false; // backwards
        }
        this.diag.updateZoomedElement(node);
        transitionDefaults.duration = transitionDefaults.durationFast;
    }

    /**
     * React to a left-clicked node by zooming in on it.
     * @param {TreeNode} node The targetted node.
     */
    leftClick(e, node) {
        // Don't do it if the node is already zoomed
        if (node === this.diag.zoomedElement) return;

        e.preventDefault();
        e.stopPropagation();

        if (!node.hasChildren() || node.isInput()) return;
        if (e.button != 0) return;
        this.addBackButtonHistory();
        node.expand();
        node.draw.manuallyExpanded = true;
        this._setupLeftClick(node);

        this.diag.update();
    }

    /**
     * Set up for an animated transition by setting and remembering where things were.
     */
    updateClickedIndices() {
        enterIndex = exitIndex = 0;

        if (this.lastClickWasLeft) {
            let lcRootIndex = (!this.leftClickedNode || !this.leftClickedNode.rootIndex) ? 0 :
                this.leftClickedNode.rootIndex;

            if (this.leftClickIsForward) {
                exitIndex = lcRootIndex - this.diag.zoomedElementPrev.rootIndex;
            }
            else {
                enterIndex = this.diag.zoomedElementPrev.rootIndex - lcRootIndex;
            }
        }
    }

    /**
     * Preserve the current zoomed element and state of all hidden elements.
     * @param {Boolean} clearForward If true, erase the forward history.
     */
    addBackButtonHistory(clearForward = true) {
        let formerHidden = [];
        this.diag.model.findAllHidden(formerHidden, false);

        this.backButtonHistory.push({
            'node': this.diag.zoomedElement,
            'hidden': formerHidden,
            'search': this.toolbar.getSearchState(),
            'collapseDepth': this.currentCollapseDepth
        });

        if (clearForward) this.forwardButtonHistory = [];
    }

    /**
     * Preserve the specified node as the zoomed element,
     * and remember the state of all hidden elements.
     * @param {TreeNode} node The node to preserve as the zoomed element.
     */
    addForwardButtonHistory(node) {
        let formerHidden = [];
        this.diag.model.findAllHidden(formerHidden, true);

        this.forwardButtonHistory.push({
            'node': node,
            'hidden': formerHidden,
            'search': this.toolbar.getSearchState(),
            'collapseDepth': this.currentCollapseDepth
        });
    }

    /**
     * When the back history button is clicked, pop the top node from that
     * history stack, and disable the button if the stack is empty. Find the
     * neared un-minimized node (if not the node itself) and zoom to that.
     * Add the previous zoomed node to the forward history stack.
     */
    backButtonPressed() {
        if (this.backButtonHistory.length == 0) {
            debugInfo("backButtonPressed(): no items in history");
            return;
        }

        debugInfo("backButtonPressed(): " +
            this.backButtonHistory.length + " items in history");

        const history = this.backButtonHistory.pop();
        const oldZoomedElement = history.node;

        this.toolbar.setSearchState(history.search);
        this.setCollapseDepthSlider({ 'val': history.collapseDepth });

        // Check to see if the node is a collapsed node or not
        if (oldZoomedElement.collapsable) {
            this.leftClickedNode = oldZoomedElement;
            this.addForwardButtonHistory(oldZoomedElement);
            this.collapse();
        }
        else {
            for (let obj = oldZoomedElement; obj != null; obj = obj.parent) {
                //make sure history item is not minimized
                if (obj.draw.minimized) return;
            }

            this.addForwardButtonHistory(this.diag.zoomedElement);
            this._setupLeftClick(oldZoomedElement);
        }

        this.diag.model.resetAllHidden(history.hidden);
        this.diag.update();
    }

    /**
     * When the forward history button is clicked, pop the top node from that
     * history stack, and disable the button if the stack is empty. Find the
     * neared un-minimized node (if not the node itself) and zoom to that.
     * Add the previous zoomed node to the back history stack.
     */
    forwardButtonPressed() {
        if (this.forwardButtonHistory.length == 0) {
            debugInfo("forwardButtonPressed(): no items in history");
            return;
        }

        debugInfo("forwardButtonPressed(): " +
            this.forwardButtonHistory.length + " items in history");

        const history = this.forwardButtonHistory.pop();
        const node = history.node;

        this.toolbar.setSearchState(history.search);
        this.setCollapseDepthSlider({ 'val': history.collapseDepth });

        d3.select('#redo-graph').classed('disabled-button',
            (this.forwardButtonHistory.length == 0));

        for (let obj = node; obj != null; obj = obj.parent) {
            // make sure history item is not minimized
            if (obj.draw.minimized) return;
        }

        this.addBackButtonHistory(false);
        this._setupLeftClick(node);

        this.diag.model.resetAllHidden(history.hidden);
        this.diag.update();
    }

    /**
     * When the last event to change the zoom level was a right-click,
     * return the targetted node. Called during drawing/transition.
     * @returns The last right-clicked node.
     */
    findRootOfChangeForRightClick() {
        return this.rightClickedNode;
    }

    /**
     * When the last event to change the zoom level was the selection
     * from the collapse depth menu, return the node with the
     * appropriate depth.
     * @returns The node that has the selected depth if it exists.
     */
    findRootOfChangeForCollapseDepth(node) {
        for (let obj = node; obj != null; obj = obj.parent) {
            //make sure history item is not minimized
            if (obj.depth == this.diag.chosenCollapseDepth) return obj;
        }
        return node;
    }

    /**
     * When either of the collapse or uncollapse toolbar buttons are
     * pressed, return the parent of the targetted node if it's a variable,
     * or the node itself if not.
     * @returns Parent of output node or node itself.
     */
    findRootOfChangeForCollapseUncollapseOutputs(node) {
        return node.isInputOrOutput()? node.parent : node;
    }

    /**
     * When the home button (aka return-to-root) button is clicked, zoom
     * to the root node.
     */
    homeButtonClick() {
        this.leftClickedNode = this.diag.model.root;
        this.lastClickWasLeft = true;
        this.leftClickIsForward = false;
        this.findRootOfChangeFunction = this.findRootOfChangeForCollapseUncollapseOutputs;
        this.addBackButtonHistory();
        this.setCollapseDepthSlider();

        this.diag.reset();
    }

    /**
     * Minimize the specified node and recursively minimize its children.
     * @param {TreeNode} node The current node to operate on.
     */
    _collapseOutputs(node) {
        if (node.isGroup()) node.minimize();

        if (node.hasChildren()) {
            for (const child of node.children) {
                this._collapseOutputs(child);
            }
        }
    }

    /**
     * React to a button click and collapse all outputs of the specified node.
     * @param {TreeNode} node The initial node, usually the currently zoomed element.
     */
    collapseOutputsButtonClick(startNode) {
        this.addBackButtonHistory();
        this.findRootOfChangeFunction = this.findRootOfChangeForCollapseUncollapseOutputs;
        transitionDefaults.duration = transitionDefaults.durationSlow;
        this.lastClickWasLeft = false;
        this._collapseOutputs(startNode);
        this.diag.update();
    }

    /**
     * Mark this node and all of its children as unminimized/unhidden
     * @param {TreeNode} node The node to operate on.
     */
    _uncollapse(node) {
        node.expand().show();
        if (node.isFilteredVariable()) node.draw.filtered = false;

        if (node.hasChildren()) {
            for (const child of node.children) {
                this._uncollapse(child);
            }
        }

        if (node.isFilter()) { node.wipe(); } // Clear the contents if it's a filter node
    }

    /**
     * React to a button click and uncollapse the specified node.
     * @param {TreeNode} startNode The initial node.
     */
    uncollapseButtonClick(startNode) {
        this.addBackButtonHistory();
        this.findRootOfChangeFunction = this.findRootOfChangeForCollapseUncollapseOutputs;
        transitionDefaults.duration = transitionDefaults.durationSlow;
        this.lastClickWasLeft = false;
        this._uncollapse(startNode);
        startNode.draw.manuallyExpanded = true;
        this.diag.update();
    }

    /** Any collapsed nodes are expanded, starting with the specified node. */
    expandAll(startNode) {
        this.diag.showWaiter();

        this.addBackButtonHistory();
        this.diag.model.manuallyExpandAll(startNode);

        this.findRootOfChangeFunction = this.findRootOfChangeForCollapseUncollapseOutputs;
        transitionDefaults.duration = transitionDefaults.durationSlow;
        this.lastClickWasLeft = false;
        this.diag.update();
    }

    /** All nodes are collapsed, starting with the specified node. */
    collapseAll(startNode) {
        this.addBackButtonHistory();
        this.diag.model.minimizeAll(startNode);

        this.findRootOfChangeFunction = this.findRootOfChangeForCollapseUncollapseOutputs;
        transitionDefaults.duration = transitionDefaults.durationSlow;
        this.lastClickWasLeft = false;
        this.diag.update();
    }

    /**
     * React to a new selection in the collapse-to-depth toolbar slider.
     * @param {Number} depth Selected depth to collapse to.
     */
    collapseToDepth(depth) {
        this.addBackButtonHistory();
        this.diag.minimizeToDepth(depth);
        this.findRootOfChangeFunction = this.findRootOfChangeForCollapseDepth.bind(
            this
        );
        transitionDefaults.duration = transitionDefaults.durationSlow;
        this.lastClickWasLeft = false;
        this.diag.update();
    }

    /** React to the toggle legend button, and show or hide the legend. */
    toggleLegend() {
        this.legend.toggle();

        d3.selectAll('i.icon-key').attr('class',
            this.legend.hidden ? 'fas icon-key' : 'fas icon-key active-tab-icon');
    }

    /** Show or hide the node info panel button */
    toggleNodeData() {
        const infoButton = d3.select('#info-button');
        const nodeData = d3.select('#node-info-table');

        if (nodeData.classed('info-hidden')) {
            nodeData.attr('class', 'info-visible');
            infoButton.attr('class', 'fas icon-info-circle active-tab-icon');
        }
        else {
            nodeData.attr('class', 'info-hidden');
            infoButton.attr('class', 'fas icon-info-circle');
        }
    }

    _setupSearch() {
        const self = this; // For callbacks that change "this".

        // Keyup so it will be after the input and awesomplete-selectcomplete event listeners
        window.addEventListener(
            'keyup',
            self.searchEnterKeyUpEventListener.bind(self),
            true
        );

        // Keydown so it will be before the input and awesomplete-selectcomplete event listeners
        window.addEventListener(
            'keydown',
            self.searchEnterKeyDownEventListener.bind(self),
            true
        );
    }

    /** Make sure UI controls reflect history and current reality. */
    update() {
        this.currentCollapseDepth = this.collapseDepthSliderVal;

        d3.select('#undo-graph').classed('disabled-button',
            (this.backButtonHistory.length == 0));
        d3.select('#redo-graph').classed('disabled-button',
            (this.forwardButtonHistory.length == 0));
    }

    /** Called when the search button is actually or effectively clicked to start a search. */
    searchButtonClicked() {
        this.addBackButtonHistory();
        this.diag.search.performSearch();

        this.findRootOfChangeFunction = this.diag.search.findRootOfChangeForSearch;
        transitionDefaults.duration = transitionDefaults.durationSlow;
        this.lastClickWasLeft = false;
        this.diag.search.updateRecomputesAutoComplete = false;
        this.diag.update();
    }

    /**
     * Called when the enter key is pressed down in the search input box.
     * @param {Event} e Object with information about the event.
     */
    searchEnterKeyDownEventListener(e) {

        const target = e.target;
        if (target.id == 'awesompleteId') {
            const key = e.which || e.keyCode;
            if (key == 13) {
                // 13 is enter
                this.callSearchFromEnterKeyPressed = true;
            }
        }
    }

    /**
     * Called when the enter key is released in the search input box.
     * @param {Event} e Object with information about the event.
     */
    searchEnterKeyUpEventListener(e) {
        const target = e.target;
        if (target.id == 'awesompleteId') {
            const key = e.which || e.keyCode;
            if (key == 13) {
                // 13 is enter
                if (this.callSearchFromEnterKeyPressed) {
                    this.searchButtonClicked();
                }
            }
        }
    }

    /**
     * Save the model state to a file.
     * @param {Object} [extraData={}] Additional items to save.
     */
    saveState(extraData = {}) {
        const stateFileName = basename() + '.n2view';

        // Zoomed node
        const zoomedElement = this.diag.zoomedElement.id;

        // Expand/Collapse state of all nodes in model.
        const expandCollapse = Array();
        this.diag.getSubState(expandCollapse);

        // Arrow State
        const arrowState = this.diag.arrowMgr.savePinnedArrows();

        const dataDict = {
            ...extraData,
            'zoomedElement': zoomedElement,
            'expandCollapse': expandCollapse,
            'arrowState': arrowState,
            'md5_hash': this.diag.model.md5_hash,
        };

        const link = document.createElement('a');
        link.setAttribute('download', stateFileName);
        const data_blob = new Blob([JSON.stringify(dataDict)], { type: 'text/plain' });

        // If we are replacing a previously generated file we need to
        // manually revoke the object URL to avoid memory leaks.
        if (stateFileName !== null) {
            window.URL.revokeObjectURL(stateFileName);
        }

        link.href = window.URL.createObjectURL(data_blob);
        document.body.appendChild(link);

        // wait for the link to be added to the document
        window.requestAnimationFrame(function () {
            var event = new MouseEvent('click');
            link.dispatchEvent(event);
            document.body.removeChild(link);
        })
    }

    /**
     * Preset a file open dialog, read in the selected file, validate the contents,
     * and update the diagram to the saved state.
     * @param {Event} e The event that initiated the dialog.
     * @param {UserInterface} ui Reference to the UserInterface object.
     */
    loadView(e, ui) {
        const fr = new FileReader();
        const fileInput = e.currentTarget;

        fr.onload = function () {
            let dataDict = false;

            try {
                dataDict = JSON.parse(fr.result);
            }
            catch (error) {
                alert("Cannot load view. The file does not appear to be a valid view file.");
                return;
            }

            if (!dataDict.md5_hash) {
                alert("Cannot load view. The file does not appear to be a valid view file.");
                return;
            }

            // Make sure model didn't change.
            if (dataDict.md5_hash != ui.diag.model.md5_hash) {
                alert("Cannot load view. Current model structure is different than in saved view.")
                return;
            }

            ui.addBackButtonHistory();
            ui.diag.restoreSavedState(dataDict);
        }

        fr.readAsText(fileInput.files[0]);
    }

    /** Load the model state to a file. */
    loadState() {
        document.getElementById('state-file-input').click();
    }
}

/**
 * Base class for all types of arrows.
 * @typedef Arrow
 * @prop {Number} attribs.start.row Row # of starting node
 * @prop {Number} attribs.start.col Col # of starting ndoe
 * @prop {String} attribs.start.id ID of the start node
 * @prop {Number} attribs.end.row Row # of end node (arrow points to)
 * @prop {Number} attribs.end.col Col # of end node (arrow points to)
 * @prop {String} attribs.end.id ID of the end node
 * @prop {String} color Color of the line/circle (arrowhead is black)
 * @prop {Number} width Width of the arrow path
 * @prop {Number} nodeSize.width Width of a matrix cell in pixels.
 * @prop {Number} nodeSize.height Height of a matrix cell in pixels.
 */
class Arrow {
    /**
     * Determine whether arrow elements already exist, and create them if not.
     * @param {Object} attribs All of the specific arrow properties.
     * @param {Object} diagGroups References to <g> SVG elements.
     * @param {Object} nodeSize The dimensions of each cell in the matrix.
     */
    constructor(attribs, diagGroups, nodeSize) {
        this.color = attribs.color;
        this.width = attribs.width;
        this.nodeSize = nodeSize;
        this.attribs = attribs;
        this._genPath = this._angledPath;

        /*
         * Generate a CSS id for the arrow. This is based on the ids of the
         * TreeNodes it points to rather than the cells, so if it's pinned
         * and the matrix is redrawn, we know whether to transition it. The color
         * is included because there can be identical arrows of different colors
         * stacked on each other.
         */
        this.id = 'arrow-' + attribs.start.id + '-to-'
            + attribs.end.id + '-' + this.color.replace(/#/, '');

        const existingArrow = d3.select('g#' + this.id);
        if (existingArrow.empty()) {
            debugInfo(`Arrow(): Creating new ${this.id}`);
            this.doTransition = false;
            this.cssClass = 'n2_hover_elements';
            this.group = diagGroups.arrows.append('g')
                .attr('id', this.id)
                .attr('class', this.cssClass)
        }
        else {
            this.doTransition = true;
            this.group = existingArrow;
            const cssClasses = String(this.group.attr('class')).split(' ');
            this.cssClass = cssClasses.find(o => o.match(/n2_hover_elements.*/));
            debugInfo(`Arrow(): Using existing ${this.id} with class ${this.cssClass}`);
        }
    }

    connectsToCell(cellId) {
        return (this.attribs.start.id == cellId ||
            this.attribs.end.id == cellId);
    }

    get offsetAbsX() {
        return this.nodeSize.width * Arrow.cellOverlap;
    }

    get offsetAbsY() {
        return this.nodeSize.height * Arrow.cellOverlap + 3;  // + to account for the arrow size
    }
}

Arrow.cellOverlap = .125;

/**
 * Draws a two-segment arrow, using provided beginning and end node locations.
 */
class BentArrow extends Arrow {
    constructor(attribs, diagGroups, nodeSize) {
        super(attribs, diagGroups, nodeSize);

        this.start = attribs.start;
        this.end = attribs.end;

        this.middle = { 'row': -1, 'col': -1 };

        this.pts = {
            'start': { 'x': -1, 'y': -1 },
            'mid': { 'x': -1, 'y': -1 },
            'end': { 'x': -1, 'y': -1 }
        }

        this._computePts();
        this.draw();
    }

    /**
     * Determine the location of the "middle" node, where the bend is. Calculate
     * the points corresponding to the associated col, row in the matrix.
     */
    _computePts() {
        this.middle.row = this.start.row;
        this.middle.col = this.end.col;
        let offsetAbsX = this.offsetAbsX;
        let offsetAbsY = this.offsetAbsY;

        this.offsetX = (this.start.col < this.end.col) ? offsetAbsX : -offsetAbsX; // Left-to-Right : Right-to-Left
        this.pts.start.x = this.nodeSize.width * this.start.col + this.nodeSize.width * .5 + this.offsetX;
        this.pts.mid.x = this.nodeSize.width * this.middle.col + this.nodeSize.width * .5;
        // this.pts.mid.x = (this.offsetX > 0)? this.nodeSize.width * this.middle.col : this.nodeSize.width * (this.middle.col + 1);
        this.pts.end.x = this.nodeSize.width * this.end.col + this.nodeSize.width * .5;

        let offsetY = (this.start.row < this.end.row) ? -offsetAbsY : offsetAbsY; // Down : Up
        this.pts.start.y = this.nodeSize.height * this.start.row + this.nodeSize.height * .5;
        this.pts.mid.y = this.nodeSize.height * this.middle.row + this.nodeSize.height * .5;
        this.pts.end.y = this.nodeSize.height * this.end.row + this.nodeSize.height * .5 + offsetY;
    }

    /** Create a path string with a quadratic curve at the bend. */
    _curvedPath() {
        const dir = (this.offsetX > 0) ? 1 : -1;
        const s = this.nodeSize.width * .5 * dir;

        return "M" + this.pts.start.x + " " + this.pts.start.y +
            " L" + this.pts.mid.x + " " + this.pts.mid.y +
            ` q${s} 0 ${s} ${s}` +
            " L" + this.pts.end.x + " " + this.pts.end.y;
    }

    /** Generate a path with a 90-degree angle at the bend. */
    _angledPath() {
        return "M" + this.pts.start.x + " " + this.pts.start.y +
            " L" + this.pts.mid.x + " " + this.pts.mid.y +
            " L" + this.pts.end.x + " " + this.pts.end.y;
    }

    /** Set up for a black/gray dot covered by a colored dot at the arrow bend. */
    _createDots() {
        this.bottomCircle = this.group.append("circle")
            .attr('id', 'bottom-circle')
            .attr("class", this.cssClass);

        this.topCircle = this.group.append("circle")
            .attr('id', 'top-circle')
            .attr("class", this.cssClass)
    }

    /** Use SVG to draw the line segments and an arrow at the end-point. */
    draw() {
        if (this.doTransition) {
            // Arrow already exists, size and/or shape needs updated
            this.path = this.group.select('path').transition(getTransition());

            if (this.group.classed('off-grid-arrow')) {
                // The arrow was previously going offscreen but now is fully onscreen
                this._createDots();
            }
            else {
                this.bottomCircle = this.group.select('circle#bottom-circle').transition(getTransition());
                this.topCircle = this.group.select('circle#top-circle').transition(getTransition());
            }
        }
        else {
            // This is an entirely new arrow
            this.path = this.group.append("path")
                .attr('id', 'arrow-path')
                .attr("class", this.cssClass);

            this._createDots();
        }

        this.group.classed('off-grid-arrow', false);

        this.path
            .attr("marker-end", "url(#arrow)")
            .attr('stroke-dasharray', null)
            .attr("d", this._genPath())
            .attr("fill", "none")
            .style("stroke-width", this.width)
            .style("stroke", this.color);

        this.bottomCircle
            .attr("cx", this.pts.mid.x)
            .attr("cy", this.pts.mid.y)
            .attr("r", this.width * 1.0)
            .style("stroke-width", 0)
            .style("fill-opacity", 1)
            .style("fill", Style.color.connection);

        this.topCircle
            .attr("cx", this.pts.mid.x)
            .attr("cy", this.pts.mid.y)
            .attr("r", this.width * 1.0)
            .style("stroke-width", 0)
            .style("fill-opacity", .75)
            .style("fill", this.color);
    }
}

/**
 * Draw a straight, dashed arrow with one side connected to an
 * offscreen node. Show a tooltip near the offscreen.
 */
class OffGridArrow extends Arrow {
    constructor(attribs, diagGroups, nodeSize) {
        super(attribs, diagGroups, nodeSize);

        this.cell = attribs.cell;
        this.direction = attribs.direction;
        this.cellId = attribs.cellId;

        this.label = {
            'text': attribs.label,
            'pts': {},
            'ref': null,
            'labels': {}
        }

        this.pts = {
            'start': { 'x': -1, 'y': -1 },
            'end': { 'x': -1, 'y': -1 }
        }

        /* Get the bounding rect for the matrix background rect (use rect
         * because getting the bounding rect of a group doesn't work well).
         * This is used to compute the locations of the tooltips since they're divs
         * and not SVG objects.
         */
        this.bgRect = d3.select("#backgroundRect").node().getBoundingClientRect();

    }

    /**
     * Add the pathname of the offscreen node to the label, if it's not
     * already in there.
     * @returns {Boolean} True if the label didn't already contain the pathname.
    */
    _addToLabel() {
        let visValue = this.label.ref.style('visibility');
        let firstEntry = (!visValue.match(/visible/));
        let tipHTML = this.label.ref.node().innerHTML;

        // Prevent duplicate listings
        if (!firstEntry && tipHTML.match(this.label.text)) {
            debugInfo('Duplicate entry for label to ' + this.label.text);
            this.newLabel = false;
            return false;
        }

        this.newLabel = true;

        if (firstEntry) {
            this.label.ref
                .style('visibility', 'visible')
                .node().innerHTML = this.label.text;
        }
        else {
            this.label.ref.node().innerHTML += '<br>' + this.label.text;
        }

        // After adding the text, store the bounding rect of the label
        // so that the new position can be calculated.
        this.label.rect = this.label.ref.node().getBoundingClientRect();

        return true;
    }

    /** Put the SVG arrow on the screen and position the tooltip. */
    draw() {
        debugInfo('Adding offscreen ' + this.attribs.direction +
            ' arrow connected to ' + this.label.text);

        if (this.doTransition) {
            if (!this.group.classed('off-grid-arrow')) {
                // If it was previously a bent arrow, remove the dots.
                this.group.selectAll('circle').remove();
            }

            this.path = this.group.select('path').transition(getTransition());
        }
        else {
            this.path = this.group.insert('path')
                .attr('id', 'arrow-path')
                .attr('class', this.cssClass);
        }

        this.group.classed('off-grid-arrow', true);

        const mid = {
                'x': this.pts.start.x - (this.pts.start.x - this.pts.end.x)/2,
                'y': this.pts.start.y - (this.pts.start.y - this.pts.end.y)/2
            }

        this.path
            .attr('marker-end', 'url(#arrow)')
            .attr('stroke-dasharray', '5,5')
            .attr('d', `M${this.pts.start.x},${this.pts.start.y}
                 L${mid.x},${mid.y} L${this.pts.end.x},${this.pts.end.y}`)
            .attr('fill', 'none')
            .style('stroke-width', this.width)
            .style('stroke', this.color);

        for (let pos in this.label.pts) {
            this.label.ref.style(pos, this.label.pts[pos] + 'px');
        }
    }
}

/**
 * Draw an arrow on the bottom half of the matrix coming up into
 * the onscreen target cell from the offscreen source.
 */
class OffGridUpArrow extends OffGridArrow {
    constructor(attribs, diagGroups, nodeSize) {
        super(Object.assign(attribs, {
            'start': { 'id': attribs.offscreenId },
            'end': { 'id': attribs.cell.tgtId },
            'direction': 'up',
            'cellId': attribs.cellId,
            'color': attribs.color ? attribs.color : Style.color.inputArrow
        }), diagGroups, nodeSize);

        this.label.ref = d3.select("div#left.offgrid");

        this._addToLabel();
        this._computePts();
        this.draw();
    }

    /**
     * Use the start coordinates and the direction of the arrow to determine
     * the starting coordinates and location of the arrowhead.
     */
    _computePts() {
        let offsetY = this.offsetAbsY;

        // Arrow
        this.pts.start.x = this.pts.end.x =
            this.nodeSize.width * this.cell.col + this.nodeSize.width * .5;
        this.pts.start.y = this.attribs.matrixSize * this.nodeSize.height +
            this.nodeSize.height * .5 + offsetY;
        this.pts.end.y = this.nodeSize.height * this.cell.row +
            this.nodeSize.height * .5 + offsetY

        // Tooltip
        if (this.newLabel) {
            this.label.pts.left = this.pts.start.x + this.bgRect.left -
                this.label.rect.width / 2;
            this.label.pts.top = this.bgRect.bottom + 2;
        }
    }
}

/**
 * Draw arrow on the top half of the matrix coming down into the
 * onscreen target cell from the offscreen source.
 */
class OffGridDownArrow extends OffGridArrow {
    constructor(attribs, diagGroups, nodeSize) {
        super(Object.assign(attribs, {
            'start': { 'id': attribs.offscreenId },
            'end': { 'id': attribs.cell.tgtId },
            'direction': 'down',
            'cellId': attribs.cellId,
            'color': attribs.color ? attribs.color : Style.color.inputArrow
        }), diagGroups, nodeSize);

        this.label.ref = d3.select("div#bottom.offgrid");

        this._addToLabel();
        this._computePts();
        this.draw();
    }

    /**
     * Use the start coordinates and the direction of the arrow to determine
     * the starting coordinates and location of the arrowhead.
     */
    _computePts() {
        let offsetY = this.offsetAbsY;

        // Arrow
        this.pts.start.x = this.pts.end.x =
            this.nodeSize.width * this.cell.col + this.nodeSize.width * .5;
        this.pts.start.y = this.nodeSize.height * -.5 - offsetY;
        this.pts.end.y = this.nodeSize.height * this.cell.row +
            this.nodeSize.height * .5 - offsetY;

        // Tooltip
        if (this.newLabel) {
            this.label.pts.left = this.pts.start.x + this.bgRect.left -
                this.label.rect.width / 2;
            this.label.pts.top = this.bgRect.top - this.label.rect.height - 2;
        }
    }
}

/**
 * Draw arrow on the bottom half of matrix going left from the
 * onscreen source cell to the offscreen target.
 */
class OffGridLeftArrow extends OffGridArrow {
    constructor(attribs, diagGroups, nodeSize) {
        super(Object.assign(attribs, {
            'start': { 'id': attribs.cell.srcId },
            'end': { 'id': attribs.offscreenId },
            'direction': 'left',
            'cellId': attribs.cellId,
            'color': attribs.color ? attribs.color : Style.color.outputArrow
        }), diagGroups, nodeSize);

        this.label.ref = d3.select("div#bottom.offgrid");

        this._addToLabel();
        this._computePts();
        this.draw();
    }

    /**
     * Use the start coordinates and the direction of the arrow to determine
     * the starting coordinates and location of the arrowhead.
     */
    _computePts() {
        let offsetX = this.offsetAbsX;

        // Arrow
        this.pts.start.y = this.pts.end.y =
            this.nodeSize.height * this.cell.row + this.nodeSize.height * .5;
        this.pts.start.x = this.nodeSize.width * this.cell.col +
            this.nodeSize.width * .5 - offsetX;
        this.pts.end.x = 0;

        // Tooltip
        if (this.newLabel) {
            this.label.pts.left = this.pts.end.x + this.bgRect.left -
                this.label.rect.width * 0.667;
            this.label.pts.top = this.pts.end.y + this.bgRect.top +
                this.label.rect.height / 2;
        }
    }
}

/**
 * Draw arrow on the top half of the matrix going right away from
 * the onscreen source cell to the offscreen target.
 */
class OffGridRightArrow extends OffGridArrow {
    constructor(attribs, diagGroups, nodeSize) {
        super(Object.assign(attribs, {
            'start': { 'id': attribs.cell.srcId },
            'end': { 'id': attribs.offscreenId },
            'direction': 'right',
            'cellId': attribs.cellId,
            'color': attribs.color ? attribs.color : Style.color.outputArrow
        }), diagGroups, nodeSize);

        this.label.ref = d3.select("div#right.offgrid");

        this._addToLabel();
        this._computePts();
        this.draw();
    }

    /**
     * Use the start coordinates and the direction of the arrow to determine
     * the starting coordinates and location of the arrowhead.
     */
    _computePts() {
        let offsetX = this.offsetAbsX;

        // Arrow
        this.pts.start.y = this.pts.end.y =
            this.nodeSize.height * this.cell.row + this.nodeSize.height * .5;
        this.pts.start.x = this.nodeSize.width * this.cell.col +
            this.nodeSize.width * .5 + offsetX;
        this.pts.end.x = this.attribs.matrixSize * this.nodeSize.width;

        // Tooltip
        if (this.newLabel) {
            this.label.pts.left = this.pts.end.x + this.bgRect.left -
                this.label.rect.width / 3;
            this.label.pts.top = this.pts.end.y + this.bgRect.top +
                this.label.rect.height / 2;
        }
    }
}


/**
 * Maintain a set of arrows, usually for pinning/unpinning.
 * @typedef ArrowCache
 * @property {Object} arrows Every individual arrow keyed by it's ID
 * @property {Object} eventCells Cells that triggered the arrows, with a Set
 *   of associated arrow IDs.
 */
class ArrowCache {
    /**
     * Initialize with empty cache.
     */
    constructor() {
        this.arrows = {};
        this.eventCells = {};
    }

    /**
     * Determine if the arrow exists in this cache.
     * @param {String} arrowId The ID of the arrow to look for.
     * @returns {Boolean} True if found.
     */
    hasArrow(arrowId) {
        return exists(this.arrows[arrowId]);
    }

    /**
     * Find an arrow that is pointing to or from the specified cell.
     * @param {String} cellId The ID of the cell to search for.
     * @returns {String} True if any arrow found, otherwise false.
     */
    hasCell(cellId) {
        for (const id in this.arrows) {
            if (this.arrows[id].connectsToCell(cellId)) return true;
        }

        return false;
    }

    /**
     * Add an individual arrow to the cache.
     * @param {String} cellId The ID of the cell that triggered the event.
     * @param {Arrow} arrow The arrow object to cache.
     * @param {Boolean} [allowReplace = true] Replacing an existing arrow is OK.
     */
    add(cellId, arrow, allowReplace = true) {
        arrow.cellId = cellId;

        if (this.hasArrow(arrow.id) && !allowReplace) {
            console.warn(`ArrowCache.add(): Not adding arrow ${arrow.id} to cache
                    since it already exists.`)
        }
        else {
            this.arrows[arrow.id] = arrow;
            this.addEventCellArrow(cellId, arrow.id);
        }
    }

    /**
     * Associate a cell with an arrow that a mouse event triggered.
     * @param {String} cellId The ID of the event-triggering cell.
     * @param {String} arrowId The ID of the arrow.
     */
    addEventCellArrow(cellId, arrowId) {
        if (!exists(this.eventCells[cellId])) this.eventCells[cellId] = new Set();
        this.eventCells[cellId].add(arrowId);
    }

    /**
     * Determine if the cell triggered any cached arrows.
     * @param {String} cellId The ID of the cell to check.
     * @returns {Boolean} True if the cellId is tracked.
     */
    hasEventCell(cellId) { return exists(this.eventCells[cellId]); }

    /**
     * Disassociate an arrow with a trigger cell. If the cell has no more arrows,
     * remove the entry.
     * @param {String} cellId The ID of the event-triggering cell.
     * @param {String} arrowId The ID of the arrow.
     */
    removeEventCellArrow(cellId, arrowId) {
        if (!exists(this.eventCells[cellId])) {
            console.warn(`removeEventCellArrow: no tracked cell with ID ${cellId}`)
        }
        else if (!this.eventCells[cellId].has(arrowId)) {
            console.warn(`removeEventCellArrow: no arrow with ID ${arrowId}
                associated with cell ID ${cellId}`)
        }
        else {
            this.eventCells[cellId].delete(arrowId)
            if (this.eventCells[cellId].size == 0) delete this.eventCells[cellId];
        }
    }

    /**
     * Delete all associations for the cell and stop tracking it.
     * @param {String} cellId The ID of the event-triggering cell.
     */
    removeEventCell(cellId) {
        if (!exists(this.eventCells[cellId])) {
            console.warn(`removeEventCellArrow: no tracked cell with ID ${cellId}`)
        }
        else {
            this.eventCells[cellId].clear();
            delete this.eventCells[cellId];
        }
    }

    /**
     * Remove drawn arrow from the screen, but keep the info cached.
     * @param {String} arrowId The ID of the single arrow to remove.
     */
    removeArrowFromScreen(arrowId) {
        if (!this.hasArrow(arrowId)) {
            console.warn(`removeArrowFromScreen: Arrow ${arrowId} doesn't exist.`)
        }
        else {
            this.arrows[arrowId].group.remove();
        }
    }

    /**
     * Remove arrow info from cache, but leave the elements on the screen.
     * @param {String} arrowId The ID of the single arrow to remove.
     */
    removeArrowFromCache(arrowId) {
        if (!this.hasArrow(arrowId)) {
            console.warn(`removeArrowFromCache: Arrow ${arrowId} doesn't exist.`)
        }
        else {
            delete this.arrows[arrowId];
            for (const cellId in this.eventCells) {
                if (this.eventCells[cellId].has(arrowId))
                    this.eventCells[cellId].delete(arrowId);
            }
        }
    }

    /**
     * Remove everything we're tracking from screen and cache.
     */
    removeAll() {
        for (const arrowId in this.arrows) {
            this.removeArrowFromScreen(arrowId);
            this.removeArrowFromCache(arrowId);
        }

        this.arrows = {};
        this.eventCells = {};
    }

    /**
     * Move an arrow from one cache to another and change its CSS classes.
     * @param {String} cellId The cell ID that triggered the event.
     * @param {String} arrowId The ID of the single arrow.
     * @param {ArrowCache} oldCache The cache to move the arrow from.
     * @param {String} newClassName The CSS class to add to HTML elements.
     * @param {String} oldClassName The CSS class to remove from HTML elements.
     */
    migrateArrow(cellId, arrowId, oldCache, newClassName, oldClassName) {
        const arrow = oldCache.arrows[arrowId];
        this.add(cellId, arrow);
        oldCache.removeArrowFromCache(arrowId);

        debugInfo(`migrateArrow(): Moving ${arrowId} from class ${oldClassName} to ${newClassName}`);

        arrow.cssClass = newClassName;
        arrow.group
            .classed(oldClassName, false)
            .classed(newClassName, true)
            .selectAll('.' + oldClassName)
            .classed(oldClassName, false)
            .classed(newClassName, true);
    }

    /**
     * Migrate all arrows associated with a cell into this cache from another.
     * @param {String} cellId The ID of the cell to operate on.
     * @param {ArrowCache} oldCache The cache to move the arrows from.
     * @param {String} newClassName The CSS class to add to HTML elements.
     * @param {String} oldClassName The CSS class to remove from HTML elements.
     */
    migrateCell(cellId, oldCache, newClassName, oldClassName) {
        if (!oldCache.hasEventCell(cellId)) {
            console.warn(`migrateCell: Event cell ${cellId} isn't tracked in
                the old cache, can't migrate arrows.`)
        }
        else {
            for (const arrowId of oldCache.eventCells[cellId]) {
                this.migrateArrow(cellId, arrowId, oldCache, newClassName, oldClassName);
            }
            delete oldCache.eventCells[cellId];
        }
    }
}


/**
 * Manage all connection arrow operations. Create new arrows, maintain
 * caches of hovered/pinned arrows, move arrows between them, and
 * transition on updates.
 * @typedef ArrowManager
 * @prop {Object} diagGroups DOM elements referenced by Diagram
 * @prop {ArrowCache} hoverArrows Arrows that disappear if the mouse moves away from the cell
 * @prop {ArrowCache} pinnedArrows Arrows that persist and are redrawn during updates
 * @prop {Object} nodeSize Matrix cell width and height
 * @prop {Number} lineWidth Width of the arrows, calculated from nodeSize.
 * @prop {Object} arrowDirClasses The various offscreen Arrow derived classes.
 */
 class ArrowManager {
    constructor(diagGroups) {
        this.diagGroups = diagGroups;
        this.hoverArrows = new ArrowCache();
        this.pinnedArrows = new ArrowCache();
        this.nodeSize = { 'width': -1, 'height': -1 };
        this._lineWidth = -1;

        this.arrowDirClasses = {
            'top': {
                'incoming': OffGridDownArrow,
                'outgoing': OffGridRightArrow
            },
            'bottom': {
                'incoming': OffGridUpArrow,
                'outgoing': OffGridLeftArrow
            }
        };
    }

    /** Make sure _lineWidth has been manually set */
    get lineWidth() {
        if (this._lineWidth < 0) {
            throw ("addFullArrow: this._lineWidth is unset")
        }

        return this._lineWidth;
    }

    /**
     * Update the node size and calculate the line width.
     * @param {Object} newNodeSize Matrix cell width and height
     */
    setNodeSize(newNodeSize) {
        this.nodeSize = newNodeSize;
        this._lineWidth = Math.min(5, newNodeSize.width * .5, newNodeSize.height * .5);
    }

    /**
     * True if the arrow is referenced in either cache
     * @param {String} arrowId The ID of the arrow to find.
     */
    arrowExists(arrowId) {
        return (this.pinnedArrows.hasArrow(arrowId) ||
            this.hoverArrows.hasArrow(arrowId));
    }

    /**
     * Create a new BentArrow object. This may replace existing elements
     * on the screen with new dimensions and colors. However, the arrow may
     * already exist in one of the caches, in which case it's replaced.
     * @param {String} cellId The ID of the cell that triggered the event.
     * @param {Object} attribs Values to pass to the Arrow constructor.
     * @returns {BentArrow} The newly created arrow object.
     */
    addFullArrow(cellId, attribs) {
        attribs.width = this.lineWidth;
        const newArrow = new BentArrow(attribs, this.diagGroups, this.nodeSize);

        // Add or replace the cache entry with the new arrow
        if (this.pinnedArrows.hasArrow(newArrow.id)) {
            this.pinnedArrows.add(cellId, newArrow);
        }
        else {
            this.hoverArrows.add(cellId, newArrow);
        }

        return newArrow;
    }

    /**
     * Create a new OffGridArrow-derived object. This may replace existing
     * elements on the screen with new dimensions and colors. However, the
     * arrow may already exist in one of the caches, in which case it's not
     * added again.
     * @param {String} cellId The ID of the cell that triggered the event.
     * @param {String} side Whether the arrow is in the top or bottom.
     * @param {String} dir Whether the arrow is incoming or outgoing.
     * @param {Object} attribs Values to pass to the Arrow constructor.
     * @returns {BentArrow} The newly created arrow object.
     */
    addOffGridArrow(cellId, side, dir, attribs) {
        attribs.width = this.lineWidth;
        attribs.cellId = cellId;
        debugInfo("addOffGridArrow(): ", side, dir, attribs)
        const newArrow = new (this.arrowDirClasses[side][dir])(attribs,
            this.diagGroups, this.nodeSize);

        // Add or replace the cache entry with the new arrow
        if (this.pinnedArrows.hasArrow(newArrow.id)) {
            this.pinnedArrows.add(cellId, newArrow);
            this.pinnedArrows.arrows[newArrow.id].cellId = cellId;
        }
        else {
            this.hoverArrows.add(cellId, newArrow);
        }

        return newArrow;
    }

    /**
     * Both endpoints are visible, so draw a full arrow between them.
     * @param {Arrow} arrow The arrow object to transition.
     * @param {MatrixCell} startCell Cell at the beginning of the arrow.
     * @param {MatrixCell} endCell Cell at the end of the arrow.
     */
    _transitionFullArrow(arrow, startCell, endCell) {
        debugInfo(`transition: Found both sides of ${arrow.id}`)
        let attribs = arrow.attribs;
        attribs.start.col = startCell.col;
        attribs.start.row = startCell.row;
        attribs.end.col = endCell.col;
        attribs.end.row = endCell.row;
        attribs.width = this.lineWidth;
        this.pinnedArrows.arrows[arrow.id] =
            new BentArrow(attribs, this.diagGroups, this.nodeSize);
    }

    /**
     * Only the starting cell is visible, so draw an arrow from that
     * heading offscreen in the direction the end would be.
     * @param {Arrow} arrow The arrow object to transition.
     * @param {MatrixCell} startCell Cell at the beginning of the arrow.
     * @param {Matrix} matrix Reference to the matrix object.
     */
    _transitionStartArrow(arrow, startCell, matrix) {
        debugInfo(`transition: Only found start cell for ${arrow.id}`)
        const side = (arrow.attribs.start.id > arrow.attribs.end.id)?
            'bottom' : 'top';
        const attribs = {
            'cell': {
                'col': startCell.col,
                'row': startCell.row,
                'srcId': startCell.srcObj.id,
                'tgtId': startCell.tgtObj.id
            },
            'width': this.lineWidth,
            'cellId': arrow.cellId,
            'matrixSize': matrix.diagNodes.length,
            'offscreenId': arrow.attribs.end.id,
            'label': matrix.model.nodeIds[arrow.attribs.end.id].path,
            'color': arrow.attribs.color
        }
        this.pinnedArrows.arrows[arrow.id] =
            new (this.arrowDirClasses[side]['outgoing'])(attribs,
                    this.diagGroups, this.nodeSize);
    }

    /**
     * Only the ending cell is visible, so draw an arrow to that
     * from offscreen in the direction the starting cell would be.
     * @param {Arrow} arrow The arrow object to transition.
     * @param {MatrixCell} endCell Cell at the end of the arrow.
     * @param {Matrix} matrix Reference to the matrix object.
     */
    _transitionEndArrow(arrow, endCell, matrix) {
        debugInfo(`transition: Only found end cell for ${arrow.id}`)
        const side = (arrow.attribs.start.id > arrow.attribs.end.id)?
            'bottom' : 'top';
        const attribs = {
            'cell': {
                'col': endCell.col,
                'row': endCell.row,
                'srcId': endCell.srcObj.id,
                'tgtId': endCell.tgtObj.id
            },
            'width': this.lineWidth,
            'cellId': arrow.cellId,
            'matrixSize': matrix.diagNodes.length,
            'offscreenId': arrow.attribs.start.id,
            'label': matrix.model.nodeIds[arrow.attribs.start.id].path,
            'color': arrow.attribs.color
        }
        this.pinnedArrows.arrows[arrow.id] =
            new (this.arrowDirClasses[side]['incoming'])(attribs,
                this.diagGroups, this.nodeSize);
    }

    /**
     * Handle nodes that were uncollapsed with pinned arrows by pinning arrows
     * to their visible child nodes. This is done after the rest of the arrow
     * transitions because new arrows are added to the cache.
     * @param {Array} uncollapsedNodeIds List of nodeIds that were uncollapsed.
     * @param {Matrix} matrix Reference to the matrix object.
     */
    _transitionUncollapsedNodes(uncollapsedNodeIds, matrix) {
        for (const row in matrix.grid) {
            const cell = matrix.grid[row][row]; // Diagonal cells only
            for (const nodeId of uncollapsedNodeIds) {
                if (cell.obj.hasParent(matrix.model.nodeIds[nodeId])) {
                    matrix.drawOnDiagonalArrows(cell);
                    this.togglePin(cell.id, true);
                }
            }
        }
    }

    /**
     * Redraw all the visible arrows in the pinned arrow cache, and remove
     * the ones for which neither endpoint is visible. Full arrows may
     * need to transition to offgrid arrows and vice versa.
     * @param {Matrix} matrix The matrix to operate with.
     */
    transition(matrix) {
        let uncollapsedNodeIds = [];

        for (const arrowId in this.pinnedArrows.arrows) {
            const arrow = this.pinnedArrows.arrows[arrowId];
            const startCellInfo = matrix.findCellByNodeId(arrow.attribs.start.id);
            const endCellInfo = matrix.findCellByNodeId(arrow.attribs.end.id);
            const startCell = startCellInfo.cell;
            const endCell = endCellInfo.cell;

            if (startCell === endCell) { // Both undefined, or same cell
                if (startCell === undefined)
                    debugInfo(`transition: No visible endpoints for ${arrowId}`)
                else
                    debugInfo(`transition: ${arrowId} points to and from` +
                        ` collapsed cell ${startCell.id}`)

                this.pinnedArrows.removeArrowFromScreen(arrowId);
            }
            else if (startCellInfo.childMatch || endCellInfo.childMatch) {
                debugInfo(`transition: ${arrowId} endpoint was previously collapsed, \
                    pinning arrows for all children.`)
                if (startCellInfo.childMatch)
                    uncollapsedNodeIds.push(arrow.attribs.start.id);
                if (endCellInfo.childMatch)
                    uncollapsedNodeIds.push(arrow.attribs.end.id);

                this.pinnedArrows.removeArrowFromScreen(arrowId);
                this.pinnedArrows.removeArrowFromCache(arrowId);
            }
            else if ((startCellInfo.exactMatch || startCellInfo.parentMatch) &&
                (endCellInfo.exactMatch || endCellInfo.parentMatch)) {
                // Both endpoint cells are visible
                this._transitionFullArrow(arrow, startCell, endCell);
            }
            else if (startCell) {
                // Only the non-pointy end is visible
                this._transitionStartArrow(arrow, startCell, matrix);
            }
            else if (endCell) {
                // Only the pointy end is visible
                this._transitionEndArrow(arrow, endCell, matrix);
            }
        }

        // Adding arrows, so do after iteration through arrow list
        this._transitionUncollapsedNodes(uncollapsedNodeIds, matrix);
    }

    /**
     * If arrows are hovering, then pin them, and vice versa.
     * @param {String} cellId The ID of the MatrixCell to operate on.
     * @param {Boolean} [ pinOnly = false] If true, don't unpin anything.
     */
    togglePin(cellId, pinOnly = false) {
        const cellClassName = "n2_hover_elements_" + cellId;
        if (this.pinnedArrows.hasEventCell(cellId)) { // Arrows already pinned
            if (pinOnly) return;
            debugInfo(`Unpinning ${cellId} arrows`)
            this.hoverArrows.migrateCell(cellId, this.pinnedArrows,
                'n2_hover_elements', cellClassName);
            this.removeAllHovered();
        }
        else if (this.hoverArrows.hasEventCell(cellId)) { // Arrows just "hovered"
            debugInfo(`Pinning ${cellId} arrows`)
            this.pinnedArrows.migrateCell(cellId, this.hoverArrows,
                cellClassName, 'n2_hover_elements');
        }
    }

    /** Remove all arrows in the hoverArrow cache */
    removeAllHovered() {
        const removedArrowIds = Object.keys(this.hoverArrows.arrows);
        this.hoverArrows.removeAll();
        debugInfo(`removeAllHovered(): Removed ${removedArrowIds.length} arrows`)
    }

    /** Remove all arrows in the pinnedArrow cache */
    removeAllPinned() {
        const removedArrowIds = Object.keys(this.pinnedArrows.arrows);
        this.pinnedArrows.removeAll();
        debugInfo(`removeAllPinned(): Removed ${removedArrowIds.length} arrows`)
    }

    /* Save all pinnedArrows to a dictionary for saving the view. */
    savePinnedArrows() {
        let pinned = this.pinnedArrows;
        let data = {};

        for (const arrowId in pinned.arrows) {
            const arrow = pinned.arrows[arrowId];

            if (arrow.cell !== undefined) {
                // Off screen connection.
                data[arrowId] = [arrow.cellId, arrow.direction,
                                 arrow.cell.col, arrow.cell.row,
                                 arrow.cell.srcId, arrow.cell.tgtId,
                                 arrow.attribs.matrixSize, arrow.attribs.label, arrow.attribs.offscreenId];
            }
            else {
                // On screen connection.
                data[arrowId] = [arrow.cellId,
                                 arrow.start.col, arrow.start.row, arrow.start.id,
                                 arrow.end.col, arrow.end.row, arrow.end.id,
                                 arrow.color];
            }

        }
        return data;
    }

    /* Restore all pinnedArrows that were saved in a view. */
    loadPinnedArrows(arrows) {
        this.pinnedArrows.removeAll();

        for(const arrowID in arrows) {
            const arrow = arrows[arrowID];

            if (arrow.length == 9) {
                // Off screen arrow.
                let arrowClasses = {
                    'down': OffGridDownArrow,
                    'up': OffGridUpArrow,
                    'left': OffGridLeftArrow,
                    'right': OffGridRightArrow,
                };

                let attribs = {
                    'cell': {
                        'col': arrow[2],
                        'row': arrow[3],
                        'srcId': arrow[4],
                        'tgtId': arrow[5],
                    },
                    'matrixSize': arrow[6],
                    'label': arrow[7],
                    'offscreenId': arrow[8],
                };

                attribs.width = this.lineWidth;
                const newArrow = new (arrowClasses[arrow[1]])(attribs,
                    this.diagGroups, this.nodeSize);
                this.pinnedArrows.add(arrow[0], newArrow);
            }
            else {
                // On screen arrow.
                let attribs = {
                    'start': {
                        'col': arrow[1],
                        'row': arrow[2],
                        'id': arrow[3]
                    },
                    'end': {
                        'col': arrow[4],
                        'row': arrow[5],
                        'id': arrow[6]
                    },
                    'color': arrow[7],
                };
                attribs.width = this.lineWidth;
                const newArrow = new BentArrow(attribs, this.diagGroups, this.nodeSize);
                this.pinnedArrows.add(arrow[0], newArrow);
            }
        }
    }
}

/**
 * Manage the search functions for the diagram, which uses the Awesomplete widget from
 * https://leaverou.github.io/awesomplete/
 * @typedef Search
 */
class Search {
    /**
     * Initialize Search object properties and Awesomeplete.
     * @param {TreeNode} zoomedElement The selected node in the model tree.
     * @param {TreeNode} root The base element of the model tree.
     */
    constructor(zoomedElement, root) {
        // Used for autocomplete suggestions:
        this.filteredWord = {
            'value': "",
            'containsDot': false,
            'baseName': ""

        }
        this.filterSet = {};

        this.updateRecomputesAutoComplete = true;

        this.wordIndex = 0;
        this.searchVals = [];
        this.inDataFunction = true;

        this.searchCollapsedUndo = []; // Non-matching nodes to be minimized/hidden.

        this.numMatches = 0;
        this.searchInputDiv = d3.select("#awesompleteId").node();
        this.searchCountDiv = d3.select("#searchCountId");
        this.searchInputDiv.value = '';

        this._setupAwesomplete();
        this._addEventListeners();
        this.update(zoomedElement, root);
    }

    /** Initialize the Awesomplete widget. */
    _setupAwesomplete() {
        const self = this;
        this.searchAwesomplete = new Awesomplete(self.searchInputDiv, {
            "minChars": 1,
            "maxItems": 15,
            "list": [],
            "filter": function (text, input) {
                if (self.inDataFunction) {
                    self.inDataFunction = false;
                    self.filterSet = {};
                }

                if (self.filteredWord.value.length == 0) return false;

                if (self.filterSet.hasOwnProperty(text)) return false;

                self.filterSet[text] = true;

                if (self.filteredWord.containsDot)
                    return Awesomplete.FILTER_STARTSWITH(text,
                        self.filteredWord.value);

                return Awesomplete.FILTER_CONTAINS(text,
                    self.filteredWord.value);
            },
            "item": function (text, input) {
                return Awesomplete.ITEM(text, self.filteredWord.value);
            },
            "replace": function (text) {
                let newVal = "";
                let cursorPos = 0;
                for (let i = 0; i < self.searchVals.length; ++i) {
                    newVal += ((i == self.wordIndex) ? text : self.searchVals[i]) + " ";
                    if (i == self.wordIndex) cursorPos = newVal.length - 1;
                }
                this.input.value = newVal;
                self.searchInputDiv.setSelectionRange(cursorPos, cursorPos);
            },
            "data": function (item /*, input*/) {
                self.inDataFunction = true;
                if (self.filteredWord.containsDot) {
                    let baseIndex = item.toLowerCase().indexOf("." +
                        self.filteredWord.baseName.toLowerCase() + ".");
                    if (baseIndex > 0) return item.slice(baseIndex + 1);
                }
                return item;
            }
        });
    }

    /**
     * Add a couple of event listeners that are easier to do from here
     * than in UserInterface.
     */
    _addEventListeners() {
        const self = this;

        d3.select('#awesompleteId').on('awesomplete-selectcomplete', e => {
            self.searchInputEventListener(e);
            self.searchAwesomplete.evaluate();
        });

        d3.select('#awesompleteId').on('input', this.searchInputEventListener.bind(this));
        d3.select('#awesompleteId').on('focus', this.searchInputEventListener.bind(this));
    }

    /**
     * Recurse through the tree and find nodes with pathnames that match
     * the computed regular expression. Minimize/hide nodes that don't match.
     * @param {TreeNode} node The current node to operate on.
     * @param {RegExp} regexMatch A regular expression assembled from the search values.
     * @param {Array} undoList List of nodes that have been hidden/minimized.
     * @returns {Boolean} True if a match was found, false otherwise.
     */
    _doSearch(node, regexMatch, undoList) {
        let didMatch = false;

        if (node.hasChildren() && !node.draw.minimized) {
            // depth first, dont go into minimized children
            for (let child of node.children) {
                if (this._doSearch(child, regexMatch, undoList)) didMatch = true;
            }
        }

        if (node === this.zoomedElement) return didMatch;

        if (!didMatch && !node.hasChildren() && node.isInputOrOutput()) {
            didMatch = regexMatch.test(node.path);
            if (didMatch) {
                // only inputs and outputs can count as matches
                ++this.numMatches;
            }
            else if (undoList) {
                // did not match and undo list is not null
                node.draw.hidden = true;
                undoList.push(node);
            }
        }

        if (!didMatch && node.hasChildren() && !node.draw.minimized && undoList) {
            // minimizeable and undoList not null
            node.draw.minimized = true;
            undoList.push(node);
        }

        return didMatch;
    }

    /**
     * Reset the number of matches to zero and execute the search with a null value
     * for undoList, so it's not changed.
     */
    _countMatches() {
        this.numMatches = 0;

        if (this.searchVals.length != 0)
            this._doSearch(this.zoomedElement, this._getSearchRegExp(this.searchVals), null);
    }

    /** Undo results of the previous search, and perform a new one. */
    performSearch() {
        for (let node of this.searchCollapsedUndo) {
            //auto undo on successive searches
            if (!node.hasChildren() && node.isInputOrOutput()) node.draw.hidden = false;
            else node.draw.minimized = false;
        }

        this.numMatches = 0;
        this.searchCollapsedUndo = [];
        if (this.searchVals.length != 0)
            this._doSearch(this.zoomedElement, this._getSearchRegExp(this.searchVals),
                this.searchCollapsedUndo);

    }

    /** Do some escaping and replacing of globbing with regular expressions. */
    _getSearchRegExp(searchValsArray) {
        let regexStr = new String("(^" + searchValsArray.join("$|^") + "$)")
            .replace(/[\.\?\*\^]/g, function (c) {
                return {
                    '.': "\\.",
                    '?': ".",
                    '*': ".*?",
                    '^': "^.*?"
                }[c];
            });

        return new RegExp(regexStr, "i"); // case insensitive
    }

    _isValid(value) {
        return value.length > 0;
    }

    /**
     * React to each value entered into the search input box.
     * @param {Event} e The object describing the keypress event.
     */
    searchInputEventListener(e) {
        testThis(this, 'Search', 'searchInputEventListener');

        const target = e.target;

        //valid characters AlphaNumeric : _ ? * space .
        const newVal = target.value.replace(/([^a-zA-Z0-9:_\?\*\s\.])/g, "");

        if (newVal != target.value) {
            target.value = newVal; // won't trigger new event
        }

        this.searchVals = target.value.split(" ");

        const filtered = this.searchVals.filter(this._isValid);
        this.searchVals = filtered;

        const lastLetterTypedIndex = target.selectionStart - 1;

        let endIndex = target.value.indexOf(" ", lastLetterTypedIndex);
        if (endIndex == -1) endIndex = target.value.length;

        let startIndex = target.value.lastIndexOf(" ", lastLetterTypedIndex);
        if (startIndex == -1) startIndex = 0;

        const sub = target.value.substring(startIndex, endIndex).trim();
        // valid openmdao character types: AlphaNumeric : _ .
        this.filteredWord.value = sub.replace(/([^a-zA-Z0-9:_\.])/g, "");

        let i = 0;
        for (let val of this.searchVals) {
            if (val.replace(/([^a-zA-Z0-9:_\.])/g, "") == this.filteredWord.value) {
                this.wordIndex = i;
                break;
            }
            ++i;
        }

        this.filteredWord.containsDot = (this.filteredWord.value.indexOf(".") != -1);
        this.searchAwesomplete.list = this.filteredWord.containsDot ?
            this.autoComplete.paths.list : this.autoComplete.names.list;
        this.filteredWord.baseName = this.filteredWord.containsDot ?
            this.filteredWord.value.split(".")[0].trim() : "";

        this._countMatches();
        this.searchCountDiv.html("" + this.numMatches + " matches");
    }

    /**
     * Find the earliest minimized parent of the specified node.
     * @param {TreeNode} node The node to search from.
     * @returns {TreeNode} The earliest mimimized parent node.
     */
    findRootOfChangeForSearch(node) {
        let earliestObj = node;
        for (let obj = node; obj != null; obj = obj.parent) {
            if (obj.draw.minimized) earliestObj = obj;
        }
        return earliestObj;
    }

    /**
     * Recurse through the children of the node and add their names to the
     * autocomplete list of names, if they're not already in it.
     * @param {TreeNode} node The node to search from.
     */
    _populateAutoCompleteList(node) {
        if (node.hasChildren() && !node.draw.minimized) {
            // Depth first, dont go into minimized children
            for (let child of node.children) {
                this._populateAutoCompleteList(child);
            }
        }

        if (node === this.zoomedElement) return;

        let nodeName = node.name;
        if (!node.isInputOrOutput()) nodeName += ".";
        let namesToAdd = [nodeName];

        for (let name of namesToAdd) {
            if (!this.autoComplete.names.set.hasOwnProperty(name)) {
                this.autoComplete.names.set[name] = true;
                this.autoComplete.names.list.push(name);
            }
        }

        let localPathName = (this.zoomedElement === this.modelRoot) ?
            node.path : node.path.slice(this.zoomedElement.path.length + 1);

        if (!this.autoComplete.paths.set.hasOwnProperty(localPathName)) {
            this.autoComplete.paths.set[localPathName] = true;
            this.autoComplete.paths.list.push(localPathName);
        }
    }

    /**
     * If the zoomed element has changed, update the auto complete lists.
     * @param {TreeNode} zoomedElement The selected node in the model tree.
     * @param {TreeNode} root The base element of the model tree.
     */
    update(zoomedElement, root) {
        this.zoomedElement = zoomedElement;
        this.modelRoot = root;

        if (!this.updateRecomputesAutoComplete) {
            this.updateRecomputesAutoComplete = true;
            return;
        }

        this.autoComplete = {
            'names': {
                'list': [],
                'set': {}
            },
            'paths': {
                'list': [],
                'set': {}
            }
        }

        this._populateAutoCompleteList(this.zoomedElement);
    }
}

/**
 * @typedef {Object} SymbolType
 * @property {string} name What the symbol is called.
 */
class SymbolType {

    /**
     * Determine the name and whether it's a declared partial based on info
     * from the provided node.
     * @param {MatrixCell} cell The object to select the type from.
     * @param {ModelData} model Reference to the model to get some info from it.
     */
    constructor(cell, model) {
        this.name = null;

        this._init();

        // Update properties based on the the referenced node.
        this.getType(cell, model);
    }

    /**
     * Separate these calls from the constructor so that subclasses can
     * set values before execution.
     */
    _init() { }

    /** 
     * Decide what object the cell will be drawn as, based on its position
     * in the matrix, type, source, target, and/or other conditions.
     * @param {MatrixCell} cell The cell to operate on.
     */
    getType(cell) {
        if (cell.srcObj.isFilter() || cell.tgtObj.isFilter()) {
            this.name = 'filter';
        }
        else if (cell.srcObj.isGroup() || cell.tgtObj.isGroup()) {
            this.name = 'group';
        }
        else if (cell.onDiagonal()) {
            this.name = 'vector';
        }
        else if (cell.srcObj.isInputOrOutput() || cell.tgtObj.isInputOrOutput() ) {
            this.name = 'vectorVector';
        }
        else {
            console.warn("Completely unrecognized symbol type for cell ", cell)
            throw ("Completely unrecognized symbol type.")
        }
    }
}


/** Base class for all cell renderers */
class CellRenderer {
    /**
     * Set values shared by objects of all derived class types.
     * @param {string} color The color to render all shapes in.
     * @param {string} className The CSS class to tag primary shapes with, used for selecting.
     */
    constructor(color, className, id) {
        this.color = color;
        this.className = className;
        this.id = 'cellShape_' + id; // To ensure it doesn't start with a number
    }

    static updateDims(baseWidth, baseHeight, pcntSize = 0.6) {
        if (!CellRenderer.dims) {
            CellRenderer.prevDims = {
                "size": {
                    "width": 0,
                    "height": 0,
                    "percent": pcntSize
                },
                "bottomRight": {
                    "x": 0,
                    "y": 0
                },
                "topLeft": {
                    "x": 0,
                    "y": 0
                }
            }
        }
        else {
            for (const prop of ["size", "bottomRight", "topLeft"]) {
                Object.assign(CellRenderer.prevDims[prop],
                    CellRenderer.dims[prop]);
            }
        }

        CellRenderer.dims = {
            "size": {
                "width": baseWidth,
                "height": baseHeight,
                "percent": pcntSize
            },
            "bottomRight": {
                "x": baseWidth * .5,
                "y": baseHeight * .5
            },
            "topLeft": {
                "x": baseWidth * -.5,
                "y": baseHeight * -.5
            }
        }
    }

    /** Enable access to the static dims variable through "this". */
    get dims() {
        return CellRenderer.dims;
    }

    /** Enable access to the static prevDims variable through "this". */
    get prevDims() {
        return CellRenderer.prevDims;
    }

    /** Act like an abstract base class force derived classes to define. */
    update() {
        throw ("ERROR: CellRenderer.update() called.")
    }

    /** Act like an abstract base class force derived classes to define. */
    render() {
        throw ("ERROR: CellRenderer.render() called.")
    }

    /** Reposition an SVG element based on dimensions of the current cell size. */
    updateCurrent(svgGroup) {
        return this.update(svgGroup, this.dims);
    }

    /** Reposition an SVG element based on dimensions of the previous cell size. */
    updatePrevious(svgGroup) {
        return this.update(svgGroup, this.prevDims);
    }

    /** Add an SVG element based on dimensions of the current cell size. */
    renderCurrent(svgGroup) {
        return this.render(svgGroup, this.dims);
    }

    /** Add an SVG element based on dimensions of the previous cell size. */
    renderPrevious(svgGroup) {
        return this.render(svgGroup, this.prevDims);
    }
}

/** Draws/updates an SVG circle for scalar types, with a transition animation. */
class ScalarBase extends CellRenderer {

    /**
     * Invoke the superclass constructor with these values and "sMid" as a CSS class.
     * @param {Object} dims Layout and dimensions for the current cell spec.
     * @param {Object} prevDims Layout and dimensions for the previous cell spec.
     * @param {string} color The color to render all shapes in.
     */
    constructor(color, id) {
        super(color, "sMid", id);
    }

    /**
     * Select the element with D3 if not already done, attach a transition
     * and resize the shape.
     * @param svgGroup Reference to SVG <g> element associated with data.
     * @param {Object} dims The cell spec to use while resizing/repositioning.
     * @param {selection} [d3Elem = null ] The selection created in render().
     */
    update(svgGroup, dims, d3Elem = null) {
        if (!d3Elem) d3Elem = d3.select(svgGroup).select("." + this.className)
            .transition(sharedTransition);
            
        return d3Elem
            .attr("rx", dims.bottomRight.x * dims.size.percent)
            .attr("ry", dims.bottomRight.y * dims.size.percent);
    }

    /** 
     * Get the D3 selection for the appropriate group and append a filled ellipse.
     * @param {Object} svgGroup Reference to SVG <g> element associated with data.
     * @param {Object} dims The cell spec to use while rendering.
     */
    render(svgGroup, dims) {
        const d3Elem = d3.select(svgGroup)
            .append("ellipse")
            .attr("class", this.className)
            .attr("id", this.id)
            .style("fill", this.color);

        return this.update(svgGroup, dims, d3Elem)
    }
}

/** Draws/updates an SVG rect for vector types, with a transition animation. */
class VectorBase extends CellRenderer {

    /**
     * Invoke the superclass constructor with these values and "vMid" as a CSS class.
     * @param {Object} dims Layout and dimensions for the current cell spec.
     * @param {Object} prevDims Layout and dimensions for the previous cell spec.
     * @param {string} color The color to render all shapes in.
     */
    constructor(color, id) {
        super(color, "vMid", id);
    }

    /**
     * Select the element with D3 if not already done, attach a transition
     * and resize the shape.
     * @param svgGroup Reference to SVG <g> element associated with data.
     * @param {Object} dims The cell spec to use while resizing/repositioning.
     * @param {selection} [d3Elem = null ] The selection created in render().
     */
    update(svgGroup, dims, d3Elem = null) {
        if (!d3Elem) d3Elem = d3.select(svgGroup).select("." + this.className)
            .transition(sharedTransition);

        const ret = d3Elem
            .attr("x", dims.topLeft.x * dims.size.percent)
            .attr("y", dims.topLeft.y * dims.size.percent)
            .attr("width", dims.bottomRight.x * dims.size.percent * 2)
            .attr("height", dims.bottomRight.y * dims.size.percent * 2);


        return ret;
    }

    /** 
     * Get the D3 selection for the appropriate group and append a filled rectangle.
     * @param {Object} svgGroup Reference to SVG <g> element associated with data.
     * @param {Object} dims The cell spec to use while rendering.
     */
    render(svgGroup, dims) {
        const d3Elem = d3.select(svgGroup).append('rect')
            .attr("class", this.className)
            .attr("id", this.id)
            .style("fill", this.color);

        return this.update(svgGroup, dims, d3Elem);
    }
}

class Connector extends CellRenderer {
    /**
     * Invoke the superclass constructor with these values and "vMid" as a CSS class.
     * @param {Object} dims Layout and dimensions for the current cell spec.
     * @param {Object} prevDims Layout and dimensions for the previous cell spec.
     * @param {string} color The color to render all shapes in.
     */
    constructor(color, id) {
        super(color, "vMid", id);
    }

    _transform(scale) { throw ("ERROR: Connector._transform() called.") }

    /**
     * Select the element with D3 if not already done, attach a transition
     * and resize the shape.
     * @param svgGroup Reference to SVG <g> element associated with data.
     * @param {Object} dims The cell spec to use while resizing/repositioning.
     * @param {selection} [d3Elem = null ] The selection created in render().
     */
    update(svgGroup, dims, d3Elem = null) {
        if (!d3Elem) d3Elem = d3.select(svgGroup).select("." + this.className)
            .transition(sharedTransition);

        const ret = d3Elem.attr("transform", this._transform(dims.size.width/10.0));

        return ret;
    }

    /** 
     * Get the D3 selection for the appropriate group and append a filled arrow.
     * @param {Object} svgGroup Reference to SVG <g> element associated with data.
     * @param {Object} dims The cell spec to use while rendering.
     */
    render(svgGroup, dims) {
        const d3Elem = d3.select(svgGroup).append('use')
            .attr("class", this.className)
            .attr("id", this.id)
            .style("fill", this.color)
            .attr("x", -5)
            .attr("y", -5)
            .attr("xlink:href", "#matrix-connector-square")

        return this.update(svgGroup, dims, d3Elem);
    }
}

/** Draws/updates an SVG rect with a border for group types, with a transition animation. */
class GroupBase extends CellRenderer {
    /**
     * Invoke the superclass constructor with these values and "gMid" as a CSS class.
     * @param {Object} dims Layout and dimensions for the current cell spec.
     * @param {Object} prevDims Layout and dimensions for the previous cell spec.
     * @param {string} color The color to render all shapes in.
     */
    constructor(color, id) {
        super(color, "gMid", id);
    }

    /**
     * Select the each of the border elements with D3 if not already done,
     * attach a transition and resize each shape individually.
     * @param {Object} dims The cell spec to use while resizing/repositioning.
     * @param {selection} d3Group The pre-selected group to work with.
     * @param {Array} border Border selections created in _renderBorder().
     */
    _updateBorder(dims, d3Group, border) {
        if (!border) {
            // Find the existing border rects if not provided.
            border = [
                d3Group.select(".bordR1").transition(sharedTransition),
                d3Group.select(".bordR2").transition(sharedTransition),
                d3Group.select(".bordR3").transition(sharedTransition),
                d3Group.select(".bordR4").transition(sharedTransition)
            ];
        }

        border[0]
            .attr("x", dims.topLeft.x).attr("y", dims.topLeft.y)
            .attr("width", dims.size.width).attr("height", dims.size.height * .1);

        border[1]
            .attr("x", dims.topLeft.x).attr("y", dims.topLeft.y)
            .attr("width", dims.size.width * .1).attr("height", dims.size.height);

        border[2]
            .attr("x", dims.bottomRight.x * .8).attr("y", dims.topLeft.y)
            .attr("width", dims.size.width * .1).attr("height", dims.size.height);

        border[3]
            .attr("x", dims.topLeft.x).attr("y", dims.bottomRight.y * .8)
            .attr("width", dims.size.width).attr("height", dims.size.height * .1);
    }

    /**
     * Draw four skinny rectangles at the perimeter of the group.
     * @param {Object} d3Group D3 selection for the group that we add to.
     */
    _renderBorder(d3Group) {
        const border = [
            d3Group.append("rect").attr("class", "bordR1").style("fill", this.color),
            d3Group.append("rect").attr("class", "bordR2").style("fill", this.color),
            d3Group.append("rect").attr("class", "bordR3").style("fill", this.color),
            d3Group.append("rect").attr("class", "bordR4").style("fill", this.color)
        ];

        return border;
    }

    /**
     * Select the element with D3 if not already done, attach a transition
     * and resize the shape.
     * @param svgGroup Reference to SVG <g> element associated with data.
     * @param {Object} dims The cell spec to use while resizing/repositioning.
     * @param {selection} [d3Elem = null] The selection created in render().
     * @param {Array} [border = null] Border selections created in _renderBorder().
     */
    update(svgGroup, dims, d3Elem = null, border = null) {
        const d3Group = d3.select(svgGroup);
        if (!d3Elem) d3Elem = d3Group.select("." + this.className)
            .transition(sharedTransition);

        this._updateBorder(dims, d3Group, border);

        return d3Elem
            .attr("x", dims.topLeft.x * dims.size.percent)
            .attr("y", dims.topLeft.y * dims.size.percent)
            .attr("width", dims.size.width * dims.size.percent)
            .attr("height", dims.size.height * dims.size.percent);
    }

    /** 
     * Get the D3 selection for the appropriate group and append a filled rectangle,
     * then call _renderBorder() to put a border around it.
     * @param {Object} svgGroup Reference to SVG <g> element associated with data.
     * @param {Object} dims The cell spec to use while rendering.
     */
    render(svgGroup, dims) {
        const d3Group = d3.select(svgGroup);
        const border = this._renderBorder(d3Group);
        const d3Elem = d3Group
            .append("rect")
            .attr("class", this.className)
            .attr("id", this.id)
            .style("fill", this.color);

        return this.update(svgGroup, dims, d3Elem, border);
    }
}

class ScalarCell extends ScalarBase {
    constructor(color, id) {
        super(color, id);
    }
}

class VectorCell extends VectorBase {
    constructor(color, id) {
        super(color, id);
    }
}

class GroupCell extends GroupBase {
    constructor(color, id) {
        super(color, id);
    }
}

class ConnectorUpper extends Connector {
    constructor(color, id) {
        super(color, id);
    }

    /** Generate a string to use for the transform attribute */
    _transform(scale) { return('scale(' + scale + ')'); }
}

class ConnectorLower extends Connector {
    constructor(color, id) {
        super(color, id);
    }

    /** Generate a string to use for the transform attribute */
    _transform(scale) { return('scale(' + scale + ') rotate(180)'); }
}

class FilterCell extends VectorBase {
    constructor(color, id) {
        super(color, id);
    }
}


/**
 * A visible cell in the matrix grid.
 * @typedef {Object} MatrixCell
 * @property {number} row Vertical coordinate of the cell in the matrix.
 * @property {number} col Horizontal coordinate of the cell in the matrix.
 * @property {TreeNode} srcObj The node in the model tree this cell is associated with.
 * @property {TreeNode} tgtObj The model tree node that this outputs to.
 * @property {string} id The srcObj id appended with the tgtObj id.
 * @property {SymbolType} symbolType Info about the type of symbol represented by the node.
 * @property {CellRenderer} renderer The object that draws the cell.
 */
class MatrixCell {
    /**
     * Initialize the cell.
     * @param {Number} row Vertical coordinate of the cell in the matrix.
     * @param {Number} col Horizontal coordinate of the cell in the matrix.
     * @param {TreeNode} srcObj The node in the model tree this node is associated with.
     * @param {TreeNode} tgtObj The model tree node that this outputs to.
     * @param {ModelData} model Reference to the model to get some info from it.
     */
    constructor(row, col, srcObj, tgtObj, model) {
        this.row = row;
        this.col = col;
        this.srcObj = this.obj = srcObj;
        this.tgtObj = tgtObj;
        this.id = MatrixCell.makeId(srcObj.id, tgtObj.id);

        this._setSymbolType(model);
        this.renderer = this._newRenderer();

        this.offScreen = {
            "top": {
                "incoming": new Set(),
                "outgoing": new Set()
            },
            "bottom": {
                "incoming": new Set(),
                "outgoing": new Set()
            },
            "total": 0
        }
    }

    _setSymbolType(model) {
        this.symbolType = new SymbolType(this, model);
    }

    static makeId(srcId, tgtId = null) {
        if (! tgtId || srcId == tgtId) return "node_" + srcId;
        
        return "conn_" + srcId + "_to_" + tgtId;
    }

    /**
     * Determine if this node is on the main diagonal of the matrix.
     * @return {Boolean} True if row equals column.
     */
    onDiagonal() {
        return (this.row == this.col);
    }

    /**
     * Determine if this node is in the upper-right triangle of the matrix.
     * @return {Boolean} True if column is greater than row.
     */
    inUpperTriangle() {
        return (this.col > this.row);
    }

    /**
     * Determine if this node is in the lower-left triangle of the matrix.
     * @return {Boolean} True if row is greater than column.
     */
    inLowerTriangle() {
        return (this.row > this.col);
    }

    /**
     * Select the mouseover callback depending on whether we're on the diagonal.
     * TODO: Remove these globals
     */
    getMouseoverFunc() {
        return (this.onDiagonal() ? n2MouseFuncs.overOnDiag : n2MouseFuncs.overOffDiag);
    }

    /**
    * Select the mousemove callback depending on whether we're on the diagonal.
    * TODO: Remove these globals
    */
    getMousemoveFunc() {
        return (this.onDiagonal() ? n2MouseFuncs.moveOnDiag : null);
    }

    /**
     * Choose a color based on our location and state of the associated TreeNode.
     */
    color() {
        if (this.onDiagonal()) {
            if (this.obj.draw.minimized) return Style.color.collapsed;
            if (this.obj.isConnectedInput()) return Style.color.input;
            if (this.obj.isOutput()) return Style.color.output;
            if (this.obj.isUnconnectedInput()) return Style.color.unconnectedInput;
        }

        return Style.color.connection;
    }

    /**
     * A connection going "off-screen" was detected between two nodes.
     * Determine whether the arrow should be in the top or bottom section of the
     * matrix based on rootIndex, and add to the appropriate array of
     * tracked offscreen connections.
     * @param {TreeNode} srcNode Where the connection starts.
     * @param {TreeNode} tgtNode Where the connection ends.
     */
    addOffScreenConn(srcNode, tgtNode) {
        let offscreenNode = null, dir = '', side = '';

        if (srcNode === this.tgtObj) {
            dir = 'outgoing';
            offscreenNode = tgtNode;           
        }
        else {
            dir = 'incoming';
            offscreenNode = srcNode;
        }
        side = (srcNode.rootIndex < tgtNode.rootIndex)? 'top' : 'bottom';

        const offScreenSet = this.offScreen[side][dir];

        if (!offScreenSet.has(offscreenNode)) {
            offScreenSet.add(offscreenNode);
            this.offScreen.total++;
        }
    }

    /** Choose a renderer based on our SymbolType. */
    _newRenderer() {
        if (this.color() == Style.color.connection) {
            if (this.inUpperTriangle()) return new ConnectorUpper(this.color(), this.id);

            return new ConnectorLower(this.color(), this.id)
        }

        const color = this.color();

        switch (this.symbolType.name) {
            case "scalar":
                return new ScalarCell(color, this.id);
            case "vector":
                return new VectorCell(color, this.id);
            case "group":
                return new GroupCell(color, this.id);
            case "filter":
                return new FilterCell(color, this.id);
            default:
                return null;
        }
    }

    /**
     * Highlight the variable nodes *associated* with the cell, not the cell
     * itself. The default is for cells on the diagonal to highlight the
     * variable directly across from them.
     * @param {String} [varType = 'self'] Either 'self', 'source', or 'target'
     *   to indicate the variable name to highlight.
     * @param {String} [direction = 'self'] Either 'self', 'input', or 'output'
     *   to indicate the style of the highlighting.
     */
    highlight(varType = 'self', direction = 'self') {

        let obj = (varType == 'target') ? this.tgtObj : this.srcObj;
        if (obj.draw.filtered) { obj = obj.draw.filterParent; }
        const treeId = TreeNode.pathToId(obj.path);
        const treeNode = d3.select('rect#' + treeId);

        let fill = treeNode.style('fill');
        if (direction == 'input') fill = Style.color.inputArrow;
        else if (direction == 'output') fill = Style.color.outputArrow;

        d3.select('#highlight-bar').append('rect')
            .attr('x', 0)
            .attr('y', treeNode.node().parentNode.transform.baseVal[0].matrix.f)
            .attr('rx', 4)
            .attr('ry', 4)
            .attr('width', 8)
            .attr('height', treeNode.attr('height'))
            .attr('stroke', Style.color.treeStroke)
            .attr('fill', fill);
    }
}


/**
 * Use the model tree to build the matrix of variables and connections, display, and
 * perform operations with it.
 * @typedef Matrix
 * @property {TreeNodes[]} nodes Reference to nodes that will be drawn.
 * @property {ModelData} model Reference to the pre-processed model.
 * @property {Layout} layout Reference to object managing columns widths and such.
 * @property {Object} diagGroups References to <g> SVG elements created by Diagram.
 * @property {number} levelOfDetailThreshold Don't draw elements below this size in pixels.
 * @property {Object} nodeSize Width and height of each node in the matrix.
 * @property {Object} prevNodeSize Width and height of each node in the previous matrix.
 * @property {Object[][]} grid Object keys corresponding to rows and columns.
 * @property {MatrixCell[]} visibleCells One-dimensional array of all cells, for D3 processing.
 */
class Matrix {
    /**
     * Render the matrix of visible elements in the model.
     * @param {ModelData} model The pre-processed model data.
     * @param {Layout} layout Pre-computed layout of the diagram.
     * @param {Object} diagGroups References to <g> SVG elements created by Diagram.
     * @param {ArrowManager} arrowMgr Object to create and manage conn. arrows.
     * @param {Boolean} lastClickWasLeft
     * @param {function} findRootOfChangeFunction
     */
    constructor(model, layout, diagGroups, arrowMgr,
        lastClickWasLeft,
        findRootOfChangeFunction,
        prevNodeSize = {
            'width': 0,
            'height': 0
        }) {

        this.model = model;
        this.layout = layout;
        this.diagNodes = layout.visibleNodes;
        this.diagGroups = diagGroups;
        this.arrowMgr = arrowMgr;
        this.lastClickWasLeft = lastClickWasLeft;
        this.findRootOfChangeFunction = findRootOfChangeFunction;

        this.prevNodeSize = prevNodeSize;
        this.nodeSize = {
            'width': layout.size.matrix.width / this.diagNodes.length,
            'height': layout.size.matrix.height / this.diagNodes.length,
        }
        this.arrowMgr.setNodeSize(this.nodeSize);

        const markerSize = Math.max(2, this.nodeSize.width * .04, this.nodeSize.height * .04);
        d3.select("#arrow").attr("markerWidth", markerSize).attr("markerHeight", markerSize);
        d3.select("#offgridArrow").attr("markerWidth", markerSize * 2).attr("markerHeight", markerSize);

        this._init();
        
        this.updateLevelOfDetailThreshold(layout.size.matrix.height);

        this._buildGrid();
        this._setupVariableBoxesAndGridLines();
    }

    _init() {
        CellRenderer.updateDims(this.nodeSize.width, this.nodeSize.height);
    }

    get cellDims() { return CellRenderer.dims; }
    get prevCellDims() { return CellRenderer.prevDims; }

    /**
     * Determine if a node exists at the specified location.
     * @param {number} row Row number of the node
     * @param {number} col Column number of the node
     * @returns False if the row doesn't exist or a column doesn't exist
     *  in the row; true otherwise.
     */
    exists(row, col) {
        if (this.grid[row] && this.grid[row][col]) return true;
        return false;
    }

    /**
     * Make sure the cell is still part of the matrix and not an old one.
     * @param {MatrixCell} cell The cell to test.
     * @returns {Boolean} True if this.diagNodes has an object in the
     *   same row and column, and it matches the provided cell.
     */
    cellExists(cell) {
        return (this.exists(cell.row, cell.col) &&
            this.cell(cell.row, cell.col) === cell);
    }

    /**
     * Safe method to access a node/cell at the specified location.
     * Renamed from node() which is confusing with D3.
     * @param {number} row Row number of the node
     * @param {number} col Column number of the node
     * @param {boolean} doThrow Whether to throw an exception if node undefined.
     * @returns {MatrixCell} The node if it exists, undefined otherwise.
     */
    cell(row, col, doThrow = false) {
        if (this.exists(row, col)) {
            return this.grid[row][col];
        }
        else if (doThrow) {
            throw "No node in matrix at (" + row + ", " + col + ").";
        }

        return undefined;
    }

    /**
     * Given the id of the cell, try to find it in the visible matrix.
     * @param {String} cellId Unique string associated with the cell.
     * @returns {MatrixCell} Cell reference if found, otherwise undefined.
     */
    findCellById(cellId) {
        for (const cell of this.visibleCells) {
            if (cell.id == cellId) return cell;
        }

        return undefined;
    }

    /**
     * Given the node ID, determine if one of the cells in the matrix
     * represents it or contains it.
     * @param {Number} nodeId The id of the TreeNode to search for
     * @returns {Object} Contains reference to cell if found, and flags describing it.
     */
    findCellByNodeId(nodeId) {
        const node = this.model.nodeIds[nodeId];
        let ret = { 
            'cell': undefined,    // Changed to refer to a related cell if found
            'exactMatch': false,  // True if nodeId matches a cell
            'parentMatch': false, // True if nodeId's ancestor is a cell
            'childMatch': false   // True if nodeId's descendant is a cell
        }

        const debugStr = `${node.absPathName}(${nodeId})`

        // Less expensive to check entire matrix for direct matches first
        for (const row in this.grid) { // Check diagonals only
            const cell = this.grid[row][row];

            // Found directly:
            if (cell.id == MatrixCell.makeId(nodeId)) {
                debugInfo(`findCellByNodeId: Found ${debugStr} directly in matrix`)
                ret.cell = cell;
                ret.exactMatch = true
                return ret;
            }
        }

        // Only check for relationships if node not directly visible
        for (const row in this.grid) { // Check diagonals only
            const cell = this.grid[row][row];
            if (node.hasNodeInChildren(cell.obj)) {
                debugInfo(`findCellByNodeId: Found descendant of ${debugStr} in matrix`)
                ret.cell = cell;
                ret.childMatch = true
                return ret;
            }

            if (node.hasParent(cell.obj)) {
                debugInfo(`findCellByNodeId: Found ancestor of ${debugStr} in matrix`)
                ret.cell = cell;
                ret.parentMatch = true
                return ret;
            }
        }
    
        // Shouldn't really get here due to zoomedElement check at top
        debugInfo(`findCellByNodeId: ${debugStr} fell through all checks!`)
        return ret;
    }

    /**
     * Compute the new minimum element size when the diagram height changes.
     * @param {number} height In pixels.
     */
    updateLevelOfDetailThreshold(height) {
        this.levelOfDetailThreshold = height / 3;
    }

    /**
     * Compare the number of visible nodes to the amount allowed by
     * the threshold setting.
     */
    tooMuchDetail() {
        const tooMuch = (this.diagNodes.length >= this.levelOfDetailThreshold);

        if (tooMuch) debugInfo("Too much detail.")

        return tooMuch;
    }

    /**
     * Add a cell to the grid Object and visibleCells array.
     * @param {number} row Index of the row in the grid to place the cell.
     * @param {number} col Index of the column in the grid to place the cell.
     * @param {MatrixCell} newCell Cell created in _buildGrid().
     */
    _addCell(row, col, newCell) {
        this.grid[row][col] = newCell;
        this.visibleCells.push(newCell);
    }

    /**
     * Generate a new MatrixCell object. Can be overridden by subclass.
     * @param {Number} row Vertical coordinate of the cell in the matrix.
     * @param {Number} col Horizontal coordinate of the cell in the matrix.
     * @param {TreeNode} srcObj The node in the model tree this node is associated with.
     * @param {TreeNode} tgtObj The model tree node that this outputs to.
     * @param {ModelData} model Reference to the model to get some info from it.
     * @returns {MatrixCell} Newly created cell.
     */
    _createCell(row, col, srcObj, tgtObj, model) {
        return new MatrixCell(row, col, srcObj, tgtObj, model);
    }

    /**
     * Stub to be overridden by subclasses that need to add more info.
     * @param {Number} srcIdx Index of the diagonal node being processed.
     * @param {MatrixCell} newDiagCell A new cell being placed.
     */
    _customProcessing(srcIdx, newDiagCell) { }

    /**
     * Set up MatrixCell arrays resembling a two-dimensional grid as the matrix, but not
     * an actual two dimensional array because most of it would be unused. Each node
     * appearing on the diagonal is first added to the matrix. It's then checked for connections
     * to see if a connecting cell needs to be added or if the connection is going offscreen.
     * Additional processing tests collapsed and filtered nodes for connections.
     */
    _buildGrid() {
        this.visibleCells = [];
        this.grid = {};

        if (this.tooMuchDetail()) return;

        for (let srcIdx = 0; srcIdx < this.diagNodes.length; ++srcIdx) {
            const diagNode = this.diagNodes[srcIdx];

            // New row
            if (!this.grid.propExists(srcIdx)) this.grid[srcIdx] = {};

            // On the diagonal
            const newDiagCell = this._createCell(srcIdx, srcIdx, diagNode, diagNode, this.model);
            this._addCell(srcIdx, srcIdx, newDiagCell);

            for (const tgt of diagNode.targetParentSet) {
                const tgtNode = tgt.draw.filtered? tgt.draw.filterParent : tgt;
                const tgtIdx = indexFor(this.diagNodes, tgtNode);

                if (tgtIdx != -1 && srcIdx != tgtIdx) {
                    const newCell = this._createCell(srcIdx, tgtIdx, diagNode, tgtNode, this.model);
                    this._addCell(srcIdx, tgtIdx, newCell);
                }
                // Make sure tgt isn't descendant of zoomedElement, otherwise it's
                // visible at least as a collapsed node
                else if (tgt.isConnectable() && !this.layout.zoomedElement.hasNode(tgt)) {
                    newDiagCell.addOffScreenConn(diagNode, tgt);
                }
            }

            // Check for missing source part of connections
            for (const src of diagNode.sourceParentSet) {
                const srcNode = src.draw.filtered? src.draw.filterParent : src;

                if (indexFor(this.diagNodes, srcNode) == -1) {
                    // Make sure src isn't descendant of zoomedElement, otherwise it's
                    // visiable at least as a collapsed node
                    if (src.isConnectable() && !this.layout.zoomedElement.hasNode(src)) {
                        newDiagCell.addOffScreenConn(srcNode, diagNode);
                    }
                }
            }

            this._customProcessing(srcIdx, newDiagCell);
        }
    }

    /**
     * Determine which "box" a diagonal node is in based on common ancestors.
     * @param {Number} [ancestorLevel=2] The nth ancestor to compare.
     * @returns {Array} Box dimensions of the box containing each diagonal node.
     */
    _boxInfo(ancestorLevel = 2) {
        let currentBox = {
            "startI": 0,
            "stopI": 0
        };

        const boxInfo = [currentBox];

        // Find which variable box each of the variables belong in,
        // while finding the bounds of that box. Top and bottom
        // rows recorded for each node.
        for (let ri = 1; ri < this.diagNodes.length; ++ri) {
            const curNode = this.diagNodes[ri];
            const startINode = this.diagNodes[currentBox.startI];

            if (startINode.boxAncestor(ancestorLevel) === curNode.boxAncestor(ancestorLevel)) {
                ++currentBox.stopI;
            }
            else {
                currentBox = {
                    "startI": ri,
                    "stopI": ri
                };
            }
            boxInfo.push(currentBox);
        }

        return boxInfo;
    }

    /** Determine the size of the boxes that will enclose the variables of each group. */
    _setupVariableBoxesAndGridLines() {
        const boxInfo = this._boxInfo();

        // Step through boxInfo[] and record one set of dimensions
        // for each box in this._variableBoxInfo[].
        this._variableBoxInfo = [];
        for (let i = 0; i < boxInfo.length; ++i) {
            const box = boxInfo[i];
            if (box.startI == box.stopI) continue;

            const curNode = this.diagNodes[box.startI];
            if (!curNode.boxAncestor()) { continue; throw "Ancestor not found in box."; }

            box.obj = curNode.boxAncestor();
            if (box.obj.draw.varBoxDims) {
                box.obj.draw.varBoxDims.preserve().count = 1 + box.stopI - box.startI;
            }

            i = box.stopI;
            this._variableBoxInfo.push(box);
        }

        //do this so you save old index for the exit()
        this._gridLines = [];
        if (!this.tooMuchDetail()) {
            for (let i = 0; i < this.diagNodes.length; ++i) {
                const obj = this.diagNodes[i];
                const gl = { "i": i, "obj": obj };
                this._gridLines.push(gl);
            }
        }
    }

    /**
     * Add SVG groups & contents coupled to the visible nodes in the matrix.
     * Select all <g> elements that have class "n2cell". If any already
     * exist, join to their associated cells in the matrix. If no
     * existing <g> matches a displayable cell, add it to the "enter"
     * selection so the <g> can be created. If a <g> exists but there is
     * no longer a displayable cell for it, put it in the "exit" selection so
     * it can be removed.
     * @param {Dimensions} dims Size of a cell and placement within its group.
     */
    _drawCells(dims) {
        const self = this;

        this.diagGroups.elements.selectAll('g.n2cell')
            .data(this.visibleCells, d => d.id)
            .join(
                enter => self._addNewMatrixCells(enter, dims),
                update => self._updateExistingMatrixCells(update, dims),
                exit => self._removeOldMatrixCells(exit, dims)
            )
    }

    /**
     * Using the visible cells in the matrix grid as data points, create SVG objects to
     * represent each one. Location is calculated from a cell's column and row.
     * @param {Selection} enter The selection to add <g> elements and children to.
     * @param {Dimensions} dims Size of a cell and placement within its group.
     */
    _addNewMatrixCells(enter, dims) {
        const enterSelection = enter.append('g')
            .attr('class', 'n2cell');

        enterSelection
            // Initialize at "previous" location...
            .attr('transform', d => {
                const transX = dims.prev.width * (d.col - enterIndex) + dims.prev.x,
                    transY = dims.prev.height * (d.row - enterIndex) + dims.prev.y;

                return `translate(${transX},${transY})`;
            })
            .transition(sharedTransition)
            // ... then smoothly transition to new location to appear to slide in:
            .attr('transform', d => {
                const transX = dims.width * d.col + dims.x,
                    transY = dims.height * d.row + dims.y;

                return `translate(${transX},${transY})`;
            })
            .each(function(d) {
                // "this" refers to the element here, so leave it alone:
                d.renderer.renderCurrent(this)
                    .on('mouseover', d.getMouseoverFunc())
                    .on('mousemove', d.getMousemoveFunc())
                    .on('mouseleave', n2MouseFuncs.out)
                    .on('click', (e,d) => n2MouseFuncs.click(d))
            });
        
        return enterSelection;
    }

    /**
     * Update the geometry for existing SVG groups with a transition.
     * @param {Selection} update The selected group of existing matrix grid <g> elements.
     * @param {Dimensions} dims Size of the cell and placement within its group.
     */
    _updateExistingMatrixCells(update, dims) {
        update.transition(sharedTransition)
            .attr('transform', d => {
                const transX = dims.width * d.col + dims.x,
                    transY = dims.height * d.row + dims.y;

                return `translate(${transX},${transY})`;
            })
            // "this" refers to the element here, so leave it alone:
            .each(function (d) {
                d.renderer.updateCurrent(this)
            });
    }

    /**
     * Remove SVG groups that no longer have displayable cells associated with them, and
     * transition them away.
     * @param {Selection} exit The selected group of matrix grid <g> elements to remove.
     * @param {Dimensions} dims Size of the cell and placement within its group.
     */
    _removeOldMatrixCells(exit, dims) {
        const exitSelection = exit.transition(sharedTransition)
            .attr('transform', d => {
                const transX = dims.width * (d.col - exitIndex) + dims.x,
                    transY = dims.height * (d.row - exitIndex) + dims.y;

                return `translate(${transX},${transY})`
            })
            .each(function (d) { d.renderer.updateCurrent(this); });

        exitSelection.on('end', function() {d3.select(this).remove(); })

        return exitSelection;
    }

    /**
     * Draw a line above every row in the matrix.
     * @param {Dimensions} dims Sizes for a current and previous matrix cell.
     */
    _drawHorizontalLines(dims) {
        const self = this;

        self.diagGroups.gridlines.selectAll('g.horiz_line')
            .data(self._gridLines, d => d.obj.id)
            .join(
                enter => { 
                    const enterGroups = enter.append('g')
                        .attr('class', 'horiz_line')
                        .attr('transform', d => `translate(0, ${dims.prev.height * (d.i - enterIndex)})`);

                    enterGroups.transition(sharedTransition)
                        .attr('transform', d => `translate(0, ${dims.height * d.i})`)

                    enterGroups.append('line')
                        .attr('x2', self.layout.size.matrix.width)
                },
                update => update.transition(sharedTransition)
                    .attr('transform', d => `translate(0, ${dims.height * d.i})`)
                    .select('line')
                    .attr('x2', self.layout.size.matrix.width),
                exit => exit.transition(sharedTransition)
                    .attr('transform', d => `translate(0, ${dims.height * (d.i - exitIndex)})`)
                    .remove()
            )
    }

    /**
     * Draw a vertical line for every column in the matrix.
     * @param {Dimensions} dims Sizes for a current and previous matrix cell.
     */
     _drawVerticalLines(dims) {
        const self = this;

        self.diagGroups.gridlines.selectAll('g.vert_line')
        .data(self._gridLines, d => d.obj.id)
        .join(
            enter => { 
                const enterGroups = enter.append('g')
                    .attr('class', 'vert_line')
                    .attr('transform', d => `translate(${dims.prev.width * (d.i - enterIndex)}) rotate(-90)`);

                enterGroups.transition(sharedTransition)
                    .attr('transform', d => `translate(${dims.width * d.i}) rotate(-90)`)

                enterGroups.append('line')
                    .attr('x1', -self.layout.size.matrix.height)
            },
            update => update.transition(sharedTransition)
                .attr('transform', d => `translate(${dims.width * d.i}) rotate(-90)`)
                .select('line')
                .attr('x1', -self.layout.size.matrix.height),
            exit => exit.transition(sharedTransition)
                .attr('transform', d => `translate(0, ${dims.width * (d.i - exitIndex)}) rotate(-90)`)
                .remove()
        )

    }

    /** Draw boxes around the cells associated with each variable grouping. */
    _drawVariableBoxes(dims) {
        const self = this; 

        self.diagGroups.variableBoxes.selectAll('g.variable_box')
            .data(self._variableBoxInfo, d => d.obj.id)
            .join(
                enter => {
                    const newGroups = enter.append('g')
                        .attr('class', 'variable_box')
                        .attr('transform', d => {
                            const transX = dims.prev.width * (d.startI - enterIndex),
                                transY = dims.prev.height * (d.startI - enterIndex);
                            return `translate(${transX}, ${transY})`;
                        });

                    newGroups.transition(sharedTransition)
                        .attr('transform', d =>
                            `translate(${dims.width * d.startI}, ${dims.height * d.startI})`);

                    newGroups.append('rect')
                        .attr('width', d => dims.prev.width * (1 + d.stopI - d.startI))
                        .attr('height', d => dims.prev.height * (1 + d.stopI - d.startI))
                        .transition(sharedTransition)
                        .attr('width', d => dims.width * (1 + d.stopI - d.startI))
                        .attr('height', d => dims.height * (1 + d.stopI - d.startI));
                },
                update => {
                    update.transition(sharedTransition)
                        .attr('transform', d =>
                            `translate(${dims.width * d.startI}, ${dims.height * d.startI})`)

                    update.select('rect').transition(sharedTransition)
                        .attr('width', d => dims.width * (1 + d.stopI - d.startI))
                        .attr('height', d => dims.height * (1 + d.stopI - d.startI))
                },
                exit => {
                    exit.transition(sharedTransition)
                        .attr('transform', d => {
                            const transX = dims.width * (d.startI - exitIndex),
                              transY = dims.height * (d.startI - exitIndex);
                            return `translate(${transX}, ${transY})`;
                        })
                        .remove();                 
                }
            )
    }

    _preDraw(dims) {

    }

    /** Add all the visible elements to the matrix. */
    draw() {
        // Dimensions used to calculate cell geometry and gridlines
        const cellDims = new Dimensions(
            { // Current cell geometry:
                width: this.cellDims.size.width,
                height: this.cellDims.size.height,
                x: this.cellDims.bottomRight.x,
                y: this.cellDims.bottomRight.y   
            }, 
            null, 
            { // Previous cell geometry:
                width: this.prevCellDims.size.width,
                height: this.prevCellDims.size.height,
                x: this.prevCellDims.bottomRight.x,
                y: this.prevCellDims.bottomRight.y 
            }
        );

        const size = this.layout.size;

        d3.select("#n2MatrixClip > rect")
            .transition(sharedTransition)
            .attr('width', size.matrix.width + size.svgMargin * 2)
            .attr('height', size.matrix.height + size.svgMargin * 2);

        this._preDraw(cellDims);
        this._drawCells(cellDims);

        if (!this.tooMuchDetail()) {
            debugInfo("Drawing gridlines.")
            this._drawHorizontalLines(cellDims);
            this._drawVerticalLines(cellDims);
        }
        else {
            debugInfo("Erasing gridlines.")
            this.diagGroups.gridlines.selectAll('.horiz_line').remove();
            this.diagGroups.gridlines.selectAll(".vert_line").remove();
        }
        this._drawVariableBoxes(cellDims);
    }

    /**
     * Iterate through all the offscreen connection sets of the
     * hovered cell and draw an arrow/add a tooltip for each.
     */
    _drawOffscreenArrows(cell) {
        if (!cell.offScreen.total) return;

        for (const side in cell.offScreen) {
            for (const dir in cell.offScreen[side]) {
                for (const offscreenNode of cell.offScreen[side][dir]) {
                    this.arrowMgr.addOffGridArrow(cell.id, side, dir, {
                        'cell': {
                            'col': cell.row,
                            'row': cell.row,
                            'srcId': cell.srcObj.id,
                            'tgtId': cell.tgtObj.id
                        },
                        'matrixSize': this.diagNodes.length,
                        'label': offscreenNode.path,
                        'offscreenId': offscreenNode.id
                    });
                }
            }
        }
    }

    /**
     * For a cell that's on the diagonal, look for and draw connection arrows.
     * @param {MatrixCell} cell The on-diagonal cell to draw arrows for.
     * @returns {Array} The highlights that can optionally be performed.
     */
    drawOnDiagonalArrows(cell) {
        // Loop over all elements in the matrix looking for other cells in the same column
        this._drawOffscreenArrows(cell);
        const highlights = [{ 'cell': cell, 'varType': 'self', 'direction': 'self' }];

        this.layout.visibleNodes.forEach( (node, col) => {
            if (this.exists(cell.row, col)) {
                if (col != cell.row) {
                    this.arrowMgr.addFullArrow(cell.id, {
                        'end': {
                            'col': col,
                            'row': col,
                            'id': this.grid[col][col].srcObj.id
                        },
                        'start': {
                            'col': cell.row,
                            'row': cell.row,
                            'id': cell.tgtObj.id
                        },
                        'color': Style.color.outputArrow,
                    });

                    highlights.push({
                        'cell': this.cell(cell.row, col),
                        'varType': 'target', 'direction': 'output'
                    });
                }
            }

            // Now swap row and col
            if (this.exists(col, cell.row)) {
                if (col != cell.row) {
                    this.arrowMgr.addFullArrow(cell.id, {
                        'start': {
                            'col': col,
                            'row': col,
                            'id': this.grid[col][col].srcObj.id
                        },
                        'end': {
                            'col': cell.row,
                            'row': cell.row,
                            'id': cell.tgtObj.id
                        },
                        'color': Style.color.inputArrow,
                    });

                    highlights.push({
                        'cell': this.cell(col, cell.row),
                        'varType': 'source', 'direction': 'input'
                    });
                }
            }
        });

        return highlights;
    }

    /**
     * When the mouse goes over a cell that's on the diagonal, look for and
     * draw connection arrows, and highlight variable names.
     * @param {MatrixCell} cell The cell the event occured on.
     */
    mouseOverOnDiagonal(cell) {
        if (! d3.active(cell)) { // Don't do anything during transition
            const highlights = this.drawOnDiagonalArrows(cell);
            highlights.forEach(h => h.cell.highlight(h.varType, h.direction));
        }
    }

    /**
     * Look for and draw cycle arrows of the specified cell.
     * @param {MatrixCell} cell The off-diagonal cell to draw arrows for.
     */
    drawOffDiagonalArrows(cell) {
        this.arrowMgr.addFullArrow(cell.id, {
            'start': {
                'col': cell.row,
                'row': cell.row,
                'id': cell.srcObj.id
            },
            'end': {
                'col': cell.col,
                'row': cell.col,
                'id': cell.tgtObj.id
            },
            'color': Style.color.inputArrow,
        });
    }

    /**
     * When the mouse goes over a cell that's not on the diagonal, look for and
     * draw cycle arrows, and highlight variable names.
     * @param {MatrixCell} cell The cell the event occured on.
     */
    mouseOverOffDiagonal(cell) {
        // Don't do anything during transition:
        if (d3.active(cell)) return;

        this.drawOffDiagonalArrows(cell);

        cell.highlight('source', 'input');
        cell.highlight('target', 'output');
    }

    /**
     * Determine if a cell is on the diagonal or not and draw the appropriate
     * connection arrows.
     * @param {MatrixCell} cell The cell to operate on.
     */
    drawConnectionArrows(cell) {
        if (cell.row == cell.col) this.drawOnDiagonalArrows(cell);
        else this.drawOffDiagonalArrows(cell);
    }
}

/**
 * Manage CSS styles for various elements.
 * @typedef Style
 */
class Style {
    /** Define colors for each element type. Selected by Isaias Reyes */
    static color = {
        'connection': 'gray',
        'background': '#eee',
        'gridline': 'white',
        'treeStroke': '#eee',
        'outputGroup': '#888',
        'output': '#888',
        'input': '#30B0AD',
        'inputGroup': 'Orchid',
        'group': '#6092B5',
        'collapsed': '#555555',
        'collapsedText': 'white',
        'filter': '#555555',
        'unconnectedInput': '#F42F0D',
        'inputArrow': 'salmon',
        'outputArrow': 'seagreen',
        'variableBox': '#555',
    };

    /**
     * Initialize the Style object.
     * @param {Object} svgStyle A reference to the SVG style section, which will be rewritten.
     * @param {Number} fontSize The font size to apply to text styles.
     */
    constructor(svgStyle, fontSize) {
        this.svgStyle = svgStyle;

        this._init();
        this.updateSvgStyle(fontSize);
    }

    /** A stub for subclasses to perform initialization. */
    _init() { }

    /**
     * Associate selectors with various style attributes.
     * @param {Number} fontSize The font size to apply to text styles.
     * @returns {Object} An object with selectors as keys, and values that are also objects,
     *     with style attributes as keys and values as their settings.
     */
    _createStyleObj(fontSize) {
        const newCssJson = {
            'rect': {
                'stroke': Style.color.treeStroke,
            },
            '#tree > g.input > rect': {
                'fill': Style.color.input,
                'fill-opacity': '.8',
            },
            '#tree > g.unconnected_input > rect': {
                'fill': Style.color.unconnectedInput,
                'fill-opacity': '.8',
            },
            '#tree > g.input_group > rect': {
                'cursor': 'pointer',
                'fill-opacity': '.8',
                'fill': Style.color.inputGroup,
            },
            '#tree > g.output > rect': {
                'cursor': 'pointer',
                'fill-opacity': '.8',
                'fill': Style.color.output,
            },
            '#tree > g.group > rect': {
                'cursor': 'pointer',
                'fill-opacity': '.8',
                'fill': Style.color.group,
            },
            '#tree > g.output_group > rect': {
                'cursor': 'pointer',
                'fill-opacity': '.8',
                'fill': Style.color.outputGroup,
            },
            '#tree > g.minimized > rect': {
                'cursor': 'pointer',
                'fill-opacity': '.8',
                'fill': Style.color.collapsed,
            },
            '#tree > g.minimized > text': {
                'fill': Style.color.collapsedText,
            },
            /* 'text': {
                //'dominant-baseline: middle',
                //'dy: .35em',
            }, */
            'g.model_tree_grp > text': {
                'text-anchor': 'end',
                'pointer-events': 'none',
                'font-family': 'helvetica, sans-serif',
                'font-size': fontSize + 'px',
            },
            'text.offgridLabel': {
                'font-family': 'helvetica, sans-serif',
                'font-size': fontSize + 'px',
            },
            '.bordR1, .bordR2, .bordR3, .bordR4, .ssMid, .grpMid, .svMid, .vsMid, .vMid, .sgrpMid, .grpsMid': {
                'stroke': 'none',
                'stroke-width': '0',
                'fill-opacity': '1',
            },
            '[class^=n2_hover_elements]': {
                'pointer-events': 'none',
            },
            '.background': {
                'fill': Style.color.background,
            },
            '.horiz_line, .vert_line': {
                'stroke': Style.color.gridline,
            },
            "g.model_tree_grp > rect[id*='_FILTER_'] + text": {
                'font-style': 'italic'
            },
            'g.variable_box > rect': {
                'stroke': Style.color.variableBox,
                'stroke-width': '2',
                'fill': 'none',
            }
        };

        return newCssJson;
    }

    /**
     * Replace the entire content of the SVG style section with new styles.
     * Doing a wholesale replace is easier than finding each style element,
     * deleting, and inserting a new one.
     * @param {number} fontSize In pixel units.
     */
    updateSvgStyle(fontSize) {
        // Define as JSON first
        const newCssJson = this._createStyleObj(fontSize);

        // Iterate over the JSON object just created and turn it into
        // CSS style sheet text.
        let newCssText = '';
        for (const selector in newCssJson) {
            newCssText += `${selector} {\n`;
            for (const attrib in newCssJson[selector]) {
                newCssText +=
                    `    ${attrib}: ${newCssJson[selector][attrib]};\n`;
            }
            newCssText += '}\n\n';
        }

        this.svgStyle.html(newCssText);
    }

    /**
       * Based on the element's type and conditionally other info, determine
       * what CSS style is associated.
       * @param {TreeNode} node The item to check.
       * @return {string} The name of an existing CSS class.
       */
    getNodeClass(node) {
        if (node.draw.minimized) return 'minimized';

        switch (node.type) {
            case 'input':
                if (Array.isPopulatedArray(node.children)) return 'input_group';
                return 'input';

            case 'unconnected_input':
                if (Array.isPopulatedArray(node.children)) return 'input_group';
                return 'unconnected_input';

            case 'filter':
                return 'filter';

            case 'output':
                if (Array.isPopulatedArray(node.children)) return 'output_group';
                return 'output';

            case 'root':
                return 'group';

            case 'group':
                return 'group';

            default:
                throw `CSS class not found for node type: ${node.type}`
        }
    }
}


/**
 * Manage all pieces of the application. The model data, the CSS styles, the
 * user interface, the layout of the matrix, and the matrix grid itself are
 * all member objects.
 * @typedef Diagram
 * @property {ModelData} model Processed model data received from Python.
 * @property {Style} style Manages diagram-related styles and functions.
 * @property {Layout} layout Sizes and positions of visible elements.
 * @property {Matrix} matrix Manages the grid of visible model parameters.
 * @property {TreeNode} zoomedElement The element the diagram is currently based on.
 * @property {TreeNode} zoomedElementPrev Reference to last zoomedElement.
 * @property {Object} dom Container for references to web page elements.
 * @property {Object} dom.svgDiv The div containing the SVG element.
 * @property {Object} dom.svg The SVG element.
 * @property {Object} dom.svgStyle Object where SVG style changes can be made.
 * @property {Object} dom.toolTip Div to display tooltips.
 * @property {Object} dom.diagOuterGroup The outermost div of the diagram itself.
 * @property {Object} dom.diagGroups References to <g> SVG elements.
 * @property {number} chosenCollapseDepth The selected depth from the drop-down.
 */
class Diagram {
    /**
     * Set initial values.
     * @param {Object} modelJSON The decompressed model structure.
     * @param {Boolean} [callInit = true] Whether to run _init() now.
     */
    constructor(modelJSON, callInit = true) {
        this.modelData = modelJSON;
        this._newModelData();
        this.zoomedElement = this.zoomedElementPrev = this.model.root;
        this.manuallyResized = false; // If the diagram has been sized by the user

        // Assign this way because defaultDims is read-only.
        this.dims = {...defaultDims};

        this._referenceD3Elements();
        this.transitionStartDelay = transitionDefaults.startDelay;
        this.chosenCollapseDepth = -1;

        this.search = new Search(this.zoomedElement, this.model.root);
        this.arrowMgr = new ArrowManager(this.dom.diagGroups);

        if (callInit) { this._init(); }
    }

    _newModelData() {
        this.model = new ModelData(this.modelData);
    }

    /** Create a Layout object. Can be overridden to create different types of Layouts */
    _newLayout() {
        return new Layout(this.model, this.zoomedElement, this.dims);
    }

    /** Create a Matrix object. Can be overridden by subclasses */
    _newMatrix(lastClickWasLeft, prevCellSize = null) {
        return new Matrix(this.model, this.layout, this.dom.diagGroups,
            this.arrowMgr, lastClickWasLeft, this.ui.findRootOfChangeFunction, prevCellSize);
    }

    /**
     * Separate these calls from the constructor so that subclasses can
     * set values before execution.
     */
    _init() {
        this.style = new Style(this.dom.svgStyle, this.dims.size.font);
        this.layout = this._newLayout();
        this.ui = new UserInterface(this);
        this.matrix = this._newMatrix(true);
    }

    /**
     * Setup internal references to D3 objects so we can avoid running
     * d3.select() over and over later.
     */
     _referenceD3Elements() {
        this.dom = {
            'svgDiv': d3.select("#svgDiv"),
            'svg': d3.select("#svgId"),
            'svgStyle': d3.select("#svgId style"),
            'toolTip': d3.select(".tool-tip"),
            'arrowMarker': d3.select("#arrow"),
            'diagOuterGroup': d3.select('g#n2outer'),
            'diagInnerGroup': d3.select('g#n2inner'),
            'pTreeGroup': d3.select('g#tree'),
            'highlightBar': d3.select('g#highlight-bar'),
            'diagBackgroundRect': d3.select('g#n2inner rect'),
            'waiter': d3.select('#waiting-container'),
            'clips': {
                'partitionTree': d3.select("#partitionTreeClip > rect"),
                'n2Matrix': d3.select("#n2MatrixClip > rect"),
            }
        };

        const diagGroups = {};
        this.dom.diagInnerGroup.selectAll('g').each(function () {
            const d3elem = d3.select(this);
            const name = new String(d3elem.attr('id')).replace(/n2/, '');
            diagGroups[name] = d3elem;
        })
        this.dom.diagGroups = diagGroups;

        const offgrid = {};
        this.dom.diagOuterGroup.selectAll('g.offgridLabel').each(function () {
            const d3elem = d3.select(this);
            const name = new String(d3elem.attr('id')).replace(/n2/, '');
            offgrid[name] = d3elem;
        })
        this.dom.diagGroups.offgrid = offgrid;
    }

    /**
     * Save the SVG to a filename selected by the user.
     * TODO: Use a proper file dialog instead of a simple prompt.
     */
     saveSvg() {
        let svgData = this.dom.svg.node().outerHTML;

        // Add name spaces.
        if (!svgData.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)) {
            svgData = svgData.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
        }
        if (!svgData.match(/^<svg[^>]+"http\:\/\/www\.w3\.org\/1999\/xlink"/)) {
            svgData = svgData.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
        }

        // Add XML declaration
        svgData = '<?xml version="1.0" standalone="no"?>\r\n' + svgData;

        svgData = vkbeautify.xml(svgData);
        const svgBlob = new Blob([svgData], {
            type: "image/svg+xml;charset=utf-8"
        });
        const svgUrl = URL.createObjectURL(svgBlob);
        const downloadLink = document.createElement("a");
        downloadLink.href = svgUrl;

        // To suggest a filename to save as, get the basename of the current HTML file,
        // remove the .html/.htm extension, and add ".svg".
        const svgFileName = basename() + ".svg";
        downloadLink.download = svgFileName;
        
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
    }

    /**
     * Recurse and pull state info from model for saving.
     * @param {Array} dataList Array of objects with state info for each node.
     * @param {TreeNode} node The current node being examined.
     */
     getSubState(dataList, node = this.model.root) {
        if (node.isFilter()) return; // Ignore state for FilterNodes

        dataList.push(node.getStateForSave());

        if (node.hasChildren()) {
            for (const child of node.children) {
                this.getSubState(dataList, child);
            }
        }
    }

    /**
     * Recurse and set state info into model.
     * @param {Array} dataList Array of objects with state info for each node. 
     * @param {TreeNode} node The node currently being restored.
     */
    setSubState(dataList, node = this.model.root) {
        if (node.isFilter()) return; // Ignore state for FilterNodes

        node.setStateFromLoad(dataList.pop());

        // Get rid of any existing filters before processing children, as they'll
        // be populated while processing the state of each child node.
        if (node.hasFilters()) { node.wipeFilters(); }

        if (node.hasChildren()) {
            for (const child of node.children) {
                this.setSubState(dataList, child);
            }
        }
    }

    /**
     * Replace the current zoomedElement, but preserve its value.
     * @param {Object} newZoomedElement Replacement zoomed element.
     */
    updateZoomedElement(newZoomedElement) {
        this.zoomedElementPrev = this.zoomedElement;
        this.zoomedElement = newZoomedElement;
        this.layout.zoomedElement = this.zoomedElement;
    }


    /**
     * The mouse interface to the diagram can be in normal left-click mode, node info mode,
     * expand/collapse mode, or variable filter mode. This function performs the correct callback.
     * @param {Object} obj The HTML element that was clicked on.
     * @param {TreeNode} node The node associated with the element.
     */
    leftClickSelector(e, node) {
        switch (this.ui.click.clickEffect) {
            case ClickHandler.ClickEffect.NodeInfo:
                this.ui.pinInfoBox();
                break;
            case ClickHandler.ClickEffect.Collapse:
                this.ui.rightClick(e, node, e.currentTarget);
                break;
            case ClickHandler.ClickEffect.Filter:
                const color = d3.select(e.currentTarget).select('rect').style('fill');
                this.ui.altRightClick(e, node, color);
                break;
            default:
                this.ui.leftClick(e, node);
        }
    }

    /**
     * Add SVG groups & contents coupled to the visible nodes in the model tree.
     * Select all <g> elements that have class "model_tree_grp". If any already
     * exist, join to their associated nodes in the model tree. If no
     * existing <g> matches a displayable node, add it to the "enter"
     * selection so the <g> can be created. If a <g> exists but there is
     * no longer a displayable node for it, put it in the "exit" selection so
     * it can be removed.
     */
    _updateTreeCells() {
        const self = this;
        const scale = this.layout.scales.model;
        const treeSize = this.layout.treeSize.model;

        this.dom.pTreeGroup.selectAll("g.model_tree_grp")
            .data(this.layout.zoomedNodes, d => d.id)
            .join(
                enter => self._addNewTreeCells(enter, scale, treeSize),
                update => self._updateExistingTreeCells(update, scale, treeSize),
                exit => self._removeOldTreeCells(exit, scale, treeSize)
            )
    }

    /**
     * Using the visible nodes in the model tree as data points, create SVG objects to
     * represent each one. Dimensions are obtained from the precalculated layout.
     * @param {Selection} enter The selection to add <g> elements and children to.
     * @param {Scale} scale Linear scales of the diagram width and height.
     * @param {Dimensions} treeSize Actual width and height of the tree in pixels.
     */
     _addNewTreeCells(enter, scale, treeSize) {
        const self = this; // For callbacks that might change "this".
      
        // Create a <g> for each node in zoomedNodes that doesn't already have one. Dimensions
        // are obtained from the previous geometry so the new nodes can appear to transition
        // to the new size together with the existing nodes.
        const enterSelection = enter
            .append("g")
            .attr("class", d => `model_tree_grp ${self.style.getNodeClass(d)}`)
            .attr("transform", d =>
                `translate(${scale.prev.x(d.draw.dims.prev.x)},${scale.prev.y(d.draw.dims.prev.y)})`)
            .on("click", (e,d) => self.leftClickSelector(e, d))
            .on("contextmenu", function(e,d) {
                if (e.altKey) {
                    self.ui.altRightClick(e, d, d3.select(this).select('rect').style('fill'));
                }
                else {
                    self.ui.rightClick(e, d);
                }
            })
            .on("mouseover", (e,d) => self.ui.showInfoBox(e, d))
            .on("mouseleave", () => self.ui.removeInfoBox())
            .on("mousemove", e => self.ui.moveInfoBox(e));

        enterSelection
            .transition(sharedTransition)
            .attr("transform", d =>
                `translate(${scale.x(d.draw.dims.x)},${scale.y(d.draw.dims.y)})`)

        // Add the rectangle that is the visible shape.
        enterSelection
            .append("rect")
            .attr("id", d => TreeNode.pathToId(d.path))
            .attr('rx', 12)
            .attr('ry', 12)
            .transition(sharedTransition)
            .attr("width", d => d.draw.dims.width * treeSize.width)
            .attr("height", d => d.draw.dims.height * treeSize.height);

        // Add a label
        enterSelection
            .append("text")
            .text(d => d.getTextName())
            .style('visibility', 'hidden')
            .attr("dy", ".35em")
            .attr("transform", d => {
                const anchorX = d.draw.dims.width * treeSize.width -
                    self.layout.size.rightTextMargin;
                return `translate(${anchorX}, ${(d.draw.dims.height * treeSize.height / 2)})`;
            })
            .style("opacity", d => (d.depth < self.zoomedElement.depth)? 0 : d.textOpacity)
            .transition(sharedTransition)
            .on('end', function() { d3.select(this).style('visibility', 'visible'); } )

        return enterSelection;
    }

    /**
     * Update the geometry for existing <g> with a transition.
     * @param {Selection} update The selected group of existing model tree <g> elements.
     * @param {Scale} scale Linear scales of the diagram width and height.
     * @param {Dimensions} treeSize Actual width and height of the tree in pixels.
     */
     _updateExistingTreeCells(update, scale, treeSize) {
        const self = this; // For callbacks that change "this".

        this.dom.clips.partitionTree
            .transition(sharedTransition)
            .attr('height', this.dims.size.partitionTree.height);

        // New location for each group
        const mergedSelection = update
            .attr("class", d => `model_tree_grp ${self.style.getNodeClass(d)}`)
            .transition(sharedTransition)
            .attr("transform", d => 
                `translate(${scale.x(d.draw.dims.x)} ${scale.y(d.draw.dims.y)})`);

        // Resize each rectangle
        mergedSelection
            .select("rect")
            .attr("width", d => d.draw.dims.width * treeSize.width)
            .attr("height", d => d.draw.dims.height * treeSize.height);

        // Move the text label
        mergedSelection
            .select("text")
            .attr("transform", d => {
                const anchorX = d.draw.dims.width * treeSize.width -
                    self.layout.size.rightTextMargin;
                return `translate(${anchorX} ${(d.draw.dims.height * treeSize.height/2)})`;
            })
            .style("opacity", d => (d.depth < self.zoomedElement.depth)? 0 : d.textOpacity);

        return mergedSelection;
    }

    /**
     * Remove <g> that no longer have displayable nodes associated with them, and
     * transition them away.
     * @param {Selection} exit The selected group of model tree <g> elements to remove.
     * @param {Scale} scale Linear scales of the diagram width and height.
     * @param {Dimensions} treeSize Actual width and height of the tree in pixels.
     */
    _removeOldTreeCells(exit, scale, treeSize) {
        const self = this; // For callbacks that change "this". Alternative to using .bind().

        // Transition exiting nodes to the parent's new position.
        const exitSelection = exit.transition(sharedTransition)
            .attr("transform", d => 
                `translate(${scale.x(d.draw.dims.x)} ${scale.y(d.draw.dims.y)})`);

        exitSelection.select("rect")
            .attr("width", d => d.draw.dims.width * treeSize.width)
            .attr("height", d => d.draw.dims.height * treeSize.height)

        exitSelection.select("text")
            .attr("transform", d => {
                const anchorX = d.draw.dims.width * treeSize.width -
                    self.layout.size.rightTextMargin;
                return `translate(${anchorX}, ${(d.draw.dims.height * treeSize.height / 2)})`;
            })
            .style("opacity", 0)

        exitSelection.on('end', function() {d3.select(this).remove(); })

        return exitSelection;
    }

    /** Remove all rects in the highlight bar */
    clearHighlights() {
        const selection = this.dom.highlightBar.selectAll('rect');
        const size = selection.size();
        debugInfo(`clearHighlights: Removing ${size} highlights`);
        selection.remove();
    }

    /** Remove all pinned arrows */
    clearArrows() {
        this.arrowMgr.removeAllPinned();
        this.clearHighlights();
    }

    /** Display connection arrows for all visible inputs/outputs */
    showAllArrows() {
        for (const row in this.matrix.grid) {
            const cell = this.matrix.grid[row][row]; // Diagonal cells only
            this.matrix.drawOnDiagonalArrows(cell);
            this.arrowMgr.togglePin(cell.id, true);
        }
    }

    /**
     * Sleep for the specified number of milliseconds.
     * @param {Number} time Milliseconds to return after
     * @returns {Promise} Promise that can be awaited on until the timer expires.
     */
    delay(time) {
        return new Promise(function(resolve) {
            setTimeout(resolve, time)
        });
     }

    /** Display an animation while the transition is in progress */
    showWaiter() { this.dom.waiter.attr('class', 'show'); }

    /** Hide the animation after the transition completes */
    hideWaiter() { this.dom.waiter.attr('class', 'no-show'); }

    /**
     * Refresh the diagram when something has visually changed.
     * @param {Boolean} [computeNewTreeLayout = true] Whether to rebuild the layout and
     *  matrix objects.
     */
    async update(computeNewTreeLayout = true) {
        this.showWaiter();
        await this.delay(100);

        this.ui.update();
        this.search.update(this.zoomedElement, this.model.root);

        // Compute the new tree layout if necessary.
        if (computeNewTreeLayout) {
            this.layout = this._newLayout();
            this.ui.updateClickedIndices();
            this.matrix = this._newMatrix(this.ui.lastClickWasLeft, this.matrix.nodeSize);
        }

        this.layout.updateGeometry(this.dom);
        this.layout.updateTransitionInfo(this.dom, this.transitionStartDelay, this.manuallyResized);
        this._updateTreeCells();
        this.arrowMgr.transition(this.matrix);
        this.matrix.draw();

        if (!d3.selection.prototype.transitionAllowed) this.hideWaiter();
    }

    /**
     * Updates the intended dimensions of the diagrams and font, but does
     * not perform rendering itself.
     * @param {number} height The base height of the diagram without margins.
     * @param {number} fontSize The new size of the font.
     */
     updateSizes(height, fontSize) {
        let gapSize = fontSize + 4;

        this.dims.size.matrix.margin = gapSize;
        this.dims.size.partitionTreeGap = gapSize;

        this.dims.size.matrix.height =
            this.dims.size.matrix.width = // Match base height, keep it looking square
            this.dims.size.partitionTree.height = height;

        this.dims.size.font = fontSize;
    }

    /**
     * Adjust the height and corresponding width of the diagram based on user input.
     * @param {number} height The new height in pixels.
     */
     verticalResize(height) {
        // Don't resize if the height didn't actually change:
        if (this.dims.size.partitionTree.height == height) return;

        if (!this.manuallyResized) {
            height = this.layout.calcFitDims().height;
        }

        this.updateSizes(height, this.dims.size.font);

        transitionDefaults.duration = transitionDefaults.durationFast;
        this.update();
    }

    /**
     * Adjust the font size of all text in the diagram based on user input.
     * @param {number} fontSize The new font size in pixels.
     */
     fontSizeSelectChange(fontSize) {
        transitionDefaults.duration = transitionDefaults.durationFast;
        this.style.updateSvgStyle(fontSize);
        this.update();
    }

    /**
     * Since the matrix can be destroyed and recreated, use this to invoke the callback
     * rather than setting one up that points directly to a specific matrix.
     * @param {MatrixCell} cell The cell the event occured on.
     */
    mouseOverOnDiagonal(e, cell) {
        if (this.matrix.cellExists(cell)) {
            this.matrix.mouseOverOnDiagonal(cell);
            this.ui.showInfoBox(e, cell.obj, cell.color(), false);
        }
    }

    /**
     * Move the node info panel around if it's visible
     * @param {MatrixCell} cell The cell the event occured on.
     */
    mouseMoveOnDiagonal(e, cell) {
        if (this.matrix.cellExists(cell)) {
            this.ui.moveInfoBox(e);
        }
    }

    /**
     * Since the matrix can be destroyed and recreated, use this to invoke the callback
     * rather than setting one up that points directly to a specific matrix.
     */
    mouseOverOffDiagonal(e, cell) {
        if (this.matrix.cellExists(cell)) {
            this.matrix.mouseOverOffDiagonal(cell);
            this.ui.showCellInfoBox(e, cell, cell.color(), true);
        }
    }

    /** When the mouse leaves a cell, remove all temporary arrows and highlights. */
    mouseOut() {
        this.arrowMgr.removeAllHovered();
        this.clearHighlights();
        d3.selectAll("div.offgrid").style("visibility", "hidden").html('');

        this.ui.removeInfoBox();
    }

    /**
     * When the mouse is left-clicked on a cell, change their CSS class
     * so they're not removed when the mouse moves out. Or, if in info panel
     * mode, pin the info panel.
     * @param {MatrixCell} cell The cell the event occured on.
     */
    mouseClick(cell) {
        if (! this.ui.click.isNodeInfo) { // If not in info-panel mode, pin/unpin arrows
            this.arrowMgr.togglePin(cell.id);
        }
        else { // Make a persistent info panel
            this.ui.pinInfoBox();
        }
    }

    /**
     * Place member mouse callbacks in an object for easy reference.
     * @returns {Object} Object containing each of the functions.
     */
    getMouseFuncs() {
        const self = this;

        const mf = {
            'overOffDiag': self.mouseOverOffDiagonal.bind(self),
            'overOnDiag': self.mouseOverOnDiagonal.bind(self),
            'moveOnDiag': self.mouseMoveOnDiagonal.bind(self),
            'out': self.mouseOut.bind(self),
            'click': self.mouseClick.bind(self)
        }

        return mf;
    }

    /**
     * Set the new depth to collapse to and perform the operation.
     * @param {Number} depth If the node's depth is the same or more, collapse it.
     */
     minimizeToDepth(depth) {
        this.chosenCollapseDepth = depth;

        if (depth > this.zoomedElement.depth)
            this.model.minimizeToDepth(this.model.root, depth);
    }

    /** Unset all manually-selected node states and zoom to the root element */
    reset() {
        this.model.resetAllHidden([]);
        this.updateZoomedElement(this.model.root);
        transitionDefaults.duration = transitionDefaults.durationFast;
        this.update();
    }

    /**
     * Using an object populated by loading and validating a JSON file, set the model
     * to the saved view.
     * @param {Object} oldState The model view to restore.
     */
     restoreSavedState(oldState) {
        // Zoomed node
        this.zoomedElement = this.model.nodeIds[oldState.zoomedElement];

        // Expand/Collapse state of all group nodes in model.
        this.setSubState(oldState.expandCollapse.reverse());

        // Force an immediate display update.
        // Needed to do this so that the arrows don't slip in before the element zoom.
        this.layout = this._newLayout();
        this.ui.updateClickedIndices();
        this.matrix = this._newMatrix(this.ui.findRootOfChangeFunction, this.matrix.nodeSize);
        this.layout.updateGeometry(this.dom);
        this.layout.updateTransitionInfo(this.dom, this.transitionStartDelay, this.manuallyResized);

        // Arrow State
        this.arrowMgr.loadPinnedArrows(oldState.arrowState);
    }
}
 



/**
 * Calculates and stores the size and positions of visible elements.
 * @typedef OmLayout
 * @property {ModelData} model Reference to the preprocessed model.
 * @property {OmTreeNode} zoomedElement Reference to zoomedElement managed by Diagram.
 * @property {OmTreeNode[]} zoomedNodes  Child workNodes of the current zoomed element.
 * @property {OmTreeNode[]} visibleNodes Zoomed workNodes that are actually drawn.
 * @property {OmTreeNode[]} zoomedSolverNodes Child solver workNodes of the current zoomed element.
 * @property {Object} svg Reference to the top-level SVG element in the document.
 * @property {Object} size The dimensions of the model and solver trees.
 */
class OmLayout extends Layout {
    /**
     * Compute the new layout based on the model data and the zoomed element.
     * @param {ModelData} model The pre-processed model object.
     * @param {Object} newZoomedElement The element the new layout is based around.
     * @param {Object} dims The initial sizes for multiple tree elements.
     * @param {Boolean} showSolvers Whether to display the solver tree.
     */
    constructor(model, zoomedElement, dims, showSolvers) {
        super(model, zoomedElement, dims, false);

        this.zoomedSolverNodes = [];
        this.visibleSolverNodes = [];
        this.showSolvers = showSolvers;
        this._init();
    }

    /** Set up the solver tree layout. */
    _init() {
        super._init();
        if (this.showSolvers) {
            this._computeSolverColumnWidths();
            this._setColumnLocations(this.size.solverTree, this.solverCols);
            this._computeSolverNormalizedPositions(this.model.root, 0, false, null);
            if (this.zoomedElement.parent) {
                this.zoomedSolverNodes.push(this.zoomedElement.parent);
            }

            this.scales.solver = new Scale(this.size.solverTree);
        }

        this.treeSize.solver = new Dimensions({width: 0, height: 0});

        return this;
    }

    /**
     * Determine text widths for all descendents of the specified node.
     * @param {OmTreeNode} [node = this.zoomedElement] Item to begin looking from.
     */
     _updateTextWidths(node = this.zoomedElement) {
        if (node.draw.hidden) return;
        super._updateTextWidths(node);

        if (!node.isInputOrOutput() && !node.isFilter()) {
            node.draw.nameSolverWidthPx = this._getTextWidth(node.getSolverText()) + 2 *
                this.size.rightTextMargin;
        }
    }

    /**
     * Compute solver column widths across the model, then adjust ends as needed.
     * @param {OmTreeNode} [node = this.zoomedElement] Item to operate on.
     */
     _computeSolverColumnWidths(node = this.zoomedElement) {
        this.greatestDepth = 0;
        this.leafSolverWidthsPx = new Array(this.model.maxDepth + 1).fill(0.0);
        this.solverCols = Array.from({length: this.model.maxDepth + 1},
            () => ({ 'width': 0.0, 'location': 0.0 }));

        this._setColumnWidthsFromWidestText(node, 'subsystem_children', this.solverCols,
            this.leafSolverWidthsPx, 'nameSolverWidthPx');

        let sum = 0;
        let lastColumnWidth = 0;
        for (let i = this.leafSolverWidthsPx.length - 1; i >= this.zoomedElement.depth; --i) {
            sum += this.solverCols[i].width;
            const lastWidthNeeded = this.leafSolverWidthsPx[i] - sum;
            lastColumnWidth = Math.max(lastWidthNeeded, lastColumnWidth);
        }

        this.solverCols[this.zoomedElement.depth - 1].width = this.size.parentNodeWidth;
        this.solverCols[this.greatestDepth].width = lastColumnWidth;
    }


    /*
     * TODO: _computeNormalizedPositions and _computeSolverNormalizedPositions do almost
     * identical things, just storing info in different variables, so they should be
     * merged as much as possible.
     */

    /**
     * Recurse over the model tree and determine the coordinates and size of visible
     * solver nodes. If a parent is minimized, operations are performed on it instead.
     * @param {OmTreeNode} node The node to operate on.
     * @param {number} leafCounter Tally of leaves encountered so far.
     * @param {Boolean} isChildOfZoomed Whether node is a descendant of this.zoomedElement.
     * @param {Object} earliestMinimizedParent The minimized parent, if any, appearing
     *   highest in the tree hierarchy. Null if none exist.
     */
     _computeSolverNormalizedPositions(node, leafCounter,
        isChildOfZoomed, earliestMinimizedParent) {

        // Fix until solver display is removed entirely from generic code:
        if (!(node instanceof OmTreeNode)) return;

        if (!isChildOfZoomed) {
            isChildOfZoomed = (node === this.zoomedElement);
        }

        if (earliestMinimizedParent == null && isChildOfZoomed) {
            if (node.type.match(/^(subsystem|root)$/)) {
                this.zoomedSolverNodes.push(node);
            }
            if (node.isVisibleLeaf()) { //at a "leaf" workNode
                if (!node.isInput()) {
                    this.visibleSolverNodes.push(node);
                }
                earliestMinimizedParent = node;
            }
            else if (node.draw.filtered) {
                earliestMinimizedParent = node.draw.filterParent;
            }
        }

        node.preserveSolverDims(leafCounter);
        const workNode = (earliestMinimizedParent) ? earliestMinimizedParent : node;
        const dims = node.draw.solverDims;

        if (! node.isVisible()) { //input or hidden leaf leaving
            dims.x = this.cols[node.parentComponent.depth + 1].location /
                this.size.partitionTree.width;
            dims.y = node.parentComponent.draw.dims.y;
            dims.width = 1e-6;
            dims.height = 1e-6;
        }
        else {
            dims.x = this.solverCols[workNode.depth].location / this.size.solverTree.width;
            dims.y = leafCounter / this.model.root.draw.numLeaves;
            dims.width = (node.subsystem_children && !node.draw.minimized) ?
                (this.solverCols[workNode.depth].width / this.size.solverTree.width) :
                1 - workNode.draw.solverDims.x;
    
            dims.height = workNode.draw.numLeaves / this.model.root.draw.numLeaves;
        }

        if (node.hasChildren()) {
            for (const child of node.children) {
                if (!child.isInputOrOutput() || !child.draw.minimized) {
                    this._computeSolverNormalizedPositions(child,
                        leafCounter, isChildOfZoomed,
                        child.draw.filterParent? child.draw.filterParent : earliestMinimizedParent);
                    if (earliestMinimizedParent == null) { //numleaves is only valid passed nonminimized nodes
                        leafCounter += child.draw.numLeaves;
                    }
                }
            }
        }
    }

    /**
     * Calculate new dimensions for the div element enclosing the main SVG element.
     * @returns {Dimensions} Members width and height.
     */
     calcOuterDims() {
        const dims = super.calcOuterDims();
        if (this.showSolvers) dims.width += this.size.solverTree.width;

        return dims;
    }

    /**
     * Calculate new dimensions for the main SVG element.
     * @returns {Dimensions} Members width, height, and margin as numbers.
     */
    calcInnerDims() {
        const dims = super.calcInnerDims();
        if (this.showSolvers) dims.width += this.size.solverTree.width;

        return dims;
    }

    /**
     * Set the geometry of the main diagram elements for the first time, without
     * using transition animations. Adds solver support to the superclass.
     * @param {Object} dom Collection of D3 selections associated with the HTML elements.
     */
    applyGeometryFirstRun(dom) {
        super.applyGeometryFirstRun(dom);
        const innerDims = this.calcInnerDims();

        const x = this.size.partitionTree.width +
            innerDims.height + innerDims.margin * 2;
        const y = innerDims.margin;

        dom.pSolverTreeGroup
            .attr("height", innerDims.height)
            .attr("transform", `translate(${x},${y})`);        
    }

    /**
     * Update container element dimensions when a new layout is calculated,
     * and set up transition animations. Adds solver support to the superclass.
     * @param {Object} dom References to HTML elements.
     * @param {Number} transitionStartDelay ms to wait before performing transition
     * @param {Boolean} manuallyResized Have the diagram dimensions have been changed through UI
     */
     updateTransitionInfo(dom, transitionStartDelay, manuallyResized) {
        super.updateTransitionInfo(dom, transitionStartDelay, manuallyResized);
        const innerDims = this.calcInnerDims();
        const u = innerDims.unit;

        dom.pSolverTreeGroup.transition(sharedTransition)
            .style('height', innerDims.heightStyle)
            .style('transform', `translate(${this.size.partitionTree.width +
                innerDims.margin + innerDims.height +
                innerDims.margin}${u},${innerDims.margin}${u})`);
     }

    /**
     * Since the matrix portion of the diagram is square, calculate the width
     * based on the height of that, plus the model and solver trees, plus the margins.
     * @param {Number} height Height of the diagram.
     * @returns {Number} Calculated width of the diagram.
     */
    calcWidthBasedOnNewHeight(height) {
        let w = super.calcWidthBasedOnNewHeight(height);
        if (this.showSolvers) w += this.size.solverTree.width;
        return w;
    }

    /**
     * Since the matrix portion of the diagram is square, calculate the height
     * based on the width of that, minus the model and solver trees and margins.
     * @param {Number} width Width of the diagram.
     * @returns {Number} Calculated height of the diagram.
     */
    calcHeightBasedOnNewWidth(width) {
        let h = super.calcHeightBasedOnNewWidth(width);
        if (this.showSolvers) h += this.size.solverTree.width;
        return h;
    }

    /**
     * Make a copy of the previous transit coordinates and linear scalers before
     * setting new ones.
     */
    preservePreviousScaleValues() {
        super.preservePreviousScaleValues()

        this.treeSize.solver.preserve();
        if (this.showSolvers) this.scales.solver.preserve();
    }

    /**
     * Calculate the dimensions of the diagram in pixels as well as updating the linear
     * scale. Preserve the previous values if there are any.
     * Adds solver support to the superclass.
     */
    updateGeometryValues() {
        super.updateGeometryValues();
        const elemDims = this.zoomedElement.draw.solverDims;
        const initSize = this.size.solverTree;

        this.treeSize.solver.width = (elemDims.x ?
            initSize.width - this.size.parentNodeWidth : initSize.width) / (1 - elemDims.x);

        this.treeSize.solver.height = initSize.height / elemDims.height;

        if (this.showSolvers) {
            this.scales.solver.x
                .domain([elemDims.x, 1])
                .range([elemDims.x ? this.size.parentNodeWidth : 0, initSize.width]);

            this.scales.solver.y
                .domain([elemDims.y, elemDims.y + elemDims.height])
                .range([0, initSize.height]);
        }
    }
}



/**
 * Manage CSS styles for various elements. Adds handling for solvers and OM-specifc types.
 * @typedef OmStyle
 */
class OmStyle extends Style {
    // Define colors for each element type. Selected by Isaias Reyes
    static color = {
        ...Style.color,
        'outputImplicit': '#C7D06D',
        'outputExplicit': '#9FC4C6',
        'desvar': '#c5b0d5',
        'component': '#02BFFF',
        'declaredPartial': 'black',
        'autoivcInput': '#ff7000'
    };

    /*
    * This is how we want to map solvers to colors and CSS classes
    *    Linear             Nonlinear
    *    ---------          ---------
    * 0. None               None
    * 1. LN: LNBJ           NL: NLBJ
    * 2. LN: SCIPY
    * 3. LN: RUNONCE        NL: RUNONCE
    * 4. LN: Direct
    * 5. LN: PETScKrylov
    * 6. LN: LNBGS          NL: NLBGS
    * 7. LN: USER
    * 8.                    NL: Newton
    * 9.                    BROYDEN
    * 10. solve_linear      solve_nonlinear
    * 11. other             other

    * Later add these for linesearch ?
    * LS: AG
    * LS: BCHK
    */
    static solverStyleData = [
     // [linear,            non-Linear,        color    ]
        ['None',            'None',            '#8dd3c7'],
        ['LN: LNBJ',        'NL: NLBJ',        '#ffffb3'],
        ['LN: SCIPY',       null,              '#bebada'],
        ['LN: RUNONCE',     'NL: RUNONCE',     '#fb8072'],
        ['LN: Direct',      null,              '#80b1d3'],
        ['LN: PETScKrylov', null,              '#fdb462'],
        ['LN: LNBGS',       'NL: NLBGS',       '#b3de69'],
        ['LN: USER',        null,              '#fccde5'],
        [null,              'NL: Newton',      '#d9d9d9'],
        [null,              'BROYDEN',         '#bc80bd'],
        ['solve_linear',    'solve_nonlinear', '#ccebc5'],
        ['other',           'other',           '#ffed6f'],
    ];

    /** The solverStyleData array is split into objects with keys 'ln', 'nl', and 'color' */
    static solverStyleObject = [];

    /**
     * Initialize the OmStyle object.
     * @param {Object} svgStyle A reference to the SVG style section, which will be rewritten.
     * @param {Number} fontSize The font size to apply to text styles.
     */
    constructor(svgStyle, fontSize) {
        super(svgStyle, fontSize);
    }

    /** Make the data in OmStyle.solverStyleData more readable */
    _init() {
        this.solvers = {};
        const solverTypes = ['linear', 'nonLinear'];

        for (const sdata of OmStyle.solverStyleData) {
            for (let i = 0; i < 2; ++i) {
                if (sdata[i]) {
                    this.solvers[sdata[i]] = {
                        'name': sdata[i],
                        'type': solverTypes[i],
                        'class': 'solver_' +
                            sdata[i]
                                .toLowerCase()
                                .replace(/[: ]/g, '_')
                                .replace(/_+/g, '_'),
                        'style': {
                            'fill': sdata[2],
                            'cursor': 'pointer',
                            'fill-opacity': '.8',
                        },
                    };
                }
            }
        }
    }

    /**
     * Associate selectors with various style attributes. Adds support for OM components,
     * subsystems, implicit/explicit outputs, solvers, and Auto-IVC inputs.
     * @param {Number} fontSize The font size to apply to text styles.
     * @returns {Object} An object with selectors as keys, and values that are also objects,
     *     with style attributes as keys and values as their settings.
     */
    _createStyleObj(fontSize) {
        const newCssJson = super._createStyleObj(fontSize);

        const OmCssJson = {
            '#tree > g.output_implicit > rect': {
                'fill': OmStyle.color.outputImplicit,
                'fill-opacity': '.8',
            },
            '#tree > g.output > rect': {
                'fill': OmStyle.color.outputExplicit,
                'fill-opacity': '.8',
            },
            '#tree > g.subsystem > rect': {
                'cursor': 'pointer',
                'fill-opacity': '.8',
                'fill': OmStyle.color.group,
            },
            '#tree > g.component > rect': {
                'cursor': 'pointer',
                'fill-opacity': '.8',
                'fill': OmStyle.color.component,
            },
            '#svgId g.solver_group > text': {
                'text-anchor': 'end',
                'pointer-events': 'none',
                'font-family': 'helvetica, sans-serif',
                'font-size': fontSize + 'px',
            },
            '#tree > g.autoivc_input > rect': {
                'cursor': 'pointer',
                'fill-opacity': '.8',
                'fill': OmStyle.color.autoivcInput,
            },
        };

        for (const solverName in this.solvers) {
            const solver = this.solvers[solverName];

            OmCssJson[`g.${solver.class} > rect`] = solver.style;
        }

        return {...newCssJson, ...OmCssJson};
    }

    /**
     * Determine the name of the CSS class based on the name of the solver.
     * @param {Object} solverNames
     * @param {string} solverNames.linear The linear solver name.
     * @param {string} solverNames.nonLinear The non-linear solver name.
     * @return {string} The CSS class of the solver, or for "other" if not found.
     */
    getSolverClass(solverNames) {
        const solverName = OmTreeNode.showLinearSolverNames? solverNames.linear : solverNames.nonLinear;
        return this.solvers[solverName]? this.solvers[solverName].class : this.solvers.other.class;
    }

    /**
     * Based on the element's type and conditionally other info, determine
     * what CSS style is associated.
     * @param {OmTreeNode} node The item to check.
     * @return {string} The name of an existing CSS class.
     */
    getNodeClass(node) {
        if (node.draw.minimized) return 'minimized';

        switch (node.type) {
            case 'input':
                if (Array.isPopulatedArray(node.children)) return 'input_group';
                return 'input';

            case 'unconnected_input':
                if (Array.isPopulatedArray(node.children)) return 'input_group';
                return 'unconnected_input';

            case 'autoivc_input':
                return 'autoivc_input';

            case 'filter':
                return 'filter';

            case 'output':
                if (Array.isPopulatedArray(node.children)) return 'output_group';
                if (node.implicit) return 'output_implicit';
                return 'output';

            case 'root':
                return 'subsystem';

            case 'subsystem':
                if (node.subsystem_type == 'component') return 'component';
                return 'subsystem';

            default:
                throw `CSS class not found for node type: ${node.type}`
        }
    }
}

// Load solverStyleObject with values from solverStyleData
for (const solver of OmStyle.solverStyleData) {
    OmStyle.solverStyleObject.push({ ln: solver[0], nl: solver[1], color: solver[2] });
}





/**
 * Manage the set of buttons and tools at the left of the diagram.
 * @typedef OmToolbar
 * @property {Boolean} hidden Whether the toolbar is visible or not.
 */
class OmToolbar extends Toolbar {
    /**
     * Set up the event handlers for mouse hovering and clicking.
     * @param {OmUserInterface} ui Reference to the main interface object
     */
    constructor(ui) {
        super(ui);
    }

    /**
     * Associate all of the buttons on the toolbar with a method in OmUserInterface.
     * @param {OmUserInterface} ui A reference to the UI object
     */
    _setupButtonFunctions(ui) {
        super._setupButtonFunctions(ui);
        const self = this; // For callbacks that change "this". Alternative to using .bind().
        const tooltipBox = d3.select(".tool-tip");

        this._addButtonAtIndex(new ToolbarButtonClick('#linear-solver-button', tooltipBox,
            "Control solver tree display",
            () => { ui.setSolvers(true); ui.showSolvers(); }), 15);

        this._addButton(new ToolbarButtonClick('#linear-solver-button-2', tooltipBox,
            "Show linear solvers",
            (e, target) => {
                ui.setSolvers(true);
                ui.showSolvers();
                self._setRootButton(target);
            }));

        this._addButton(new ToolbarButtonClick('#non-linear-solver-button', tooltipBox,
            "Show non-linear solvers",
            (e, target) => {
                ui.setSolvers(false);
                ui.showSolvers();
                self._setRootButton(target);
            }));

        this._addButton(new ToolbarButtonClick('#no-solver-button', tooltipBox,
            "Hide solvers",
            (e, target) => {
                ui.hideSolvers();
                self._setRootButton(target);
            }));

        this._addButton(new ToolbarButtonToggle('#desvars-button', tooltipBox,
            ["Show optimization variables", "Hide optimization variables"],
            () => ui.desVars, () => ui.toggleDesVars()))
            .setHelpInfo("Toggle optimization variables");
    }

    _showHelp() {
        if (!this._helpWindow) {
            const version = d3.select('div#all-diagram-content').attr('data-openmdao-version');
            const footerText = `OpenMDAO Version ${version} Model Hierarchy and N2 diagram`;

            this._helpWindow = new DiagramHelp(this.helpInfo, footerText);
        }
        else this._helpWindow.show().modal(true);
    }
}




/** Display a subsection of options values in the info panel */
class InfoPropOptions extends InfoPropDefault {
    constructor(key, desc, solverType = null) {
        super(key, desc, false);
        this.solverType = solverType;
    }

    /** Also check whether there are any options in the list */
    canShow(node) {
        return (super.canShow(node) && Object.keys(node[this.key]).length > 0);
    }

    /**
     * There may be a list of options, so create a subsection in the table for them.
     * @param {Object} tbody D3 reference to an existing table body.
     * @param {TreeNode} node Reference to the node that may have the property.
     */
    addRow(tbody, node) {
        if (!this.canShow(node)) return;

        const val = node[this.key];

        let desc = this.desc;
        if (this.solverType) {
            desc += ': ' + node[this.solverType + '_solver'].substring(3);
        }

        // Add a subsection header for the option rows to follow
        tbody.append('tr').append('th')
            .text(desc)
            .attr('colspan', '2')
            .attr('class', 'options-header');

        for (const key of Object.keys(val).sort()) {
            const optVal = (val[key] === null) ? 'None' : val[key];
            InfoPropDefault.addRowWithVal(tbody, key, optVal);
        }
    }
}



/**
 * Manage a table containing all available metadata properties for
 * the currently active node, as well as whether the table is
 * visible or not.
 * @typedef OmNodeInfo
 */
class OmNodeInfo extends NodeInfo {
    /**
     * Build a list of the properties we care about and set up
     * references to the HTML elements.
     */
    constructor(ui) {
        super(ui);

        // Add potential properties to super class listing
        const newPropList = [
            this.propList[0], // path
            new InfoPropDefault('promotedName', 'Promoted Name'),
            this.propList[1], // class
            new InfoPropDefault('surrogate_name', 'Surrogate'),
            this.propList[2], // type
            new InfoPropDefault('dtype', 'DType'),

            new InfoPropDefault('units', 'Units'),
            new InfoPropDefault('shape', 'Shape'),
            new InfoPropYesNo('is_discrete', 'Discrete'),
            new InfoPropMessage('initial_value', '** Note **',
                                'Non-local values are not available under MPI, showing initial value.'),
            new InfoPropYesNo('distributed', 'Distributed'),
            this.propList[3], // val
            new InfoPropNumber('val_min', 'Minimum'),
            new InfoPropDefault('val_min_indices', 'Minimum Indices'),
            new InfoPropNumber('val_max', 'Maximum'),
            new InfoPropDefault('val_max_indices', 'Maximum Indices'),
            new InfoPropDefault('subsystem_type', 'Subsystem Type', true),
            new InfoPropDefault('component_type', 'Component Type', true),
            new InfoPropYesNo('implicit', 'Implicit'),
            new InfoPropYesNo('is_parallel', 'Parallel'),
            new InfoPropDefault('linear_solver', 'Linear Solver'),
            new InfoPropDefault('nonlinear_solver', 'Non-Linear Solver'),
            new InfoPropExpr('expressions', 'Expressions'),

            new InfoPropOptions('options', 'Options'),
            new InfoPropOptions('linear_solver_options', 'Linear Solver Options', 'linear'),
            new InfoPropOptions('nonlinear_solver_options', 'Non-Linear Solver Options', 'nonlinear'),
        ];

        this.propList = newPropList;
    }
}

/**
 * Manage a table containing all available metadata properties for
 * the currently active node, as well as whether the table is
 * visible or not.
 * @typedef OmSolverNodeInfo
 */
 class OmSolverNodeInfo extends NodeInfo {
    /**
     * Build a list of the properties we care about and set up
     * references to the HTML elements.
     */
    constructor(ui) {
        super(ui, false);

        // Potential solver properties
        this.propList = [
            new InfoPropDefault('path', 'Absolute Name'),
            new InfoPropOptions('linear_solver_options', 'Linear Solver Options', 'linear'),
            new InfoPropOptions('nonlinear_solver_options', 'Non-Linear Solver Options', 'nonlinear'),
        ];
    }
}



/**
 * Draw a symbol describing each of the element types.
 * @typedef OmLegend
 * @property {Boolean} shown Whether the legend is currently drawn or not.
 */
class OmLegend extends Legend {
    /**
     * Initializes the legend object.
     * @param {ModelData} modelData Symbols are only displayed if they're in the model
     */
    constructor(modelData) {
        super(modelData);
    }

    /**
     * Set the types to check for in the model to determine if they
     * need to be displayed in the legend.
     */
    _initItemTypes() {
        this.showSysVar = {
            'group': false,
            'component': false,
            'input': false,
            'desvars': false,
            'unconnectedInput': false,
            'autoivcInput': false,
            'outputExplicit': false,
            'outputImplicit': false,
            'collapsed': true,
            'connection': true,
            'declaredPartial': true
        };

        this.showSymbols = {
            'scalar': false,
            'vector': false,
            'collapsedVariables': false
        };

        this.sysAndVar = [
            { 'name': "Connection", 'color': OmStyle.color.connection },
            { 'name': "Collapsed", 'color': OmStyle.color.collapsed },
            { 'name': "Declared Partial", 'color': OmStyle.color.declaredPartial }
        ];
                
        const rootLinearSolver =
            OmStyle.solverStyleObject.find(x => x.ln === modelData.tree.linear_solver);
        const rootNonLinearSolver =
            OmStyle.solverStyleObject.find(x => x.nl === modelData.tree.nonlinear_solver);
        this.linearSolvers = [
            { 'name': modelData.tree.linear_solver, 'color': rootLinearSolver.color }
        ];

        this.nonLinearSolvers = [
            { 'name': modelData.tree.nonlinear_solver, 'color': rootNonLinearSolver.color }
        ];
    }

    /**
     * Determine which types of nodes are present in the model and only mark
     * those types of keys to be displayed in the legend.
     * @param {Object} nodes The model node tree.
     */
    _setDisplayBooleans(nodes) {
        for (const node of nodes) {
            const {
                group,
                component,
                desvar,
                input,
                unconnectedInput,
                outputExplicit,
                outputImplicit,
                collapsed,
                connection,
                declaredPartial
            } = this.showSysVar;

            const linearSolver = node.linear_solver;
            const nonLinearSolver = node.nonlinear_solver;

            const linearSolverIndex =
                this.linearSolvers.indexOf(this.linearSolvers.find(x => x.name === linearSolver))
            const nonLinearSolverIndex =
                this.nonLinearSolvers.indexOf(this.nonLinearSolvers.find(x => x.name === nonLinearSolver));

            if (linearSolverIndex < 0 && linearSolver !== undefined) {
                let solverStyle = OmStyle.solverStyleObject.find(x => x.ln === linearSolver);
                this.linearSolvers.push({
                    'name': solverStyle.ln,
                    'color': solverStyle.color
                });
            }

            if (nonLinearSolverIndex < 0 && nonLinearSolver !== undefined) {
                let solverStyle = OmStyle.solverStyleObject.find(x => x.nl === nonLinearSolver);
                this.nonLinearSolvers.push({
                    'name': solverStyle.nl,
                    'color': solverStyle.color
                });
            }

            if (node.hasChildren()) {
                if (!this.showSysVar.group && node.isGroup()) {
                    this.showSysVar.group = true;
                    this.sysAndVar.push({
                        'name': 'Group',
                        'color': OmStyle.color.group
                    })
                }
                else if (!this.showSysVar.component && node instanceof OmTreeNode &&
                    node.isComponent()) {
                    this.showSysVar.component = true;
                    this.sysAndVar.push({
                        'name': 'Component',
                        'color': OmStyle.color.component
                    })
                }
                this._setDisplayBooleans(node.children);
            }
            else {
                if (!this.showSysVar.input && node.isInput()) {
                    this.showSysVar.input = true;
                    this.sysAndVar.push({
                        'name': 'Input',
                        'color': OmStyle.color.input
                    })
                }
                else if (!this.showSysVar.outputExplicit && node instanceof OmTreeNode &&
                    node.isExplicitOutput()) {
                    this.showSysVar.outputExplicit = true;
                    this.sysAndVar.push({
                        'name': 'Explicit Output',
                        'color': OmStyle.color.outputExplicit
                    })
                }
                else if (!this.showSysVar.outputImplicit && node instanceof OmTreeNode &&
                    node.isImplicitOutput()) {
                    this.showSysVar.outputImplicit = true;
                    this.sysAndVar.push({
                        'name': 'Implicit Output',
                        'color': OmStyle.color.outputImplicit
                    })
                }
                else if (!this.showSysVar.autoivcInput && node instanceof OmTreeNode &&
                    node.isAutoIvcInput()) {
                    this.showSysVar.autoivcInput = true;
                    this.sysAndVar.push({
                        'name': 'Auto-IVC Input',
                        'color': OmStyle.color.autoivcInput
                    })
                }
                else if (!this.showSysVar.unconnectedInput && node.isUnconnectedInput()) {
                    this.showSysVar.unconnectedInput = true;
                    this.sysAndVar.push({
                        'name': 'Unconnected Input',
                        'color': OmStyle.color.unconnectedInput
                    })
                }
                else if (!this.showSysVar.desvar) {
                    this.showSysVar.desvar = true;
                    this.sysAndVar.push({
                        'name': 'Optimization Variables',
                        'color': OmStyle.color.desvar
                    })
                }
            }
        }
    }

    /** Add symbols for all of the items that were discovered */
    _setupContents() {
        super._setupContents();

        const solversLegend = d3.select('#solvers-legend')
        for (let item of this.linearSolvers) this._addItem(item, solversLegend);

        solversLegend.style('width', solversLegend.node().scrollWidth + 'px');

    }

    /**
     * Wipe the current solvers legend area and populate with the current setting.
     */
    updateSolvers() {
        const solversLegendTitle = d3.select('#solvers-legend-title');
        solversLegendTitle.text(OmTreeNode.showLinearSolverNames?
            "Linear Solvers" : "Non-Linear Solvers");

        const solversLegend = d3.select('#solvers-legend');
        solversLegend.html('');

        const solvers = OmTreeNode.showLinearSolverNames? this.linearSolvers : this.nonLinearSolvers;
        for (const item of solvers) this._addItem(item, solversLegend);

        solversLegend.style('width', solversLegend.node().scrollWidth + 'px');
    }
}


/**
 * Handle input events for the matrix and toolbar.
 * @typedef OmUserInterface
 */

class OmUserInterface extends UserInterface {
    /**
     * Initialize properties, set up the collapse-depth menu, and set up other
     * elements of the toolbar.
     * @param {OmDiagram} diag A reference to the main diagram.
     */
    constructor(diag) {
        super(diag);
    }

    /**
     * Separate these calls from the constructor so that subclasses can
     * set values before execution.
     */
    _init() {
        this.desVars = true;
        this.legend = new OmLegend(this.diag.modelData);
        this.toolbar = new OmToolbar(this);
    }

    /**
     * Create a regular node info window if the hovered object is not a solver,
     * or a solver node info window if it is.
     * @param {Selection} svgNodeGroup Selected object that triggered the event.
     */
    _newInfoBox(svgNodeGroup) {
        this.nodeInfoBox = svgNodeGroup.classed('solver_group')? 
            new OmSolverNodeInfo(this) : new OmNodeInfo(this);        
    }

    /** Determine the style of the inactive handle (overriding superclass) */
    _inactiveResizerHandlerStyle() {
        return this.diag.showSolvers?
            'inactive-resizer-handle' : 'inactive-resizer-handle-without-solvers'
    }

    /**
     * Wipe the current solvers legend area and populate with the other type.
     * @param {Boolean} linear True to use linear solvers, false for non-linear.
     */
    setSolvers(linear) {
        // Update the diagram
        OmTreeNode.showLinearSolverNames = linear;

        // update the legend
        this.legend.updateSolvers();

        if (this.legend.shown)
            this.legend.show();
        this.diag.update();
    }

    /** Display the solver tree. */
    showSolvers() {
        this.diag.showSolvers = true;
        this.diag.update();
        d3.select('#n2-resizer-handle').attr('class', 'inactive-resizer-handle')
    }

    /** Hide the solver tree. */
    hideSolvers() {
        this.diag.showSolvers = false;
        this.diag.update();
        d3.select('#n2-resizer-handle').attr('class', 'inactive-resizer-handle-without-solvers')
    }

    /** Show or hide design variables. */
    toggleDesVars() {
        if (this.desVars) {
            this.diag.showDesignVars();
            this.desVars = false;
        } else {
            this.diag.hideDesignVars();
            this.desVars = true;
        }

        d3.select('#desvars-button').attr('class',
            this.desVars ? 'fas icon-fx-2' : 'fas icon-fx-2 active-tab-icon');
    }

    /**
     * Minimize the specified node and recursively minimize its children.
     * @param {OmTreeNode} node The current node to operate on.
     */
     _collapseOutputs(node) {
        if (node.subsystem_type && node.subsystem_type == 'component') {
            node.minimize();
        }
        if (node.hasChildren()) {
            for (const child of node.children) {
                this._collapseOutputs(child);
            }
        }
    }

    /** Save the model state to a file. Adds solver support to the base class. */
    saveState() {
        // Solver toggle state.
        const extraData = {
            'showLinearSolverNames': OmTreeNode.showLinearSolverNames,
            'showSolvers': this.diag.showSolvers,            
        }

        super.saveState(extraData);
    }
}




class OmScalarScalarCell extends ScalarBase {
    constructor(color, id) {
        super(color, id);
    }
}

class OmScalarVectorCell extends VectorBase {
    constructor(color, id) {
        super(color, id);
    }
}

class OmVectorScalarCell extends VectorBase {
    constructor(color, id) {
        super(color, id);
    }
}

class OmVectorVectorCell extends VectorBase {
    constructor(color, id) {
        super(color, id);
    }
}

class OmScalarGroupCell extends GroupBase {
    constructor(color, id) {
        super(color, id);
    }
}

class OmGroupScalarCell extends GroupBase {
    constructor(color, id) {
        super(color, id);
    }
}

class OmVectorGroupCell extends GroupBase {
    constructor(color, id) {
        super(color, id);
    }
}

class OmGroupVectorCell extends GroupBase {
    constructor(color, id) {
        super(color, id);
    }
}

class OmGroupGroupCell extends GroupBase {
    constructor(color, id) {
        super(color, id);
    }
}



/**
 * @typedef {Object} OmSymbolType
 * @property {string} name What the symbol is called.
 * @property {Boolean} declaredPartial Whether the symbol is a declared partial.
 */
class OmSymbolType extends SymbolType {

    /**
     * Determine the name and whether it's a declared partial based on info
     * from the provided node.
     * @param {MatrixCell} cell The object to select the type from.
     * @param {OmModelData} model Reference to the model to get some info from it.
     */
    constructor(cell, model) {
        super(cell, model);
    }

    _init() {
        // Indicates that the type of symbol CAN be a declared partial
        // AND both source and target objects are part of the same component.
        this.potentialDeclaredPartial = false;

        this.declaredPartial = false;
    }

    /**
     * For symbols types that CAN be a declared partial, check whether they're
     * part of the same component and that they're in the declared partial list.
     * @param {OmTreeNode} cell The cell to operate on.
     * @param {ModelData} model Reference to the entire model.
     */
    _setDeclaredPartialInfo(cell, model) {
        if (cell.tgtObj.parentComponent === cell.srcObj.parentComponent) {
            this.potentialDeclaredPartial = true;
            this.declaredPartial = model.isDeclaredPartial(cell.srcObj, cell.tgtObj);
        }
    }

    /** 
     * Decide what object the cell will be drawn as, based on its position
     * in the matrix, type, source, target, and/or other conditions.
     * @param {MatrixCell} cell The cell to operate on.
     * @param {ModelData} model Reference to the entire model.
     */
    getType(cell, model) {
        if (cell.srcObj.isFilter() || cell.tgtObj.isFilter()) {
            this.name = 'filter';
        }
        else if (cell.onDiagonal()) {
            if (cell.srcObj.isSubsystem()) this.name = 'group';
            else if (cell.srcObj.isInputOrOutput()) {
                if (cell.srcObj.dtype == "ndarray") this.name = 'vector';
                else this.name = 'scalar';
            }
            else {
                throw (`Output symbol type '${cell.srcObj.type}' for cell on diagonal.`);
            }
        }
        else if (cell.srcObj.isSubsystem()) {
            if (cell.tgtObj.isSubsystem()) this.name = 'groupGroup';
            else if (cell.tgtObj.isInputOrOutput()) {
                if (cell.tgtObj.dtype == "ndarray") this.name = 'groupVector';
                else this.name = 'groupScalar';
            }
            else throw ("Output group symbol type.");
        }
        else if (cell.srcObj.isInputOrOutput() ) {
            if (cell.srcObj.dtype == "ndarray") {
                if (cell.tgtObj.isInputOrOutput()) {
                    if (cell.tgtObj.dtype == "ndarray" || cell.tgtObj.isInput()) {
                        this.name = 'vectorVector';
                        this._setDeclaredPartialInfo(cell, model);
                    }
                    else {
                        this.name = 'vectorScalar';
                        this._setDeclaredPartialInfo(cell, model);
                    }
                }

                else if (cell.tgtObj.isSubsystem()) this.name = 'vectorGroup';
                else throw ("Output vector symbol type.");
            }

            else if (cell.tgtObj.isInputOrOutput()) {
                if (cell.tgtObj.dtype == "ndarray") {
                    this.name = 'scalarVector';
                    this._setDeclaredPartialInfo(cell, model);
                }
                else {
                    this.name = 'scalarScalar';
                    this._setDeclaredPartialInfo(cell, model);
                }
            }

            else if (cell.tgtObj.isSubsystem()) this.name = 'scalarGroup';

            else throw ("Output vector or scalar symbol type.");
        }
        else {
            console.warn("Completely unrecognized symbol type for cell ", cell)
            throw ("Completely unrecognized symbol type.")
        }
    }
}


/**
 * A visible cell in the matrix grid.
 * @typedef {Object} OmMatrixCell
 * @property {number} row Vertical coordinate of the cell in the matrix.
 * @property {number} col Horizontal coordinate of the cell in the matrix.
 * @property {OmTreeNode} srcObj The node in the model tree this cell is associated with.
 * @property {OmTreeNode} tgtObj The model tree node that this outputs to.
 * @property {string} id The srcObj id appended with the tgtObj id.
 * @property {OmSymbolType} symbolType Info about the type of symbol represented by the node.
 * @property {CellRenderer} renderer The object that draws the cell.
 */
class OmMatrixCell extends MatrixCell {
    /**
     * Initialize the cell.
     * @param {number} row Vertical coordinate of the cell in the matrix.
     * @param {number} col Horizontal coordinate of the cell in the matrix.
     * @param {OmTreeNode} srcObj The node in the model tree this node is associated with.
     * @param {OmTreeNode} tgtObj The model tree node that this outputs to.
     * @param {ModelData} model Reference to the model to get some info from it.
     */
    constructor(row, col, srcObj, tgtObj, model) {
        super(row, col, srcObj, tgtObj, model);
    }

    _setSymbolType(model) {
        this.symbolType = new OmSymbolType(this, model);
    }

    /**
     * Choose a color based on our location and state of the associated OmTreeNode.
     */
    color() {
        if (this.symbolType.potentialDeclaredPartial &&
            this.symbolType.declaredPartial) return OmStyle.color.declaredPartial;

        if (this.onDiagonal()) {
            if (this.obj.draw.minimized) return OmStyle.color.collapsed;
            if (this.obj.isAutoIvcInput()) return OmStyle.color.autoivcInput;
            if (this.obj.isConnectedInput()) return OmStyle.color.input;
            if (this.obj.isUnconnectedInput()) return OmStyle.color.unconnectedInput;
            return (this.obj.implicit) ?
                OmStyle.color.outputImplicit :
                OmStyle.color.outputExplicit;
        }

        return OmStyle.color.connection;
    }

    /** Choose a renderer based on our SymbolType. */
    _newRenderer() {
        const renderer = super._newRenderer();
        if (renderer) return renderer;

        const color = this.color();

        switch (this.symbolType.name) {
            case "scalarScalar":
                return new OmScalarScalarCell(color, this.id);
            case "scalarVector":
                return new OmScalarVectorCell(color, this.id);
            case "vectorScalar":
                return new OmVectorScalarCell(color, this.id);
            case "vectorVector":
                return new OmVectorVectorCell(color, this.id);
            case "scalarGroup":
                return new OmScalarGroupCell(color, this.id);
            case "groupScalar":
                return new OmGroupScalarCell(color, this.id);
            case "vectorGroup":
                return new OmVectorGroupCell(color, this.id);
            case "groupVector":
                return new OmGroupVectorCell(color, this.id);
            case "groupGroup":
                return new OmGroupGroupCell(color, this.id);
            default:
                throw(`No known renderer for ${this.symbolType.name}`);
        }
    }
}



/**
 * Use the model tree to build the matrix of variables and connections, display, and
 * perform operations with it.
 * @typedef OmMatrix
 * @property {OmTreeNodes[]} nodes Reference to nodes that will be drawn.
 * @property {OmModelData} model Reference to the pre-processed model.
 * @property {OmLayout} layout Reference to object managing columns widths and such.
 * @property {Object} diagGroups References to <g> SVG elements created by Diagram.
 * @property {Number} levelOfDetailThreshold Don't draw elements below this size in pixels.
 * @property {Object} nodeSize Width and height of each node in the matrix.
 * @property {Object} prevNodeSize Width and height of each node in the previous matrix.
 * @property {Object[][]} grid Object keys corresponding to rows and columns.
 * @property {OmMatrixCell[]} visibleCells One-dimensional array of all cells, for D3 processing.
 */
class OmMatrix extends Matrix {
    /**
     * Render the matrix of visible elements in the model.
     * @param {OmModelData} model The pre-processed model data.
     * @param {OmLayout} layout Pre-computed layout of the diagram.
     * @param {Object} diagGroups References to <g> SVG elements created by Diagram.
     * @param {ArrowManager} arrowMgr Object to create and manage conn. arrows.
     * @param {Boolean} lastClickWasLeft
     * @param {function} findRootOfChangeFunction
     */
    constructor(model, layout, diagGroups, arrowMgr, lastClickWasLeft, findRootOfChangeFunction,
        prevNodeSize = { 'width': 0, 'height': 0 }) {
        super(model, layout, diagGroups, arrowMgr, lastClickWasLeft, findRootOfChangeFunction, prevNodeSize);

        this._nodeIdxCache = {};
    }

    /**
     * Add a cell to the grid Object and visibleCells array, with special
     * handling for declared partials.
     * @param {number} row Index of the row in the grid to place the cell.
     * @param {number} col Index of the column in the grid to place the cell.
     * @param {OmMatrixCell} newCell Cell created in _buildGrid().
     */
    _addCell(row, col, newCell) {
        if (this.model.useDeclarePartialsList &&
            newCell.symbolType.potentialDeclaredPartial &&
            !newCell.symbolType.declaredPartial) {

            return;
        }

        super._addCell(row, col, newCell);
    }

    /**
     * For cells that are part of cycles, determine if there are parts
     * of the cycle that are offscreen. If so, record them in the cell.
     * @param {OmMatrixCell} cell The cell to check.
     */
    _findUnseenCycleSources(cell) {
        const node = cell.tgtObj;
        if (!(node instanceof OmTreeNode)) return;
        
        const targetsWithCycleArrows = node.getNodesWithCycleArrows();

        const offscreenInit = cell.offScreen.total;

        for (const twca of targetsWithCycleArrows) {
            for (const ai of twca.cycleArrows) {
                let found = false;

                // Check visible nodes on the diagonal.
                for (const diagNode of this.diagNodes) {
                    const commonParent = diagNode.nearestCommonParent(ai.src);
                    if (diagNode.hasNode(ai.src, commonParent)) {
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    for (const tgt of ai.src.targetParentSet) {
                        if (tgt.absPathName == node.absPathName) {
                            debugInfo("Adding offscreen connection from _findUnseenCycleSources().")
                            debugInfo(`Offscreen cycle conn from ${ai.src.absPathName}(${ai.src.type}) to ${node.absPathName}(${node.type}).`)
                            cell.addOffScreenConn(ai.src, node);
                        }
                    }
                }
            }
        }
    }

    /**
     * Generate a new OmMatrixCell object. Overrides superclass definition.
     * @param {Number} row Vertical coordinate of the cell in the matrix.
     * @param {Number} col Horizontal coordinate of the cell in the matrix.
     * @param {OmTreeNode} srcObj The node in the model tree this node is associated with.
     * @param {OmTreeNode} tgtObj The model tree node that this outputs to.
     * @param {ModelData} model Reference to the model to get some info from it.
     * @returns {OmMatrixCell} Newly created cell.
     */
    _createCell(row, col, srcObj, tgtObj, model) {
        return new OmMatrixCell(row, col, srcObj, tgtObj, model);
    }

    /**
     * Handle solver processing and cycle arrows. Overrides superclass definition.
     * @param {Number} srcIdx Index of the diagonal node being processed.
     * @param {MatrixCell} newDiagCell A new cell being placed.
     */
    _customProcessing(srcIdx, newDiagCell) {
        const diagNode = this.diagNodes[srcIdx]

        // Solver nodes
        let solverNodes = null;
        if (diagNode.isInput()) { solverNodes = [diagNode]; }
        else if (diagNode.isInputFilter() && diagNode.count > 0) {
            solverNodes = diagNode.children;
        }
        else { solverNodes = []; }

        for (const solverNode of solverNodes) {
            for (let j = srcIdx + 1; j < this.diagNodes.length; ++j) {
                const tgtObj = this.diagNodes[j];
                if (solverNode.parentComponent !== tgtObj.parentComponent) break;

                if (tgtObj.isOutput() || tgtObj.isOutputFilter()) {
                    const tgtIdx = j;
                    const newCell = this._createCell(srcIdx, tgtIdx, solverNode, tgtObj, this.model);
                    this._addCell(srcIdx, tgtIdx, newCell);
                }
            }
        }

        this._findUnseenCycleSources(newDiagCell);
    }

    /**
     * Determine whether a connection has already been drawn. If not,
     * record that it has now.
     * @param {Number} startIndex The index of the first diagonal node.
     * @param {Number} endIndex The index of the last diagonal node.
     * @returns {Boolean} True if the connection is already drawn, otherwise false.
     */
    _checkDrawnList(startIndex, endIndex) {
        if (this._drawnList[startIndex] && this._drawnList[startIndex][endIndex]) return true;
        if (this._drawnList[endIndex] && this._drawnList[endIndex][startIndex]) return true;

        if (!this._drawnList[startIndex]) this._drawnList[startIndex] = {};
        this._drawnList[startIndex][endIndex] = true;
        return false;
    }

    /**
     * Determine which cycle arrows to draw in the lower-left corner of the matrix.
     * @param {Number} startIndex The index of the first diagonal node.
     * @param {Number} endIndex The index of the last diagonal node.
     */
    _addArrowsInputView(startIndex, endIndex) {
        if (this._checkDrawnList(startIndex, endIndex)) return;

        const boxInfo = this._boxInfo()
        const boxStart = boxInfo[startIndex],
            boxEnd = boxInfo[endIndex];

        // Draw multiple horizontal lines, but no more than one vertical line
        // for box-to-box connections
        for (let startsI = boxStart.startI; startsI <= boxStart.stopI; ++startsI) {
            for (let endsI = boxEnd.startI; endsI <= boxEnd.stopI; ++endsI) {
                if (startsI != endsI && this.exists(startsI, endsI)) {
                    if (!this._arrows[startsI]) this._arrows[startsI] = {};
                    this._arrows[startsI][endsI] = true;
                }
            }
        }
    }

    /**
     * Draw the accumulated set of arrows in the matrix.
     * @param {OmMatrixCell} cell Reference to the cell where the mouseover was triggered.
     */
    _drawArrowsInputView(cell) {
        for (const start in this._arrows) {
            for (const end in this._arrows[start]) {
                this.arrowMgr.addFullArrow(cell.id, {
                    'start': {
                        'col': start,
                        'row': start,
                        'id': this.grid[start][start].srcObj.id
                    },
                    'end': {
                        'col': end,
                        'row': end,
                        'id': this.grid[end][end].tgtObj.id
                    },
                    'color': (start < end) ?
                        OmStyle.color.outputArrow : OmStyle.color.inputArrow,
                });
            }
        }
    }

    /**
     * Find the index of the first node in this.diagNodes that "has" the supplied node.
     * For some reason Array.findIndex() did not work correctly for this. Found nodes
     * are cached with their index so the search doesn't have to be performed more
     * than once per node.
     * @param {OmTreeNode} node Reference to the node to search for.
     * @returns {Number} The index of the node if found, otherwise -1.
     */
    _findDiagNodeIndex(node) {
        if (this._nodeIdxCache[node.path]) {
            return this._nodeIdxCache[node.path];
        }

        for (const idx in this.diagNodes) {
            if (this.diagNodes[idx].hasNode(node)) {
                this._nodeIdxCache[node.path] = idx;
                return idx;
            }
        }

        return -1;
    }

    /**
     * Look for and draw cycle arrows of the specified cell.
     * @param {OmMatrixCell} cell The off-diagonal cell to draw arrows for.
     */
    drawOffDiagonalArrows(cell) {
        super.drawOffDiagonalArrows(cell);

        /* Cycle arrows are only drawn for cells in the bottom triangle of the diagram */
        if (cell.row > cell.col) {
            const src = this.diagNodes[cell.row],
                tgt = this.diagNodes[cell.col];

            // Accumulate what's been discovered/drawn in these to prevent duplicates
            this._drawnList = {};
            this._arrows = {};

            // Get an array of all the parents and children of the target with cycle arrows
            const relativesWithCycleArrows = tgt.getNodesWithCycleArrows();

            for (const relative of relativesWithCycleArrows) {
                for (const ai of relative.cycleArrows) {
                    if (src.hasNode(ai.src)) {
                        for (const arrow of ai.arrows) {
                            const firstBeginIndex = this._findDiagNodeIndex(arrow.begin);
                            if (firstBeginIndex == -1)
                                throw ("OmMatrix.drawOffDiagonalArrows() error: first begin index not found");

                            const firstEndIndex = this._findDiagNodeIndex(arrow.end);
                            if (firstEndIndex == -1)
                                throw ("OmMatrix.drawOffDiagonalArrows() error: first end index not found");

                            if (firstBeginIndex != firstEndIndex) {
                                this._addArrowsInputView(firstBeginIndex, firstEndIndex);
                            }
                        }
                    }
                }
            }

            this._drawArrowsInputView(cell)
        }
    }
}


/**
 * Manage all components of the application. The model data, the CSS styles, the
 * user interface, the layout of the matrix, and the matrix grid itself are
 * all member objects. OmDiagram adds handling for solvers.
 * @typedef OmDiagram
 */
class OmDiagram extends Diagram {
    /**
     * Set initial values.
     * @param {Object} modelJSON The decompressed model structure.
     */
    constructor(modelJSON) {
        super(modelJSON, false);

        // Solver tree initial dimensions are the same as the model tree
        this.dims.size.solverTree = {...this.dims.size.partitionTree};

        this._init();
    }

    _newModelData() {
        this.model = new OmModelData(this.modelData);
    }

    /** Override Diagram._newLayout() to create an OmLayout object. */
    _newLayout() {

        if (this.showSolvers === undefined)
            this.showSolvers = true;

        return new OmLayout(this.model, this.zoomedElement, this.dims, this.showSolvers);
    }

    /** Create a new OmMatrix object. Overrides superclass method. */
    _newMatrix(lastClickWasLeft, prevCellSize = null) {
        return new OmMatrix(this.model, this.layout, this.dom.diagGroups,
            this.arrowMgr, lastClickWasLeft, this.ui.findRootOfChangeFunction, prevCellSize);
    }

    /**
     * Separate these calls from the constructor so that subclasses can
     * set values before execution.
     */
     _init() {
        this.style = new OmStyle(this.dom.svgStyle, this.dims.size.font);
        this.layout = this._newLayout();
        this.ui = new OmUserInterface(this);
        this.matrix = this._newMatrix(true);
    }

    /**
     * Setup internal references to D3 objects so we can avoid running
     * d3.select() over and over later.
     */
    _referenceD3Elements() {
        super._referenceD3Elements();
        this.dom.pSolverTreeGroup = d3.select('g#solver_tree');
        this.dom.clips.solverTree = d3.select("#solverTreeClip > rect");
    }

    /**
     * Add SVG groups & contents coupled to the visible nodes in the trees.
     * Select all <g> elements that have class "solver_group". If any already
     * exist, join to their associated nodes in the solver tree. If no
     * existing <g> matches a displayable node, add it to the "enter"
     * selection so the <g> can be created. If a <g> exists but there is
     * no longer a displayable node for it, put it in the "exit" selection so
     * it can be removed:
     */
    _updateTreeCells() {
        super._updateTreeCells();

        const self = this;
        const scale = this.layout.scales.solver;
        const treeSize = this.layout.treeSize.solver;

        this.dom.pSolverTreeGroup.selectAll("g.solver_group")
            .data(this.layout.zoomedSolverNodes, d => d.id)
            .join(
                enter => self._addNewSolverCells(enter, scale, treeSize),
                update => self._updateExistingSolverCells(update, scale, treeSize),
                exit => self._removeOldSolverCells(exit, scale, treeSize)
            )
    }

    /**
     * Using the visible nodes in the solver tree as data points, create SVG objects to
     * represent each one. Dimensions are obtained from the precalculated layout.
     * @param {Selection} enter The selection to add <g> elements and children to.
     * @param {Scale} scale Linear scales of the diagram width and height.
     * @param {Dimensions} treeSize Actual width and height of the tree in pixels.
     */
    _addNewSolverCells(enter, scale, treeSize) {
        const self = this; // For callbacks that change "this".

        // Create a <g> for each node in zoomedSolverNodes that doesn't already have one.
        // Dimensions are obtained from the previous geometry so the new nodes can appear
        // to transition to the new size together with the existing nodes.
        const enterSelection = enter
            .append("g")
            .attr("class", d => {
                const solver_class = self.style.getSolverClass({ 'linear': d.linear_solver,
                    'nonLinear': d.nonlinear_solver });
                return `${solver_class} solver_group ${self.style.getNodeClass(d)}`;
            })
            .on("click", (e,d) => self.leftClickSelector(e, d))
            .on("contextmenu", (e,d) => self.ui.rightClick(e, d))
            .on("mouseover", (e,d) => {
                self.ui.showInfoBox(e, d);

                if (self.model.abs2prom != undefined) {
                    if (d.isInput()) {
                        return self.dom.toolTip.text(self.model.abs2prom.input[d.path])
                            .style("visibility", "visible");
                    }
                    if (d.isOutput()) {
                        return self.dom.toolTip.text(self.model.abs2prom.output[d.path])
                            .style("visibility", "visible");
                    }
                }
            })
            .on("mouseleave", () => {
                self.ui.removeInfoBox();

                if (self.model.abs2prom != undefined) {
                    self.dom.toolTip.style("visibility", "hidden");
                }
            })
            .on("mousemove", e => {
                self.ui.moveInfoBox(e);

                if (self.model.abs2prom != undefined) {
                    self.dom.toolTip.style("top", (e.pageY - 30) + "px")
                        .style("left", (e.pageX + 5) + "px");
                }
            });

        enterSelection
            .transition(sharedTransition)
            .attr("transform", d => {
                // The magic for reversing the blocks on the right side
                // The solver tree goes from the root on the right and expands to the left
                const x = 1.0 - d.draw.solverDims.x - d.draw.solverDims.width;

                return `translate(${scale.x(x)},${scale.y(d.draw.solverDims.y)})`;
            })

        enterSelection // Add the visible rectangle
            .append("rect")
            .transition(sharedTransition)
            .attr("width", d => d.draw.solverDims.width * treeSize.width)
            .attr("height", d => d.draw.solverDims.height * treeSize.height)
            .attr("id", d => d.path.replace(/\./g, '_'))
            .attr('rx', 12)
            .attr('ry', 12);

        enterSelection // Add a label
            .append("text")
            .text( d => d.getSolverText())
            .style('visibility', 'hidden')
            .attr("dy", ".35em")
            .attr("transform", d => {
                const anchorX = d.draw.solverDims.width * treeSize.width -
                    self.layout.size.rightTextMargin;
                return `translate(${anchorX},${d.draw.solverDims.height * treeSize.height / 2})`;
            })
            .style("opacity", d => (d.depth < self.zoomedElement.depth)? 0 : d.textOpacity)
            .transition(sharedTransition)
            .on('end', function() { d3.select(this).style('visibility', 'visible'); } )

        return enterSelection;
    }

    /**
     * Update the geometry for existing <g> with a transition.
     * @param {Selection} update The selected group of existing solver tree <g> elements.
     * @param {Scale} scale Linear scales of the diagram width and height.
     * @param {Dimensions} treeSize Actual width and height of the tree in pixels.
     */
     _updateExistingSolverCells(update, scale, treeSize) {
        const self = this; // For callbacks that change "this".

        this.dom.clips.solverTree
            .transition(sharedTransition)
            .attr('height', this.dims.size.solverTree.height);

        // New location for each group
        const mergedSelection = update
            .attr("class", d => {
                const solver_class = self.style.getSolverClass({ 'linear': d.linear_solver,
                    'nonLinear': d.nonlinear_solver });
                return `${solver_class} solver_group ${self.style.getNodeClass(d)}`;
            })
            .transition(sharedTransition)
            .attr("transform", d => {
                // The magic for reversing the blocks on the right side
                const x = 1.0 - d.draw.solverDims.x - d.draw.solverDims.width;

                return `translate(${scale.x(x)},${scale.y(d.draw.solverDims.y)})`;
            });

        // Resize each rectangle      
        mergedSelection
            .select("rect")
            .attr("width", d => d.draw.solverDims.width * treeSize.width)
            .attr("height", d => d.draw.solverDims.height * treeSize.height);

         // Move the text label
        mergedSelection
            .select("text")
            .text( d => d.getSolverText())
            .attr("transform", d => {
                const anchorX = d.draw.solverDims.width * treeSize.width -
                    self.layout.size.rightTextMargin;
                return `translate(${anchorX},${d.draw.solverDims.height * treeSize.height / 2})`;
            })
            .style("opacity", d => (d.depth < self.zoomedElement.depth)? 0 : d.textOpacity);

        return mergedSelection;
    }

    /**
     * Remove <g> that no longer have displayable nodes associated with them, and
     * transition them away.
     * @param {Selection} exit The selected group of solver tree <g> elements to remove.
     * @param {Scale} scale Linear scales of the diagram width and height.
     * @param {Dimensions} treeSize Actual width and height of the tree in pixels.
     */
    _removeOldSolverCells(exit, scale, treeSize) {
        const self = this; // For callbacks that change "this".

        // Transition exiting nodes to the parent's new position.
        const exitSelection = exit.transition(sharedTransition);

        if (this.showSolvers) {
            exitSelection.attr("transform", d =>
                `translate(${scale.x(d.draw.solverDims.x)},${scale.y(d.draw.solverDims.y)})`)
        }

        exitSelection.select("rect")
            .attr("width", d => d.draw.solverDims.width * treeSize.width)
            .attr("height", d => d.draw.solverDims.height * treeSize.height);

        exitSelection.select("text")
            .attr("transform", d => {
                const anchorX = d.draw.solverDims.width * treeSize.width -
                    self.layout.size.rightTextMargin;
                return `translate(${anchorX},${d.draw.solverDims.height * treeSize.height / 2})`;
            })
            .style("opacity", 0);

        exitSelection.on('end', function() {d3.select(this).remove(); })

        return exitSelection;
    }

    /** Add the opt-vars class to design variable elements to set the fill color */
    showDesignVars() {
        [Object.keys(modelData.design_vars), Object.keys(modelData.responses)].flat().forEach(
            path => d3.select(`#${TreeNode.pathToId(path)}`).classed('opt-vars', true)
            );
        d3.select('.model_tree_grp #_auto_ivc').classed('opt-vars', true)
    }

    /** Remove the opt-vars class from design variable elements to use the default fill color */
    hideDesignVars() {
        [Object.keys(modelData.design_vars), Object.keys(modelData.responses)].flat().forEach(
            path => d3.select(`#${TreeNode.pathToId(path)}`).classed('opt-vars', false)
            );
        d3.select("#_auto_ivc").classed('opt-vars', false)
    }

    /**
     * Refresh the diagram when something has visually changed. Adds the ability to handle
     * design vars for OpenMDAO.
     * @param {Boolean} [computeNewTreeLayout = true] Whether to rebuild the layout and
     *  matrix objects.
     */
    async update(computeNewTreeLayout = true) {
        await super.update(computeNewTreeLayout);

        if (!this.ui.desVars) this.showDesignVars()
    }

    /**
     * Updates the intended dimensions of the diagrams and font, but does
     * not perform rendering itself.
     * @param {number} height The base height of the diagram without margins.
     * @param {number} fontSize The new size of the font.
     */
    updateSizes(height, fontSize) {
        super.updateSizes(height, fontSize);
        this.dims.size.solverTree.height = height;
    }

    /**
     * Using an object populated by loading and validating a JSON file, set the model
     * to the saved view. Adds solver-handling capability to the superclass function.
     * @param {Object} oldState The model view to restore.
     */
     restoreSavedState(oldState) {
        // Solver toggle state.
        OmTreeNode.showLinearSolverNames = oldState.showLinearSolverNames;
        this.ui.setSolvers(oldState.showLinearSolverNames);
        this.showSolvers = oldState.showSolvers;
        
        super.restoreSavedState(oldState);       
     }
}


var sharedTransition = null;

var enterIndex = 0;
var exitIndex = 0;

// The modelData object is generated and populated by n2_viewer.py
let modelData = OmModelData.uncompressModel(compressedModel);
delete compressedModel;

var n2MouseFuncs = null;

function n2main() {
    const n2Diag = new OmDiagram(modelData);
    n2MouseFuncs = n2Diag.getMouseFuncs();

    n2Diag.update(false);
}

// wintest();
n2main();

</script>

</body>
</html>
